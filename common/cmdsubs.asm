		TITLE	CMDSUBS - Copyright (c) SLR Systems 1994

		INCLUDE MACROS
		INCLUDE	SECTS
		INCLUDE	IO_STRUC
		INCLUDE	SECTIONS

		PUBLIC	_set_case_mode,IGNORECASE_PROC,NOIGNORECASE_PROC,MAPSTUFF,PATHSTUFF,NOCHECKSUM_PROC,NEST_INDIRECT
		PUBLIC	UPPERCASE_PROC,LOWERCASE_PROC,CHECKSUM_PROC,OBJSTUFF,LOCAL_INFO,NULSTUFF
		PUBLIC	DOSSEG_PROC,MIXCASE_PROC,EXESTUFF,RES_LOGO_OUTPUT,GET_SYMBOL,YYLEX_SYMBOL,ERRORDELETE_PROC,NOLOGO_PROC
		PUBLIC	SILENT_PROC,RES_ECHO_IND,VERBOSE_PROC,SET_REORDER_ALLOWED,NONULLSDOSSEG_PROC,NOERRORDELETE_PROC
		PUBLIC	RES_REORDER_ALLOWED,YYLEX_FILENAME,HANDLE_EOF,TOKEN_TOO,HELP_PROC_1,GET_KEYWORD,GETNST
		PUBLIC	SET_ECHO_IND,GET_LINE,VERIFY_SECTION,DO_NEW_SECTION,INIT_AREA,NOGROUPSTACK_PROC,GROUPSTACK_PROC
		PUBLIC	SET_PACKFUNCTIONS,RES_PACKFUNCTIONS,GET_NEXT,SEE_NEXT,INDIR_STUFF,YY_FILENAME,PARSE_TABLE


		.DATA

		EXTERNDEF	CODEVIEW_BYTE:BYTE,OUTBUF:BYTE,TEMP_RECORD:BYTE,INBUF:BYTE,FNTBL:BYTE,CURN_PLTYPE:BYTE
		EXTERNDEF	CACHE_DEFAULT_BYTE:BYTE,COMPRESS_DEFAULT_BYTE:BYTE,CASE_TYPE:BYTE,COMMENT_CHAR:BYTE
		EXTERNDEF	FIRST_SECTION_PLTYPE:BYTE,SYMBOL_TEXT:BYTE

		EXTERNDEF	SYMBOL_LENGTH:DWORD,CURN_COUNT:DWORD,FILESTUFF_PTR:DWORD,SECTION_NUMBER:DWORD,INDIRECT_LEVEL:DWORD
		EXTERNDEF	AREA_COUNT:DWORD,NEXT_READ_THREAD:DWORD,INPTR1:DWORD,THREAD_STACKS:DWORD,PLINK_LEVEL:DWORD
		EXTERNDEF	TOKSTR:DWORD,MAX_LEVEL:DWORD,IND_DEVICE:DWORD,CURN_SECTION_GINDEX:DWORD,CURN_AREA_GINDEX:DWORD
		EXTERNDEF	SYMBOL_HASH:DWORD,CURN_OUTFILE_GINDEX:DWORD,CURN_INPTR:DWORD,INDIR_TABLE:DWORD,SECTION_COUNT:DWORD
		EXTERNDEF	ENVIRONMENT_BLOCK:DWORD,FIRST_AREA_GINDEX:DWORD,FIRST_SECTION_GINDEX:DWORD,LAST_SECTION_GINDEX:DWORD
		EXTERNDEF	ME_PTR:DWORD,ME_PATH_LEN:DWORD

		EXTERNDEF	FILNAM:NFN_STRUCT,SRCNAM:NFN_STRUCT,SYMBOL_TPTR:TPTR_STRUCT,FILE_LIST_SEM:QWORD,INDNAM:NFN_STRUCT
		EXTERNDEF	MYI_STUFF:MYI_STRUCT

		EXTERNDEF	SECTION_GARRAY:STD_PTR_S,AREA_GARRAY:STD_PTR_S

		EXTERNDEF	OPTI_MOVE:DWORD,OPTI_HASH:DWORD,CASE_STRING_COMPARE:DWORD

                EXTERNDEF	GINPUT_LINE_NUMBER:DWORD

XSEG		SEGMENT	AT 0

X		MYI_STRUCT	<>

XSEG		ENDS


		.CODE	FILEPARSE_TEXT

		externdef	_unget_char:proc
		externdef	_store_filnam:proc
		EXTERNDEF	OPTI_MOVE_PRESERVE_SIGNIFICANT:PROC,DO_FINDFIRST:PROC,RETT:PROC,OS2_FIXER:PROC,_ret_true:PROC
		EXTERNDEF	RET_FALSE:PROC,_issue_prompt:PROC,_err_abort:proc,OPTI_MOVE_PRESERVE_IGNORE:PROC
		EXTERNDEF	OPTI_MOVE_UPPER_IGNORE:PROC,PROCESS_DEF:PROC,OBJ_PLUS_ABSORBER:PROC,OPTI_MOVE_LOWER_IGNORE:PROC
		EXTERNDEF	DO_FINDNEXT:PROC,FILENAME_INSTALL:PROC,_move_nfn:proc,PLUS_ABSORBER:PROC,EXE_PROC:PROC,_abort:proc
		EXTERNDEF	INIT_THREAD:PROC,DO_CAPTURE_SSAX:PROC,LOUTALL_CON:PROC,ERR_INBUF_ABORT:PROC,_open_input:proc
		EXTERNDEF	SIGNON:PROC,ERR_DSSI_FN_ABORT:PROC,_end_of_indirect:proc,DO_RELEASE_SSAX:PROC,_proper_prompt:PROC
		EXTERNDEF	_do_filename:proc,DO_DOSSEMCLEAR_DSAX:PROC,LOUTALL_CON:PROC,ERR_INBUF_RET:PROC
		EXTERNDEF	CASE_STRING_COMPARE_EASY:PROC,CASE_STRING_COMPARE_HARD:PROC,OPTI_HASH_IGNORE:PROC
		EXTERNDEF	OPTI_HASH_SIGNIFICANT:PROC,GET_NEW_IO_LOG_BLK:PROC,ERR_NFN_ABORT:PROC,FORCE_SIGNON:PROC

		EXTERNDEF	TOKEN_TOO_LONG_ERR:ABS,FILE_EXP_ERR:ABS,FILE_NOT_FOUND_ERR:ABS,ENDAREA_ERR:ABS,DUP_SECTION_ERR:ABS
		EXTERNDEF	AREA_DEEP_ERR:ABS,ID_EXP_ERR:ABS,INDIRECT_DEEP_ERR:ABS,FILENAME_ERR:ABS

		externdef	_switch_help:proc

GET_LINE	PROC
		;
		;GET NEXT LINE OF INPUT FROM INPUT STREAM... INTO INBUF
		;
		PUSH	ESI
		GETT	CL,GET_LINE_PARTIAL
		PUSH	EDI
		MOV	EDI,OFF INBUF+4
		TEST	CL,CL
		PUSH	EBX
		JNZ	L6$
		MOV	INPTR1,EDI
		BITT	INBUF_EOF
		JNZ	L99$

		BITT	INDIRECT_MODE
		JZ	L1$
		BITT	ECHO_INDIRECT
		JZ	L1$
		CALL	_issue_prompt
		;
		;STARTING A BRAND NEW LINE
		;
		JMP	L1$

L99$:
		;
		;END OF FILE
		;
		XOR	EAX,EAX
		STC
		MOV	BPTR [EDI],1AH
		POPM	EBX,EDI,ESI
		MOV	DPTR INBUF,1
		RET

L6$:
		;
		;PARTIAL LINE BEFORE, MOVE BUFFER DOWN, AND READ SOME MORE PLEASE...
		;
		MOV	ECX,DPTR INBUF
		MOV	ESI,INPTR1
		MOV	INPTR1,EDI
		SUB	ECX,ESI
		XOR	AL,AL
		ADD	ECX,EDI
		RESS	GET_LINE_PARTIAL,AL
		OPTI_MOVSB
		JMP	L1$


L9$:
		SETT	GET_LINE_PARTIAL
		JMP	L42$

L41$:
		CALL	GET_NEXT_CHAR
		CMP	AL,0AH
		JZ	L4$
		DEC	CURN_INPTR
		INC	CURN_COUNT
		JMP	L4$

L2$:
		;
		;^ ESCAPE CHARACTER
		;
		STOSB
		CALL	GET_NEXT_CHAR
L0$:
		MOV	[EDI],AL
		CMP	EDI,OFF INBUF+INBUF_LEN-4-1;MAX LINE LENGTH-2
		LEA	EDI,[EDI+1]
		JAE	L9$			;WILL BE A PARTIAL LINE...
L1$:
		CALL	GET_NEXT_CHAR
		CMP	AL,'^'
		JZ	L2$
		CMP	AL,0DH
		JZ	L41$
		CMP	AL,0AH
		JZ	L4$
		CMP	AL,'@'
		JZ	L3$
		CMP	COMMENT_CHAR,AL
		JNZ	L0$
		;
		;COMMENT CHARACTER...
		;
L70$:
		CALL	GET_NEXT_CHAR
		CMP	AL,0DH
		JZ	L41$			;VALID END OF COMMENT
		CMP	AL,0AH
		JNZ	L70$
L4$:
		;
		;END OF LINE
		;
		MOV	WPTR [EDI],0A0DH
		ADD	EDI,2
		INC	GINPUT_LINE_NUMBER
L42$:
;		MOV	CURN_INPTR,ESI
		MOV	EAX,EDI
		GETT	CL,INDIRECT_MODE
		SUB	EAX,OFF INBUF+4
		TEST	CL,CL
		MOV	DPTR INBUF,EAX
		JZ	L429$
		BITT	ECHO_INDIRECT
		JZ	L429$
		PUSH	EAX
		CALL	SIGNON
		POP	ECX
		MOV	EAX,OFF INBUF+4
		CALL	LOUTALL_CON
L429$:
		POPM	EBX,EDI,ESI
		XOR	EAX,EAX
		RET

L3$:
		CMP	EDI,OFF INBUF+4		;BEGINNING OF LINE, GO AHEAD
		MOV	CL,BPTR [EDI-1]
		JZ	L32$
		CMP	CL,' '		;OR PRECEDED BY A SPACE
		JZ	L32$
		CMP	CL,9		;OR TAB
		JZ	L32$
		CMP	CL,'+'
		JZ	L32$
		CMP	CL,','		;OR COMMA
		JNZ	L00$
		;
		;OPEN UP INDIRECT COMMAND FILE
		;
L32$:
		BITT	SUPPORT_AT_INDIRECT
		JZ	L00$

		CALL	INDIRECT
		JMP	L1$

L00$:
		JMP	L0$

GET_LINE	ENDP


GET_NEXT_CHAR	PROC
		;
		;GET CHAR, REFILL BUFFER AND/OR UNNEST IF NEEDED
		;
		MOV	ECX,CURN_COUNT
		MOV	EDX,CURN_INPTR

		DEC	ECX
		JZ	L5$

		MOV	AL,[EDX]
		INC	EDX

		MOV	CURN_COUNT,ECX
		MOV	CURN_INPTR,EDX

		CMP	AL,1AH
		JZ	L6$

		RET

L5$:
		CALL	TRY_ANOTHER_BUFFER
		JMP	GET_NEXT_CHAR

L6$:
		CALL	TRY_UNNESTING
		JC	L8$
		;
		;FOR MS CMDLINE, IGNORE CR IMMEDIATELY FOLLOWING EOF
		;
L7$:
		CALL	GET_NEXT_CHAR

		CMP	AL,0DH			;SKIP CR LF
		JZ	L71$

		CMP	AL,0AH
		JNZ	L9$
L75$:
		BITT	INBUF_EOF
		JZ	GET_NEXT_CHAR
L8$:
		SETT	INBUF_EOF
		MOV	AL,0AH
L9$:
		RET

L71$:
		CALL	GET_NEXT_CHAR

		CMP	AL,0AH
		JZ	L75$

		DEC	CURN_INPTR
		INC	CURN_COUNT

		MOV	AL,0AH

		RET

GET_NEXT_CHAR	ENDP



TRY_ANOTHER_BUFFER	PROC
		;
		;
		;
		MOV	EAX,IND_DEVICE
		ASSUME	EAX:PTR MYI_STRUCT

		TEST	EAX,EAX
		JZ	L9$

		push	EAX
		CALL	[EAX].MYI_FILLBUF
		add	ESP,4

		MOV	ECX,[EAX].MYI_COUNT
		MOV	EDX,[EAX].MYI_PTRA

		TEST	ECX,ECX
		JZ	L7$

		INC	ECX
		MOV	CURN_INPTR,EDX

		MOV	CURN_COUNT,ECX

		RET

L9$:
		BITT	DOING_CFG
		JNZ	L7$
		BITT	CMDLINE_FINAL
		JNZ	L7$
		;
		;GO AHEAD AND PROMPT FOR INPUT
		;
		CALL	SIGNON
		CALL	_proper_prompt
		RET

L7$:
		MOV	EAX,OFF TEMP_RECORD

		MOV	CURN_COUNT,2

		MOV	CURN_INPTR,EAX
		MOV	BPTR [EAX],1AH

		RET

TRY_ANOTHER_BUFFER	ENDP


TRY_UNNESTING	PROC
		;
		;
		;
		MOV	EAX,IND_DEVICE
		TEST	EAX,EAX
		JZ	L9$
		CALL	DO_UNNEST
		OR	EAX,EAX			;CLEAR CARRY
		RET

L9$:
		STC
		RET

TRY_UNNESTING	ENDP


DO_UNNEST	PROC
		;
		;RETURN TO PREVIOUS INDIRECTION LEVEL
		;
		CALL	_end_of_indirect 	;CLOSE AND RELEASE

		PUSHM	EDI,ESI

		MOV	ESI,INDIRECT_LEVEL
		DEC	INDIRECT_LEVEL
		JNZ	L1$
		RESS	INDIRECT_MODE
L1$:
		MOV	ECX,3
		MOV	ESI,INDIR_TABLE[ESI*4]
		MOV	EDI,OFF CURN_INPTR
		REP	MOVSD			;MOVE CURN_INPTR, CURN_COUNT, IND_DEVICE

		MOV	EDI,IND_DEVICE
		MOV	CL,(MYI_STRUCT.MYI_FILLBUF+4)/4

		OR	EDI,EDI
		JZ	L9$

		REP	MOVSD			;MOVE THRU MYI_FILLBUF
L9$:
		POPM	ESI,EDI

		RET

DO_UNNEST	ENDP


INDIRECT	PROC
		;
		;SET UP TO READ FROM INDIRECT COMMAND FILE
		;
		PUSHM	EDI,EBX		;PLACE TEXT GOES
		XOR	EAX,EAX
		MOV	EBX,OFF FNTBL
		MOV	EDI,OFF INDNAM.NFN_TEXT	;PROBABLY IN TEMP_RECORD
		JMP	L1$

L6$:
		CALL	GET_NEXT_CHAR
		CMP	AL,'"'
		JZ	L1$			;END SPECIAL HANDLING
		CMP	EDI,OFF INDNAM.NFN_TEXT+NFN_TEXT_SIZE-1
		MOV	[EDI],AL
		JA	L5$
		INC	EDI
		CMP	AL,' '
		MOV	AL,[EBX+EAX]
		JZ	L6$
		TEST	EAX,MASK FNTBL_ILLEGAL
		JZ	L6$
		JMP	L15$

L5$:
		CALL	TOKEN_TOO


L1$:
		CALL	GET_NEXT_CHAR
		CMP	AL,'"'
		MOV	[EDI],AL
		JZ	L6$			;SPECIAL HANDLING
		INC	EDI
		MOV	AL,[EBX+EAX]
		CMP	EDI,OFF INDNAM.NFN_TEXT+NFN_TEXT_SIZE
		JA	L5$
		TEST	EAX,MASK FNTBL_ILLEGAL
		JZ	L1$
L15$:
		CALL	_unget_char		;STORES POINTER TOO
		SUB	EDI,OFF INDNAM.NFN_TEXT+1
		MOV	EAX,OFF INDIR_STUFF
		MOV	INDNAM.NFN_TOTAL_LENGTH,EDI
		MOV	ECX,OFF INDNAM

		push	EAX
		push	ECX
		call	_do_filename
		add	ESP,8

		CALL	NEST_INDIRECT

		POPM	EBX,EDI
		RET

INDIRECT	ENDP


NEST_INDIRECT	PROC
		;
		;
		;
		PUSHM	EDI,ESI

		SETT	INDIRECT_MODE

		MOV	EDI,INDIRECT_LEVEL	;STORE INFO FOR NESTING...
		MOV	ESI,OFF CURN_INPTR

		INC	EDI
		XOR	ECX,ECX

		MOV	INDIRECT_LEVEL,EDI
		CMP	EDI,INDIRECT_NEST_LIMIT

		MOV	ECX,INDIR_TABLE[EDI*4]
		JA	L5$

		TEST	ECX,ECX
		JZ	L2$			;GO ALLOCATE SPACE
L3$:
		MOV	EDI,ECX
		MOV	ECX,3

		REP	MOVSD			;MOVE CURN_INPTR, CURN_COUNT, IND_DEVICE

		MOV	ESI,IND_DEVICE
		MOV	CL,(MYI_STRUCT.MYI_FILLBUF+4)/4

		TEST	ESI,ESI
		JZ	L33$

		REP	MOVSD			;STORE HANDLE, PTRS, COUNTS
L33$:
		MOV	EDI,OFF CURN_INPTR
		MOV	CL,2

		XOR	EAX,EAX

		REP	STOSD			;ZERO CURN_INPTR, CURN_COUNT

		MOV	EDI,IND_DEVICE
		MOV	CL,(MYI_STRUCT.MYI_FILLBUF+4)/4

		TEST	EDI,EDI
		JZ	L35$

		MOV	IND_DEVICE,EAX

		REP	STOSD
L35$:
		POPM	ESI,EDI
		MOV	CURN_COUNT,1		;MARK BUFFER EMPTY
		CALL	OPEN_INDIRECT
		RET

L2$:
		MOV	EAX,MYI_STRUCT.MYI_FILLBUF+4+16
		TEXT_POOL_ALLOC
		MOV	ECX,EAX
		MOV	INDIR_TABLE[EDI*4],EAX
		JMP	L3$

L5$:
		MOV	AL,INDIRECT_DEEP_ERR
		push	EAX
		call	_err_abort

NEST_INDIRECT	ENDP


OPEN_INDIRECT	PROC
		;
		;OPEN AN INDIRECT COMMAND FILE
		;
		;
		;WALTER LOOKS THIS UP IN THE ENVIRONMENT FIRST...
		;
		MOV	EAX,OFF INDNAM
		CALL	OPEN_ENVIRONMENT

		MOV	IND_DEVICE,EAX
		JC	L2$

		RET

L2$:
		MOV	EAX,OFF INDNAM

		mov	ECX,offset IND_DEVICE
		push	ECX
		push	EAX
		call	_open_input		; open indirect file
		add	ESP,8
		test	EAX,EAX
		mov	EAX,IND_DEVICE
		jnz	L5$			; file not found

		RET				;FROM INDIRECT FILE

L5$:
		MOV	AL,FILE_NOT_FOUND_ERR
		MOV	ECX,OFF INDNAM
		CALL	ERR_NFN_ABORT

OPEN_INDIRECT	ENDP


OPEN_ENVIRONMENT	PROC
		;
		;EAX IS NFN_STRUCT
		;
		PUSH	ESI
		MOV	ESI,EAX
		ASSUME	ESI:PTR NFN_STRUCT

		PUSHM	EDI,EBX

		MOV	EDI,ENVIRONMENT_BLOCK
		MOV	EBX,[ESI].NFN_TOTAL_LENGTH

		TEST	EDI,EDI
		JZ	L99$

		MOV	[EBX+ESI].NFN_TEXT,'='

		MOV	EDX,ESI
		ASSUME	EDX:PTR NFN_STRUCT
		JMP	L7$

L1$:
		DEC	EDI
		MOV	ECX,[EDX].NFN_TOTAL_LENGTH

		LEA	ESI,[EDX].NFN_TEXT
		INC	ECX	;STRING LENGTH (INCLUDING =)

		MOV	EBX,EDI

		REPE	CMPSB	;COMPARE CX BYTES

		MOV	CH,64	;16K MAX, ABORT
		JZ	L4$	;MATCH, JUMP

		DEC	EDI	;NEED TO FIND END OF STRING
		XOR	AL,AL

		REPNE	SCASB	;THANK-YOU

		JNZ	L9$
L7$:
		SCASB		;TRAILING ZERO?

		JNZ	L1$
L9$:
		;
		;NOTHING FOUND, RETURN
		;
L99$:
		MOV	EAX,[EDX].NFN_TOTAL_LENGTH
		POPM	EBX,EDI,ESI

		MOV	[EAX+EDX].NFN_TEXT,0

		STC
		RET

L8$:
		POP	EDI
		JMP	L9$

L4$:
		;
		;ES:DI POINTS TO STRING...
		;
		PUSH	EDI
L41$:
		;
		;SEE IF ANY NON-BLANK CHARACTERS
		;
		MOV	AL,[EDI]
		INC	EDI

		CMP	AL,0		;END OF ENVIRONMENT
		JZ	L8$

		CMP	AL,' '
		JZ	L41$

		CMP	AL,9
		JZ	L41$
L49$:
		POP	ESI
		CALL	GET_NEW_IO_LOG_BLK

		MOV	EBX,OFF MYI_STUFF
		ASSUME	EBX:PTR MYI_STRUCT
		MOV	EDI,EAX

		MOV	CURN_INPTR,EDI

		MOV	[EBX].MYI_BLOCK,EAX
		MOV	[EBX].MYI_PTRA,EDI
L5$:
		MOV	AL,[ESI]
		INC	ESI

		MOV	[EDI],AL
		INC	EDI

		OR	AL,AL
		JNZ	L5$

		DEC	EDI
		MOV	EAX,0A0DH

		STOSW

		SUB	EDI,[EBX].MYI_BLOCK
		XOR	EAX,EAX

		MOV	[EBX].MYI_FILE_LENGTH,EDI
		MOV	[EBX].MYI_BYTE_OFFSET,EAX

		INC	EDI
		MOV	[EBX].MYI_PHYS_ADDR,EAX

		MOV	CURN_COUNT,EDI
		MOV	[EBX].MYI_COUNT,EAX

		MOV	[EBX].MYI_FILLBUF,OFF ENVIRON_READ_RETT

		MOV	EAX,EBX
		POPM	EBX,EDI,ESI

		RET

OPEN_ENVIRONMENT	ENDP


ENVIRON_READ_RETT	PROC

		RET

ENVIRON_READ_RETT	ENDP


SEE_NEXT	PROC
		;
		;
		;
		MOV	ESI,INPTR1

		MOV	AL,[ESI]

		RET

SEE_NEXT	ENDP


GET_NEXT	PROC
		;
		;
		;
		MOV	ESI,INPTR1
		MOV	AL,[ESI]
		INC	ESI
		MOV	INPTR1,ESI
		RET

GET_NEXT	ENDP


GETNST		PROC
		;
		;
		;
		MOV	ECX,INPTR1
		XOR	EAX,EAX
		MOV	EDX,OFF PARSE_TABLE
L0$:
		MOV	AL,[ECX]
		INC	ECX
		CMP	ECX,OFF INBUF+INBUF_LEN+1
		MOV	AL,[EDX+EAX]
		JZ	L2$		;GET ANOTHER LINE
		CMP	AL,CH_SPC
		JZ	L0$
		CMP	AL,CH_SEMI
		JZ	L1$		;EOF...
		CMP	AL,CH_NL
if	fg_mscmd
		JZ	L5$
else
		JZ	L2$		;GET ANOTHER LINE
endif
L6$:
		CMP	ECX,OFF INBUF+INBUF_LEN/2
		MOV	AL,[ECX-1]
		JAE	L3$
L4$:
		MOV	INPTR1,ECX
		RET

if	fg_mscmd
L5$:
if	fg_plink
		BITT	CMDLINE_FREEFORMAT
		JNZ	L2$
endif
if	fg_def
		BITT	DEF_IN_PROGRESS
		JNZ	L2$
endif
		CMP	BPTR [ECX-1],0DH
		JZ	L6$
		JMP	L2$			;ACTUALLY READ NEXT LINE WITH 0AH
endif

L3$:
		BITT	GET_LINE_PARTIAL
		JZ	L4$
		DEC	ECX
		MOV	INPTR1,ECX
L2$:
		CALL	GET_LINE
		JNC	GETNST
L21$:
		MOV	ECX,INPTR1
		INC	ECX
L1$:
		MOV	INPTR1,ECX
		MOV	AL,[ECX-1]		; OR 1AH
if	fg_def
		CMP	AL,';'
		JNZ	L9$
		BITT	DEF_IN_PROGRESS
		JNZ	L2$
endif
L9$:
		RET

GETNST		ENDP


HANDLE_EOF	PROC
		;
		;
		;
		CMP	INDIRECT_LEVEL,0
		JZ	L9$
		CALL	DO_UNNEST
		JMP	HANDLE_EOF

L9$:
		RET

HANDLE_EOF	ENDP


YYLEX_FILENAME	PROC
		;
		;EAX IS STUFF FOR DEFAULT
		;
		PUSH	FILESTUFF_PTR
		MOV	FILESTUFF_PTR,EAX

		CALL	YY_FILENAME		;PUT INTO FILNAM

		MOV	EAX,FILESTUFF_PTR
		MOV	ECX,OFF FILNAM

		push	EAX
		push	ECX
		call	_do_filename
		add	ESP,8

		POP	FILESTUFF_PTR

		RET

YYLEX_FILENAME	ENDP


YY_FILENAME	PROC
		;
		;
		;
		CALL	GETNST			;DEALS WITH BLANKS

		PUSH	ESI
		MOV	ESI,INPTR1
		;
		;TO COMPATIBLY HANDLE ^, WE MUST COPY TO ANOTHER BUFFER...
		;
		PUSH	EDI
		DEC	ESI

		MOV	EDI,OFF FILNAM.NFN_TEXT
		XOR	EAX,EAX

		MOV	EDX,OFF FNTBL
		XOR	ECX,ECX
L1$:
		MOV	AL,[ESI]
		INC	ESI
L11$:
		CMP	AL,'^'
		JZ	L2$

		CMP	AL,'"'
		JZ	L5$

		CMP	AL,"'"
		JZ	L5$
L13$:
		MOV	[EDI],AL
		INC	EDI

		CMP	AL,'%'
		JZ	L7$

		CMP	AL,' '
		JZ	L4$
L79$:
		MOV	AL,[EDX+EAX]
		CMP	EDI,OFF FILNAM.NFN_TEXT+NFN_TEXT_SIZE
		JAE	L8$
		TEST	AL,MASK FNTBL_ILLEGAL
		JZ	L1$
L15$:
		DEC	ESI
		SUB	EDI,OFF FILNAM.NFN_TEXT+1
		MOV	FILNAM.NFN_TOTAL_LENGTH,EDI
		JZ	L9$
L16$:
		POP	EDI
		MOV	INPTR1,ESI
		POP	ESI
		RET

L2$:
		MOVSB
		JMP	L1$

L4$:
		TEST	CL,CL		;SPACE BAD IF NOT IN QUOTES
		JZ	L15$

		MOV	AL,'A'
		JMP	L79$		;OTHERWISE, OK

L5$:
		CMP	CL,AL		;SAME QUOTE I'M ALREADY PROCESSING?
		JZ	L59$

		TEST	CL,CL		;WAS I PROCESSING A QUOTE?
		JNZ	L13$

		MOV	CL,AL		;NOW I'M PROCESSING A QUOTE
		JMP	L1$

L59$:
		MOV	CL,0		;CLEAR STRING PROCESSING
		JMP	L1$

L7$:
		MOV	AL,[ESI]	;GOT A %, WHATS NEXT?
		INC	ESI

		MOV	[EDI],AL
		INC	EDI

		CMP	AL,'@'
		JNZ	L77$

		MOV	AL,[ESI]	;GOT A %@
		INC	ESI

		MOV	[EDI],AL
		INC	EDI

		CMP	AL,'p'
		JZ	L71$

		CMP	AL,'P'
		JNZ	L77$
L71$:
		MOV	AL,[ESI]	;GOT A %@P
		INC	ESI

		MOV	[EDI],AL
		INC	EDI

		CMP	AL,'%'
		JNZ	L77$

		PUSH	ESI
		MOV	ESI,ME_PTR

		PUSH	ECX		;SAVE QUOTES FLAG
		MOV	ECX,ME_PATH_LEN

		TEST	ECX,ECX
		JZ	L78$

		SUB	EDI,4

		REP	MOVSB

		CMP	BPTR [EDI-1],'\'
		JNZ	L78$

		DEC	EDI
L78$:
		POP	ECX

		POP	ESI
		JMP	L79$

L77$:
		DEC	EDI
		JMP	L11$

L8$:
		CALL	TOKEN_TOO

L9$:
if	fg_plink
		BITT	CMDLINE_FREEFORMAT
		JZ	L91$
		MOV	AL,FILE_EXP_ERR
		CALL	ERR_INBUF_ABORT
L91$:
endif
		MOV	AL,[ESI];CHECK LAST ILLEGAL CHARACTER, MAKE SURE IT ISN'T
				;   >, <, =, ), [, ], |,
				;I.E., ONLY ALLOW 0DH, +, ", SPACE, /, ;
				;	WE ALREADY SKIPPED SPACES, TABS,+, ", /
		CMP	AL,0DH
		JZ	L16$
		CMP	AL,','
		JZ	L16$
		CMP	AL,';'
		JZ	L16$
		CMP	AL,1AH
		JZ	L16$
		MOV	AL,FILENAME_ERR
		CALL	ERR_INBUF_ABORT

YY_FILENAME	ENDP


GET_KEYWORD	PROC
		;
		;MOVE TEXT INTO SYMBOL_TEXT, RETURN LENGTH IN AX
		;EOF ILLEGAL
		;
		CALL	GETNST
		PUSHM	EDI,ESI
		MOV	ESI,INPTR1
		MOV	EDI,OFF SYMBOL_TEXT	;PLACE TO COPY COMMAND
		DEC	ESI
		XOR	EAX,EAX
		MOV	TOKSTR,ESI
		;
		;SKIP LEADING SPACE AND COMM
		;
if	fg_td
		MOV	EDX,OFF PARSE_TABLE
		BITT	TLINK_SYNTAX
		JZ	L00$
		MOV	EDX,OFF PARSE_TABLE_TL
L00$:
		MOV	MY_PARSE_TABLE,EDX
endif

if	fg_td
else
		MOV	EDX,OFF PARSE_TABLE
endif
L0$:
		MOV	AL,[ESI]
		INC	ESI
		MOV	AL,[EDX+EAX]
		CMP	AL,CH_SEMI	;SEP, AT, OR SEMI
		JB	L31$
		JE	L3$
		JMP	L12$

		;
		;OK, FOUND A NON SPACE-TAB, BUILD TOKEN
		;
L1$:
if	fg_td
		MOV	EDX,MY_PARSE_TABLE
else
		MOV	EDX,OFF PARSE_TABLE
endif
L11$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	EDI,OFF SYMBOL_TEXT+SYMBOL_TEXT_SIZE-1
		JAE	TOKEN_TOO
		MOV	AL,[EDX+EAX]
L12$:
		MOV	[EDI],AL
		INC	EDI
		CMP	AL,' '
		JAE	L11$
		;
		;SPECIAL CHARACTER
		;
		DEC	EDI
L2$:
		JMP	PARSE_JMP_TABLE[EAX]


TOKEN_TOO	LABEL	PROC

		MOV	AL,TOKEN_TOO_LONG_ERR
		CALL	ERR_INBUF_ABORT

L3$:
		DEC	ESI
L31$:
		MOV	[EDI],AL
		INC	EDI
		JMP	K_SPCTAB1

K_EOL:
K_SEPARATOR:
K_SEMI:
K_AT:
K_SPCTAB:
		;
		;SEPARATOR
		;
		DEC	ESI
K_SPCTAB1:
		MOV	DPTR [EDI],0
		SUB	EDI,OFF SYMBOL_TEXT
		MOV	INPTR1,ESI
		POP	ESI
		MOV	SYMBOL_LENGTH,EDI
		MOV	EAX,EDI
		POP	EDI
		RET

K_ESCAPE:
		;
		;ESCAPE, MAKE SURE NEXT ISN'T EOL
		;
		MOV	AL,[ESI]
if	fg_td
		MOV	EDX,MY_PARSE_TABLE
else
		MOV	EDX,OFF PARSE_TABLE
endif
		INC	ESI
		MOV	AL,[EDX+EAX]
		CMP	AL,' '
		JNC	K_ESCAPE_1
		MOV	AL,[ESI-1]
K_ESCAPE_1:
		MOV	[EDI],AL
		INC	EDI
		JMP	L11$


		ALIGN	4

PARSE_JMP_TABLE LABEL	DWORD

		DD	K_SPCTAB	;SPACE OR TAB - SEPARATER
		DD	K_SEPARATOR	;END OF TOKEN - PRESERVE IF TOKEN
		DD	K_AT		;I DON'T KNOW...
		DD	K_SEMI		;SEMICOLON - SEPARATOR - PRESERVE
		DD	K_EOL		;END-OF-LINE - SEPARATOR
		DD	K_ESCAPE	;ESCAPE CHAR

GET_KEYWORD	ENDP


GET_SYMBOL	PROC
		;
		;MOVE TEXT INTO SYMBOL_TEXT, RETURN LENGTH IN AX
		;
		CALL	GETNST
		PUSHM	EDI,ESI
		MOV	ESI,INPTR1
		MOV	EDI,OFF SYMBOL_TEXT	;PLACE TO COPY COMMAND
		DEC	ESI
		MOV	EDX,OFF FNTBL
		XOR	EAX,EAX
		MOV	TOKSTR,ESI
		XOR	CL,CL
L1$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'^'
		JZ	L2$
		CMP	AL,'"'
		JZ	L6$
		CMP	AL,"'"
		JZ	L6$
		MOV	[EDI],AL
		INC	EDI
		MOV	AL,[EDX+EAX]
		CMP	EDI,OFF SYMBOL_TEXT+SYMBOL_TEXT_SIZE
		JAE	L8$
		TEST	AL,MASK SYMTBL_ILLEGAL
		JZ	L1$
L15$:
		MOV	DPTR [EDI-1],0

		DEC	ESI
		SUB	EDI,OFF SYMBOL_TEXT+1

		MOV	INPTR1,ESI
		MOV	EAX,EDI

		MOV	SYMBOL_LENGTH,EDI
		JZ	L4$

		POPM	ESI,EDI

		RET

L2$:
		MOVSB
		JMP	L1$

L4$:
		;
		;ZERO LENGTH ONLY ALLOWED IF QUOTES USED...
		;
		OR	CL,CL
		JZ	L5$
		POPM	ESI,EDI
		RET

L5$:
		MOV	AL,ID_EXP_ERR
		CALL	ERR_INBUF_RET
		POPM	ESI,EDI
		XOR	EAX,EAX
		RET

L6$:
		MOV	CL,AL
L61$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,CL
		JZ	L1$
		MOV	[EDI],AL
		INC	EDI
		CMP	AL,' '
		JAE	L61$
		JMP	L15$

L8$:
		CALL	TOKEN_TOO

GET_SYMBOL	ENDP


YYLEX_SYMBOL	PROC
		;
		;
		;
		CALL	GET_SYMBOL
		PUSHM	EDI,ESI
		MOV	EAX,SYMBOL_LENGTH
		MOV	ESI,OFF SYMBOL_TEXT
		OR	EAX,EAX
		JZ	L9$
		MOV	EDI,ESI
		CALL	OPTI_MOVE		;TRANSLATE AND HASH
		POPM	ESI,EDI
		MOV	SYMBOL_HASH,EDX
		RET

L9$:
		MOV	AL,ID_EXP_ERR
		CALL	ERR_INBUF_ABORT

YYLEX_SYMBOL	ENDP


GROUPSTACK_PROC	PROC
		;
		;
		;
		SETT	STACK_GROUP_FLAG
		RET

GROUPSTACK_PROC	ENDP


NOGROUPSTACK_PROC	PROC
		;
		;
		;
		RESS	STACK_GROUP_FLAG
		RET

NOGROUPSTACK_PROC	ENDP


ERRORDELETE_PROC	PROC
		;
		;
		;
		SETT	_DELETE_EXE_ON_ERROR
		RET

ERRORDELETE_PROC	ENDP


NOERRORDELETE_PROC	PROC
		;
		;
		;
		RESS	_DELETE_EXE_ON_ERROR
		RET

NOERRORDELETE_PROC	ENDP


IGNORECASE_PROC	LABEL	PROC

		MOV	AL,1
		JMP	DEFINE_CASE_MODE

NOIGNORECASE_PROC	LABEL	PROC
MIXCASE_PROC		LABEL	PROC

		MOV	AL,0
		JMP	DEFINE_CASE_MODE

UPPERCASE_PROC	LABEL	PROC

		MOV	AL,2
		JMP	DEFINE_CASE_MODE

LOWERCASE_PROC	LABEL	PROC

		MOV	AL,3
DEFINE_CASE_MODE::
		MOV	CASE_TYPE,AL
		;
		;
		;

_set_case_mode	proc
		;
		;OK, LOOK AT OPTIONS, SET UP OPTI_MOVE AND CONVERT_TABLE
		;
		PUSH	ESI
		MOV	AL,CASE_TYPE		;0 = PRESERVE, SIGNIFICANT
						;1 = PRESERVE, IGNORE
						;2 = CONVERT UPPER
						;3 = CONVERT LOWER

		SETT	IGNORE_PRESERVE
		MOV	EDX,OFF CASE_STRING_COMPARE_HARD
		MOV	ECX,OFF OPTI_HASH_IGNORE
		MOV	ESI,OFF OPTI_MOVE_PRESERVE_IGNORE
		DEC	AL
		JZ	L0$
		RESS	IGNORE_PRESERVE
		MOV	EDX,OFF CASE_STRING_COMPARE_EASY
		MOV	ESI,OFF OPTI_MOVE_UPPER_IGNORE
		DEC	AL
		JZ	L0$
		MOV	ESI,OFF OPTI_MOVE_LOWER_IGNORE
		DEC	AL
		JZ	L0$
		;
		;0 = PRESERVE, SIGNIFICANT
		;
		MOV	ESI,OFF OPTI_MOVE_PRESERVE_SIGNIFICANT
		MOV	ECX,OFF OPTI_HASH_SIGNIFICANT
L0$:
		MOV	OPTI_MOVE,ESI
		POP	ESI
		MOV	OPTI_HASH,ECX
		MOV	CASE_STRING_COMPARE,EDX
		RET

_set_case_mode	endp


CHECKSUM_PROC	PROC
		;
		;SLR
		;
		SETT	DO_CHECKSUMING
		RET

CHECKSUM_PROC	ENDP

NOCHECKSUM_PROC	PROC
		;
		;
		;
		RESS	DO_CHECKSUMING
		RET

NOCHECKSUM_PROC	ENDP

NONULLSDOSSEG_PROC	PROC
		;
		RESS	NULLSDOSSEG_FLAG
		JMP	DOSSEG_PROC

NONULLSDOSSEG_PROC	ENDP

DOSSEG_PROC	PROC
		;
		;ENABLE DOSSEG ORDERING SCHEME IN DGROUP
		;
		SETT	DOSSEG_FLAG
		RET

DOSSEG_PROC	ENDP


SET_ECHO_IND	PROC

		SETT	ECHO_INDIRECT
;		BITT	INDIRECT_MODE
;		JZ	1$
		SETT	ECHO_ANY
;1$:
		RET

NOLOGO_PROC	LABEL	PROC
RES_LOGO_OUTPUT	LABEL	PROC

		RESS	LOGO_OUTPUT

RES_ECHO_IND	LABEL	PROC
SILENT_PROC	LABEL	PROC

		RESS	INFORMATION_FLAG
		RESS	ECHO_INDIRECT
		BITT	INDIRECT_MODE
		JZ	L2$
		RESS	ECHO_ANY
L2$:
		RET

SET_ECHO_IND	ENDP

VERBOSE_PROC	PROC
		;
		;
		;
		SETT	INFORMATION_FLAG
		RET

VERBOSE_PROC	ENDP


INIT_AREA	PROC
		;
		;INITIALIZE ROOT AREA
		;
		;ALLOCATE ROOM FOR AREA_STRUCT
		;
		PUSH	EDI
		MOV	EAX,SIZE AREA_STRUCT
		SECTION_POOL_ALLOC
		MOV	EDI,EAX
		INSTALL_POINTER_GINDEX	AREA_GARRAY
		MOV	FIRST_AREA_GINDEX,EAX
		MOV	CURN_AREA_GINDEX,EAX
		MOV	ECX,SIZE AREA_STRUCT/4
		XOR	EAX,EAX
		REP	STOSD
		MOV	AREA_COUNT,EAX		;SIMPLY FOR COUNTING AREAS
		POP	EDI
		RET

INIT_AREA	ENDP

if	any_overlays

		PUBLIC	ENDAREA_PROC,OVLCODEFIRST_PROC,OVLCODELAST_PROC,NORENAME_PROC

ENDAREA_PROC	PROC
		;
		;CLOSE MOST RECENT AREA
		;
		LDS	SI,CURN_AREA
		ASSUME	DS:NOTHING
		SYM_CONV_DS
		XOR	AX,AX
		CMP	[SI]._AREA_LEVEL,AX
		JZ	9$
		MOV	[SI]._AREA_MAX_ADDRESS.LW,AX
		MOV	[SI]._AREA_MAX_ADDRESS.HW,AX

		LDS	SI,[SI]._AREA_PARENT_SECTION
		MOV	CURN_SECTION.OFFS,SI
		MOV	CURN_SECTION.SEGM,DS
		SYM_CONV_DS
		XOR	AX,AX
		MOV	CURN_PLTYPE,AL
		CMP	[SI]._SECT_LEVEL,AX
		JNZ	2$
		MOV	CURN_PLTYPE,MASK LEVEL_0_SECTION
2$:
		MOV	AX,SECTION_NUMBER
		SUB	AX,[SI]._SECT_NUMBER
		DEC	AX
		MOV	[SI]._SECT_CHILDREN,AX
		LEA	SI,[SI]._SECT_PARENT_AREA
		LEA	DI,CURN_AREA
		MOVSW
		MOVSW
		LDS	SI,-4[SI]
		SYM_CONV_DS
		LEA	DI,CURN_OUTFILE
		LEA	SI,[SI]._AREA_LAST_OUTFILE
		MOVSW
		MOVSW
		FIXDS
		DEC	PLINK_LEVEL
		RET

9$:
		MOV	CL,ENDAREA_ERR
		JMP	ERR_INBUF_ABORT

ENDAREA_PROC	ENDP

OVLCODEFIRST_PROC	PROC
		;
		;
		;
		SETT	$$SLR_CODE_FIRST
		RET

OVLCODEFIRST_PROC	ENDP

OVLCODELAST_PROC	PROC
		;
		;
		;
		RESS	$$SLR_CODE_FIRST
		RET

OVLCODELAST_PROC	ENDP

NORENAME_PROC	PROC
		;
		;
		;
		RESS	ROOT_ENVIRONMENT_LEGAL
		RET

NORENAME_PROC	ENDP

endif


VERIFY_SECTION	PROC
		;
		;
		;
		CMP	CURN_SECTION_GINDEX,0
		JZ	L1$
		RET

L1$:

VERIFY_SECTION	ENDP


DO_NEW_SECTION	PROC
		;
		;IF LEVEL=0, AND THIS AREA ALREADY HAS A SECTION, DO NEW
		;AREA FIRST
		;
		PUSHM	EDI,ESI,EBX

		CMP	PLINK_LEVEL,0
		JNZ	L11$
		MOV	EAX,CURN_AREA_GINDEX	;LEVEL 0
		CONVERT	EAX,EAX,AREA_GARRAY
		ASSUME	EAX:PTR AREA_STRUCT
		CMP	[EAX]._AREA_LAST_SECT_GINDEX,0
		JZ	L1$
		MOV	ESI,EAX
		ASSUME	ESI:PTR AREA_STRUCT

		MOV	EAX,SIZE AREA_STRUCT
		SECTION_POOL_ALLOC
		MOV	EBX,EAX
		ASSUME	EBX:PTR AREA_STRUCT
		MOV	EDI,EAX
		INSTALL_POINTER_GINDEX	AREA_GARRAY
		MOV	CURN_AREA_GINDEX,EAX
		MOV	[ESI]._AREA_NEXT_AREA_GINDEX,EAX
		XOR	EAX,EAX
		MOV	ECX,(SIZE AREA_STRUCT+3)/4
		REP	STOSD
		MOV	CURN_SECTION_GINDEX,EAX
		MOV	EAX,CURN_OUTFILE_GINDEX
		INC	AREA_COUNT
		;
		;SET LAST OUTFILE?
		;
		MOV	[EBX]._AREA_LAST_OUTFILE_GINDEX,EAX
L1$:
L11$:
		MOV	EAX,SIZE SECTION_STRUCT
		SECTION_POOL_ALLOC
		MOV	EBX,EAX
		ASSUME	EBX:PTR SECTION_STRUCT
		MOV	EDI,EAX
		INSTALL_POINTER_GINDEX	SECTION_GARRAY
		MOV	EDX,EAX

		MOV	ESI,LAST_SECTION_GINDEX

		MOV	ECX,(SIZE SECTION_STRUCT+3)/4
		XOR	EAX,EAX
		REP	STOSD

		TEST	ESI,ESI
		JZ	L7$

		CONVERT	ESI,ESI,SECTION_GINDEX
		ASSUME	ESI:PTR SECTION_STRUCT

		MOV	[ESI]._SECT_NEXT_SECTION_GINDEX,EDX

L79$:
		MOV	EAX,SECTION_COUNT
		MOV	LAST_SECTION_GINDEX,EDX

		INC	EAX
		MOV	ECX,CURN_OUTFILE_GINDEX

		MOV	[EBX]._SECT_NUMBER,EAX
		MOV	SECTION_COUNT,EAX

		MOV	EAX,CURN_AREA_GINDEX
		MOV	[EBX]._SECT_OUTFILE_GINDEX,ECX

		MOV	[EBX]._SECT_PARENT_AREA_GINDEX,EAX
		;
		;SET OUTFILE
		;
if	any_overlays
		CMP	CACHE_DEFAULT_BYTE,0
		JZ	L4$
		OR	[EBX]._SECT_FLAGS,MASK SECT_CACHEABLE
L4$:
		CMP	COMPRESS_DEFAULT_BYTE,0
		JZ	L41$
		OR	[EBX]._SECT_FLAGS,MASK SECT_SLRPACK
L41$:
endif
		MOV	EAX,CURN_AREA_GINDEX
		CONVERT	EAX,EAX,AREA_GARRAY
		ASSUME	EAX:PTR AREA_STRUCT

		MOV	ECX,[EAX]._AREA_LAST_SECT_GINDEX
		MOV	[EAX]._AREA_LAST_SECT_GINDEX,EDX
		TEST	ECX,ECX
		JZ	L3$			;GO DO FIRST SECTION
		CONVERT	ECX,ECX,SECTION_GARRAY
		MOV	[ECX].SECTION_STRUCT._SECT_NEXT_SECT_GINDEX,EDX
L5$:
		MOV	CURN_PLTYPE,0
		MOV	CURN_SECTION_GINDEX,EDX
		CMP	PLINK_LEVEL,0
		JNZ	L6$
		MOV	CURN_PLTYPE,MASK LEVEL_0_SECTION
L6$:
		POPM	EBX,ESI,EDI
		RET

L7$:
		MOV	FIRST_SECTION_GINDEX,EDX
		JMP	L79$

L3$:
		MOV	[EAX]._AREA_FIRST_SECT_GINDEX,EDX
		JMP	L5$

DO_NEW_SECTION	ENDP


HELP_PROC_1	PROC
		;
		;EAX IS COMMAND TABLE
		;
		ASSUME	ESI:NOTHING

		PUSH	EAX
		CALL	FORCE_SIGNON

		POP	ESI
;		MOV	EDI,OFF OUTBUF
;L1$:
;		MOV	EAX,[ESI]	;ONE OF THESE FOR EVERY STARTING LETTER
;		ADD	ESI,4
;		OR	EAX,EAX
;		JZ	L25$
;		PUSH	ESI
;		MOV	ESI,EAX
;L2$:
;		CALL	DO_ONE
;		JNZ	L2$
;		POP	ESI
;		JMP	L1$
;
;L25$:
;		CMP	EDI,OFF OUTBUF
;		JZ	L3$
;		CALL	HELP_PRINT
;L3$:
		call	_switch_help
		JMP	_abort

HELP_PROC_1	ENDP


;DO_ONE		PROC
		;
		;
		;
;		XOR	EDX,EDX
;		XOR	ECX,ECX
;		MOV	DL,[ESI]
;		INC	ESI
;		OR	EDX,EDX
;		JZ	L9$
;
;		MOV	CL,[ESI]
;		ADD	ESI,5
;		SUB	EDX,ECX
;		REP	MOVSB
;		MOV	ECX,EDX
;		OR	EDX,EDX
;		JZ	L2$
;		MOV	AL,'['
;		STOSB
;L1$:
;		LODSB
;		CMP	AL,'A'
;		JB	L15$
;		CMP	AL,'Z'
;		JA	L15$
;		ADD	AL,20H
;L15$:
;		STOSB
;		LOOP	L1$
;		MOV	AL,']'
;		STOSB
;L2$:
;		MOV	ECX,OFF OUTBUF+26
;		SUB	ECX,EDI
;		JAE	L3$
;		MOV	ECX,OFF OUTBUF+52
;		SUB	ECX,EDI
;		JAE	L3$

;HELP_PRINT	LABEL	PROC
;		MOV	AX,0A0DH
;		STOSW
;		MOV	EAX,OFF OUTBUF
;		MOV	ECX,EDI
;		SUB	ECX,EAX
;		CALL	LOUTALL_CON
;		MOV	EDI,OFF OUTBUF
;L5$:
;		OR	AL,-1
;L9$:
;		RET
;
;L3$:
;		MOV	AL,' '
;		REP	STOSB
;		JMP	L5$
;DO_ONE		ENDP


SET_REORDER_ALLOWED	PROC

		SETT	REORDER_ALLOWED
		RET

SET_REORDER_ALLOWED	ENDP


RES_REORDER_ALLOWED	PROC

		RESS	REORDER_ALLOWED
		RET

RES_REORDER_ALLOWED	ENDP


RES_PACKFUNCTIONS	PROC
		;
		RESS	PACKFUNCTIONS_FLAG
		RET

RES_PACKFUNCTIONS	ENDP


SET_PACKFUNCTIONS	PROC
		;
		SETT	PACKFUNCTIONS_FLAG
		RET

SET_PACKFUNCTIONS	ENDP


CHECK_MAP_FLAG	PROC
		;
		;
		;
		BITT	MAPFILE_SELECTED
		JNZ	CMF_RET
		BITT	LINENUMBERS_FLAG
		JNZ	CMF_RET
		BITT	XREF_OUT
		JNZ	CMF_RET
		BITT	DETAILEDMAP_FLAG
		JNZ	CMF_RET
		BITT	SYMBOLS_OUT
CMF_RET		LABEL	PROC
		RET

CHECK_MAP_FLAG	ENDP

_check_map_flag	proc
		call	CHECK_MAP_FLAG
		mov	EAX,0
		jz	L1
		mov	EAX,1
L1:		ret
_check_map_flag	endp

		public _ret_true
_ret_true	proc
		or	EAX,1
		ret
_ret_true	endp

		public _ret_false
_ret_false	proc
		xor	EAX,EAX
		ret
_ret_false	endp

		.CONST

;
;DEFAULT EXTENSIONS
;
OBJ_EXT		DB	4,'.obj'
MAP_EXT		DB	4,'.map'
IND_EXT		DB	4,'.lnk'
EXE_EXT		DB	4,'.exe'
DEF_EXT		DB	4,'.def'
NUL_EXT		DB	0
if	any_overlays
OVL_EXT		DB	4,'.ovl'
endif
if	fg_segm
RES_EXT		DB	4,'.res'
LIB_EXT		DB	4,'.lib'
DIN_EXT		DB	4,'.din'
endif

		ALIGN	4
NULSTUFF	LABEL	DWORD
INDIR_STUFF	LABEL	DWORD
		DCA	_ret_false	;CMD_SELECTED - NUL OR SRCNAM
;		DD	IND_EXT		;CMD_EXTENT - DEFAULT EXTENT
		DD	NUL_EXT
if	fg_mscmd
		DCA	_ret_true	;CMD_DESIRED - USED AT ALL?
		DD	IND_MSG		;CMD_PMSG - PROMPT MESSAGE
endif

LOCAL_INFO	LABEL	DWORD
OBJSTUFF	LABEL	DWORD

		DCA	_ret_false	;NO DEFAULT PRIMARY NAME
		DD	OBJ_EXT		;DEFAULT EXTENSION
if	fg_mscmd
		DCA	_ret_true	;YES WE WANT THIS
		DD	OBJ_MSG
endif

EXESTUFF	LABEL	DWORD
		DCA	_ret_true	;YES, DEFAULT=SOURCE
		DD	EXE_EXT		;DEFAULT EXTENTION
if	fg_mscmd
		DCA	_ret_true	;USE THIS AT ALL?  YES!
		DD	OUT_MSG		;IF PROMPTING
endif

MAPSTUFF	LABEL	WORD
		DCA	_check_map_flag	;USE LIBRARY NAME IF SELECT
		DD	MAP_EXT
if	fg_mscmd
		DCA	_ret_true	;YES, WE WANT THIS
		DD	MAP_MSG
endif

if	fg_mscmd

		PUBLIC	DEFSTUFF

DEFSTUFF	LABEL	WORD
		DCA	_ret_false	;DEFAULT TO NUL
		DD	DEF_EXT		;DEFAULT LIB EXTENSION
		DCA	_ret_true	;YES, THIS IS WANTED
		DD	DEF_MSG		;IF PROMPTING...

endif

		DD	0

PATHSTUFF	LABEL	WORD
		DCA	_ret_false	;DEFAULT TO NUL
		DD	NUL_EXT		;DEFAULT PATH EXTENSION
if	fg_mscmd
		DCA	_ret_true	;YES, THIS IS WANTED
		DD	IND_MSG		;IF PROMPTING...
endif

if	any_overlays

		PUBLIC	OVLSTUFF

OVLSTUFF	DCA	_ret_false
		DD	OVL_EXT
if	fg_mscmd
		DCA	_ret_true	;YES, THIS IS WANTED
		DD	IND_MSG		;IF PROMPTING...
endif

endif

if	fg_segm

		PUBLIC	STUBSTUFF,RCSTUFF,IMPLIB_STUFF,IMPDEF_STUFF,RESSTUFF

STUBSTUFF	LABEL	WORD
		DCA	_ret_false	;DEFAULT TO NUL
		DD	EXE_EXT		;DEFAULT LIB EXTENSION
		DCA	_ret_true	;YES, THIS IS WANTED
		DD	IND_MSG		;IF PROMPTING...

RCSTUFF		LABEL	WORD
		DCA	_ret_true	;OUTPUT FILENAME BY DEFAULT
		DD	RES_EXT		;.RES
		DCA	_ret_true	;YES, I WANT IT
		DD	IND_MSG

RESSTUFF	LABEL	WORD
		DCA	_ret_false	;NUL BY DEFAULT
		DD	RES_EXT		;.RES
		DCA	_ret_true	;YES, I WANT IT
		DD	RES_MSG

IMPLIB_STUFF	LABEL	WORD
		DCA	_ret_true	;USE OUTPUT FILENAME BY DEFAULT
		DD	LIB_EXT
		DCA	_ret_true	;
		DD	IND_MSG		;NO PROMPTING...

IMPDEF_STUFF	LABEL	WORD
		DCA	_ret_true	;USE OUTPUT FILENAME BY DEFAULT
		DD	DIN_EXT
		DCA	_ret_true	;
		DD	IND_MSG		;NO PROMPTING...

endif

if	fg_mscmd

;PROMPTS
OBJ_MSG		DB	11,'OBJ Files: '
MAP_MSG		DB	10,'Map File: '
OUT_MSG		DB	13,'Output File: '
IND_MSG		DB	1,'I'
DEF_MSG		DB	17,'Definition File: '
RES_MSG		DB	16,'Resource Files: '

endif

if	any_overlays

		PUBLIC	OVR_EXTRN,CACHE_BYTE,COMPRESS_BYTE,RELOAD_BYTE,TRACK_BYTE,DEBUG_BYTE,CODEVIEW_BYTE,MODEL_FAR_BYTE
		PUBLIC	MULTI_LEVEL_BYTE,MULTI_AREA_BYTE,MULTI_FILES_BYTE,OVR_EXTRN_TABLE,OVR_EXTRN_COUNT,BYTES

		.DATA

OVR_EXTRN_COUNT	EQU	6

OVR_EXTRN_TABLE	DW	OVR_EXTRN	;$$SLR_INI
		DB	3		;CACHE, RELOAD, CODEVIEW
		DB	CACHE_OFF
		DB	RELOAD_OFF
		DB	CODEVIEW_OFF

SELECT_EXTRN_TABLE	DW	SELECT_EXTRN	;$$SLR_SF
		DB	1
		DB	MT_FILES_OFF

HANDLER_EXTRN_TABLE	DW	HANDLER_EXTRN	;$$SLR_HND
		DB	3
		DB	RELOAD_OFF
		DB	MODEL_FAR_OFF
		DB	TRACK_OFF

LSECT_EXTRN_TABLE	DW	LSECT_EXTRN	;$$SLR_LSECT
		DB	4
		DB	CACHE_OFF
		DB	COMPRESS_OFF
		DB	MT_AREA_OFF
		DB	MT_LEVEL_OFF

CACHE_EXTRN_TABLE	DW	CACHE_EXTRN	;$$SLR_CCH
		DB	3
		DB	CACHE_OFF
		DB	MT_LEVEL_OFF
		DB	MT_AREA_OFF

CV_EXTRN_TABLE	DW	CV_EXTRN
		DB	1
		DB	CODEVIEW_OFF


OVR_EXTRN	DB	9,'$$SLR_INI'
SELECT_EXTRN	DB	8,'$$SLR_SF'
HANDLER_EXTRN	DB	9,'$$SLR_HND'
LSECT_EXTRN	DB	11,'$$SLR_LSECT'
CACHE_EXTRN	DB	9,'$$SLR_CCH'
CV_EXTRN	DB	8,'$$SLR_CV'

BYTES		LABEL	BYTE
CACHE_BYTE	DB	'N'
COMPRESS_BYTE	DB	'N'
RELOAD_BYTE	DB	'N'
TRACK_BYTE	DB	'N'
MODEL_FAR_BYTE	DB	'Y'		;FAR OVERLAYS BY DEFAULT
DEBUG_BYTE	DB	'N'
CODEVIEW_BYTE	DB	'N'
MULTI_LEVEL_BYTE DB	'N'
MULTI_AREA_BYTE	DB	'N'
MULTI_FILES_BYTE DB	'N'

CACHE_OFF	EQU	CACHE_BYTE-BYTES
COMPRESS_OFF	EQU	COMPRESS_BYTE-BYTES
RELOAD_OFF	EQU	RELOAD_BYTE-BYTES
TRACK_OFF	EQU	TRACK_BYTE-BYTES
MODEL_FAR_OFF	EQU	MODEL_FAR_BYTE-BYTES
DEBUG_OFF	EQU	DEBUG_BYTE-BYTES
CODEVIEW_OFF	EQU	CODEVIEW_BYTE-BYTES
MT_LEVEL_OFF	EQU	MULTI_LEVEL_BYTE-BYTES
MT_AREA_OFF	EQU	MULTI_AREA_BYTE-BYTES
MT_FILES_OFF	EQU	MULTI_FILES_BYTE-BYTES

OVR_EXTRN_ENDER LABEL	BYTE

endif

		.DATA			;CAUSE SOMETIMES THIS CHANGES...

PARSE_TABLE	LABEL	BYTE

	;0 IS SPACE-TAB (OR OTHER IGNORED CONTROL CHARS)
	;2 IS SEPARATOR ( # , @ % ( ) - " * + / = : )
	;4 IS SEMICOLON
	;6 IS NEW-LINE CHARS (CR, LF, FF)

		DB	4 DUP(CH_SPC)			;00-03 SKIP IT
		DB	4 DUP(CH_SPC)			;04-07 SKIP IT
		DB	CH_SPC,CH_SPC,CH_NL,CH_SPC	;08-0B
		DB	CH_NL,CH_NL,CH_SPC,CH_SPC	;0C-0F
		DB	10 DUP(CH_SPC),CH_SEMI,5 DUP(CH_SPC)	;10-1F

		DB	CH_SPC,'!',CH_SEP,CH_SEP        ; !"#
		DB	'$','%',"&'"                    ;$%&'
		DB	4 DUP(CH_SEP)			;()*+
		DB	CH_SEP,CH_SEP,'.',CH_SEP        ;,-./

		DB	'01234567'                      ;0123
							;4567
		DB	'89',CH_SEP,CH_SEMI             ;89:;
		DB	'<',CH_SEP,'>?'                 ;<=>?

		DB	CH_AT,'ABCDEFG'
		DB	'HIJKLMNO'
		DB	'PQRSTUVW'
		DB	'XYZ[\]',CH_ESC,'_'
		DB	'`ABCDEFGHIJKLMNO'              ;
		DB	'PQRSTUVWXYZ{|}~',7FH
XX	=	128
		REPT	128
		DB	XX
XX = XX+1
		ENDM

if	fg_td
PARSE_TABLE_TL	LABEL	BYTE

	;0 IS SPACE-TAB (OR OTHER IGNORED CONTROL CHARS)
	;2 IS SEPARATOR ( # , @ % ( ) - " * + / = : )
	;4 IS SEMICOLON
	;6 IS NEW-LINE CHARS (CR, LF, FF)

		DB	4 DUP(CH_SPC)			;00-03 SKIP IT
		DB	4 DUP(CH_SPC)			;04-07 SKIP IT
		DB	CH_SPC,CH_SPC,CH_NL,CH_SPC	;08-0B
		DB	CH_NL,CH_NL,CH_SPC,CH_SPC	;0C-0F
		DB	10 DUP(CH_SPC),CH_SEMI,5 DUP(CH_SPC)	;10-1F

		DB	CH_SPC,'!',CH_SEP,CH_SEP        ; !"#
		DB	'$','%',"&'"                    ;$%&'
		DB	4 DUP(CH_SEP)			;()*+
		DB	CH_SEP,CH_SEP,'.',CH_SEP        ;,-./

		DB	'01234567'                      ;0123
							;4567
		DB	'89',CH_SEP,CH_SEMI             ;89:;
		DB	'<',CH_SEP,'>?'                 ;<=>?

		DB	CH_AT,'ABCDEFG'
		DB	'HIJKLMNO'
		DB	'PQRSTUVW'
		DB	'XYZ[\]',CH_ESC,'_'
		DB	'`abcdefghijklmno'		;
		DB	'pqrstuvwxyz{|}~',7FH
XX	=	128
		REPT	128
		DB	XX
XX = XX+1
		ENDM
endif

if	fg_td
		.DATA?
MY_PARSE_TABLE	DD	?
endif
		END

