		TITLE	COMENT - Copyright (c) SLR Systems 1994
		SUBTTL	Contains Confidential and Proprietary material

		INCLUDE	MACROS
		INCLUDE	SYMBOLS
		INCLUDE	SEGMSYMS
		INCLUDE	EXES
		INCLUDE	MODULES
		INCLUDE	IO_STRUC
if	fg_td
		INCLUDE	TDBG
		INCLUDE	TDTYPES
endif

		PUBLIC	COMENT


		.DATA

		EXTERNDEF	INBUF:BYTE,MODULE_NAME:BYTE,EXP_PWORDS:BYTE,EXP_FLAGS:BYTE,LNKDIR_FLAGS:BYTE,EXETYPE_FLAG:BYTE
		EXTERNDEF	TD_MAJOR:BYTE,TD_MINOR:BYTE,SYMBOL_TEXT:BYTE,DEBUG_TYPES_SELECTED:BYTE,TD_INFO_TYPE:BYTE
		EXTERNDEF	MEMORY_MODEL:BYTE

		EXTERNDEF	END_OF_RECORD:DWORD,IMPEXP_MOD:DWORD,IMPEXP_NAM:DWORD,IMP_ORDNUM:DWORD,IMPEXP_INTNAM:DWORD
		EXTERNDEF	EXP_ORDNUM:DWORD,SYMBOL_LENGTH:DWORD,TYPDEF_ANDER:DWORD,EXTDEF_DELTA:DWORD,LINNUM_DELTA:DWORD
		EXTERNDEF	DEFAULT_SIZE:DWORD,LNKDIR_PCODE_CV:DWORD,LAST_EXTDEF_GINDEX:DWORD,LAST_PUBDEF_GINDEX:DWORD
		EXTERNDEF	LIN_SRC_GINDEX:DWORD,TD_N_LSCOPES:DWORD,TD_CURRENT_SCOPE:DWORD,TD_CURN_FILE_LINDEX:DWORD
		EXTERNDEF	MOD_TD_COMP_PARAMS:DWORD,WINMAIN_GINDEX:DWORD,CURNMOD_GINDEX:DWORD,TD_OUTER_SCOPE:DWORD
		EXTERNDEF	TD_SMEM_STARTING_INDEX:DWORD,SYMBOL_HASH:DWORD,TD_SMEM_RUNNING_HASH:DWORD,MATCHED_COUNT:DWORD
		EXTERNDEF	TD_SMEM_RUNNING_COUNT:DWORD,MATCHED_BUFFER:DWORD,MOD_TD_OPTFLAGS:DWORD,MOD_TD_FIRST_LOCAL:DWORD
		EXTERNDEF	TD_LAST_COVERAGE:DWORD,MATCHED_PTR:DWORD,LAST_TD_MATCHED:DWORD

		EXTERNDEF	SYMBOL_LARRAY:LARRAY_STRUCT,SYMBOL_GARRAY:STD_PTR_S,SYMBOL_TPTR:TPTR_STRUCT
		EXTERNDEF	TD_LTYPE_GARRAY:STD_PTR_S,TD_LCLASS_GARRAY:STD_PTR_S,TD_LSMEM_GARRAY:STD_PTR_S
		EXTERNDEF	EXESTR_STRUCTURE:SEQ_STRUCT

		EXTERNDEF	OPTI_MOVE:DWORD


		.CODE	PASS1_TEXT

		EXTERNDEF	ERR_RET:PROC,OBJ_PHASE:PROC,_err_abort:proc,SELECT_OUTPUT_SEGMENTED:PROC
		EXTERNDEF	DEFINE_EXPORT:PROC,STORE_EAXECX_EDX_SEQ:PROC,DEFINE_IMPORT:PROC,REMOVE_FROM_WEAK_LIST:PROC
		EXTERNDEF	REMOVE_FROM_WEAK_DEFINED_LIST:PROC,WARN_RET:PROC,FAR_INSTALL:PROC,ALLOC_LOCAL:PROC
		EXTERNDEF	DO_DEFINE_MODULE:PROC,SRCNAME_INSTALL:PROC,SELECT_OUTPUT_PE:PROC,_lib_routine_final_coment:proc

		EXTERNDEF	NO_IMPORTS_ERR:ABS,WEAK_DEF_ERR:ABS,INCERR_ERR:ABS,EXESTR_ERR:ABS,BAD_OMF_EXTENT_ERR:ABS
		EXTERNDEF	TD_E0_EXTDEF_ERR:ABS,TD_E1_PUBDEF_ERR:ABS,TD_SCOPE_NEST_ERR:ABS,TD_TID_ERR:ABS,TD_CLASS_ERR:ABS
		EXTERNDEF	CLASS_ZERO_ERR:ABS,MODEL_CONFLICT_ERR:ABS,TD_REF_ERR:ABS


COMENT		PROC
		;
		;ESI IS RECORD
		;
		;SOME COMENT RECORDS HAVE SPECIAL MEANINGS...
		;BUT I DON'T KNOW WHAT THEY ARE YET...
		;
		;129	LIBRARY SEARCH NAME
		;157	MEMORY MODEL			9D
		;158 	DOSSEG				9E
		;159	LIBRARY SEARCH NAME		9F
		;160	OMF EXTENSION			A0
		;161	CODEVIEW INFORMATION		A1
		;162	NO MORE SEG, EXTS, PUBS, JUST DATA FOLLOWS A2
		;163	MODULE_NAME			A3
		;164	EXESTR				A4
		;165	QC1				A5 ?
		;166	INCERR				A6
		;167	NOPAD				A7
		;168	WKEXT				A8
		;169	LZEXT				A9
		;170	PHARLAP				AA
		;
		;221	T&D STAMP (SLR)
		;
		XOR	EBX,EBX

		MOV	BL,[ESI+1]
		ADD	ESI,2

		TEST	BL,BL
		JNS	COMENT_0_7F

		CMP	BL,0ACH			;IS IT A BORLAND DEBUG RECORD?		
		JAE	L2$			;YES, JUMP

		JMP	COMENT_TABLE[EBX*4-200H]

L2$:
if	fg_td

		BITT	KEEPING_THIS_TDBG	;ARE WE KEEPING TURBO-DEBUG INFORMATION?
		JZ	22$
		CALL	TDBG_TABLE[BX-(0E0H*2)]
		CMP	END_OF_RECORD,SI
		JNZ	3$
		RET

22$:
		CMP	CURNMOD_GINDEX,0	;DID WE DEFINE MODULE YET?
		JNZ	COMENT_IGNORE		;YEP, WE ARE REALLY SKIPPING THESE RECORDS
		CALL	DO_DEFINE_MODULE	;NOPE, DEFINE MODULE, THEN CHECK AGAIN
		JMP	2$

3$:
		CALL	OBJ_PHASE

endif

COMENT_0_7F:
		JNZ	COMENT_IGNORE
		;
		;COMENT 0
		;
if	fg_symc
		;
		;SEE IF THIS IS FROM SYMANTEC COMPILER
		;
		CMP	WPTR [SI],'yS'
		JNZ	4$
		CMP	WPTR 8[SI],'C '
		JNZ	4$
		SETT	COMENT_FOUND
4$:
endif
		CMP	CURNMOD_GINDEX,0
		JNZ	COMENT_IGNORE
		CALL	DO_DEFINE_MODULE
COMENT_IGNORE::
		RET


YES_DOSSEG::
		SETT	DOSSEG_FLAG
YES_QC1::
YES_NOPAD::
YES_PASS2::
		RET

YES_CODEVIEW::
;		SETT	CVINFO_THIS_MODULE
NO_RET:
		RET

YES_LIBNAM::
		;
		;COPY LIBRARY NAME, IF NOT ALREADY IN LIST...
		;MOVE IT TO OUTBUF
		;
		MOV	ECX,END_OF_RECORD
		MOV	EDI,OFF INBUF+4

		SUB	ECX,ESI
		MOV	EAX,EDI

		MOV	[EDI-4],ECX

		REP	MOVSB

		MOV	DPTR [EDI],1A0DH

		push	EAX
		call	_lib_routine_final_coment
		add	ESP,4
		ret
		;JMP	LIB_ROUTINE_FINAL_COMENT


YES_MODNAME::
		MOV	EDI,OFF MODULE_NAME+4
		GET_OMF_NAME_LENGTH		;HANDLE SYMANTEC KLUDGE

		MOV	ECX,EAX
		MOV	[EDI-4],EAX

		REP	MOVSB

		RET

YES_MODEL::
		MOV	BL,1[ESI]

		AND	EBX,0DFH		;UPPER-CASE

		SUB	EBX,'A'

		CMP	EBX,'Z'-'A'
		JA	NO_MODEL

		MOV	AL,MODEL_TABLE[EBX]
		MOV	CL,MEMORY_MODEL

		TEST	AL,AL
		JZ	NO_MODEL

		CMP	CL,AL
		JNZ	YM_5
NO_MODEL:
		RET

YM_5:
		MOV	MEMORY_MODEL,AL

		OR	CL,CL
		JZ	NO_MODEL

		MOV	AL,MODEL_CONFLICT_ERR
		CALL	WARN_RET
		RET

COMENT		ENDP


		.CONST

MODEL_TABLE	LABEL	BYTE

		DB	0,0,MODEL_COMPACT,0,0,MODEL_FLATOS2,0,MODEL_HUGE,0,0,0,MODEL_LARGE,MODEL_MEDIUM,MODEL_FLATNT
		DB	0,0,0,0,MODEL_SMALL,0,0,0,0,MODEL_DOSX,0,0


		ALIGN	4

COMENT_TABLE	LABEL	DWORD

		DD	COMENT_IGNORE,YES_LIBNAM,COMENT_IGNORE,COMENT_IGNORE	;80-83
		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;84-87
		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;88-8B
		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;8C-8F
		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;90-93
		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;94-97
		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;98-9B
		DD	COMENT_IGNORE,YES_MODEL,YES_DOSSEG,YES_LIBNAM		;9C-9F
		DD	YES_OMF_EXTENT,YES_CODEVIEW,YES_PASS2,YES_MODNAME	;A0-A3

		DD	YES_EXESTR,YES_QC1,YES_INCERR,YES_NOPAD			;A4-A7
		DD	YES_WKEXT,YES_LZEXT,YES_PHARLAP,COMENT_IGNORE		;A8-AB
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;AC-AF
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;B0-B3
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;B4-B7
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;B8-BB
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;BC-BF
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;C0-C3
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;C4-C7
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;C8-CB
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;CC-CF
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;D0-D3
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;D4-D7
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;D8-DB
;		DD	COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE,COMENT_IGNORE	;DC-DF

		ALIGN	4
OMF_EXTENT_TABLE	LABEL	DWORD
		DD	BAD_OMF_EXTENT	;00
		DD	YES_IMPORT	;01
		DD	YES_EXPORT	;02
		DD	YES_INCDEF	;03
		DD	YES_PMLIB	;04	??
		DD	YES_LNKDIR	;05
		DD	YES_BIG_ENDIAN	;06
		DD	YES_PCH		;07


		.CODE	PASS1_TEXT

YES_OMF_EXTENT	PROC
		;
		;
		;
		MOV	BL,[ESI]			;GET TYPE BYTE
		INC	ESI

		CMP	EBX,8
		JAE	BAD_OMF_EXTENT

		JMP	OMF_EXTENT_TABLE[EBX*4]

BAD_OMF_EXTENT::
		MOV	AL,BAD_OMF_EXTENT_ERR
		push	EAX
		call	_err_abort

YES_OMF_EXTENT	ENDP


YES_IMPORT	PROC

if	fg_segm
		;
		;01	;1 MEANS IMPORT, 2 MEANS EXPORT (FROM C5.1????)
		;01	;1 MEANS ORDINAL, 0 MEANS BY NAME
		;STRING	;THIS IS THE SYMBOL NAME
		;STRING	;THIS IS THE LIBRARY NAME
		;IF ORDINAL, THIS IS THE ORDINAL #
		;
		RESS	IMP_BY_NAME,BH
		MOV	AL,[ESI]
		INC	ESI
		TEST	AL,AL
		JNZ	L1$
		SETT	IMP_BY_NAME
L1$:
		MOV	EDI,OFF IMPEXP_INTNAM	;GET INTERNAL NAME
		CALL	GET_NAME_HASH_DI

		MOV	EDI,OFF IMPEXP_MOD	;GET MODULE NAME
		CALL	GET_NAME_HASH_DI

		XOR	EAX,EAX
		BITT	IMP_BY_NAME,AL
		JNZ	L3$

		MOV	DPTR IMPEXP_NAM+4,EAX
		MOV	AX,[ESI]
		ADD	ESI,2
L2$:
		MOV	ECX,END_OF_RECORD
		MOV	IMP_ORDNUM,EAX		;STORE IMPORT #
		CMP	ECX,ESI
		JNZ	L21$
L25$:
		BITT	FORCE_DOS_MODE
		JNZ	L9$
		CALL	DEFINE_IMPORT
		;
		CALL	SELECT_OUTPUT_SEGMENTED_OR_PE
		RET

L3$:
		MOV	EDI,OFF IMPEXP_NAM	;GET EXTERNAL NAME
		CALL	GET_NAME_HASH_DI
		XOR	EAX,EAX			;MAKE SURE HINT IS 0
		JMP	L2$

L21$:
		MOV	AL,[ESI]		;SKIP EXTRA ZERO FOR BORLAND
		INC	ESI
		TEST	AL,AL
		JNZ	EXP_ERROR
		CMP	ECX,ESI
		JZ	L25$
EXP_ERROR:
		CALL	OBJ_PHASE
		JMP	L25$

endif

L9$:
		MOV	AL,NO_IMPORTS_ERR
		CALL	ERR_RET
		RET

YES_IMPORT	ENDP


YES_INCDEF	PROC
		;
		;
		;
		XOR	EAX,EAX
		XOR	EBX,EBX
		MOV	AX,[ESI]
		MOV	BX,[ESI+2]
		ADD	EXTDEF_DELTA,EAX
		ADD	LINNUM_DELTA,EBX
		RET

YES_INCDEF	ENDP


YES_PMLIB	PROC
		;
		; SOMETHING ABOUT LINK386 DLL LOADDS
		;
		SETT	PMLIB_FLAG
		RET

YES_PMLIB	ENDP


YES_LNKDIR	PROC
		;
		;C++ DIRECTIVE
		;
		;FLAGS		1 BYTE
		;PCODE VERSION	1 BYTE
		;CV VERSION	1 BYTE
		;

LNKDIR_REC	RECORD	LNKDIR_JUNK:5,LNKDIR_RUN_MPC:1,LNKDIR_OMIT_PUBLICS:1,LNKDIR_NEW_EXE:1
		;
		MOV	AL,[ESI]
		MOV	BL,-1
		MOV	LNKDIR_FLAGS,AL
		TEST	AL,MASK LNKDIR_NEW_EXE
		JZ	L1$
		SETT	PCODE_NEW_EXE,BL
		BITT	OUTPUT_SEGMENTED,BH
		JNZ	L1$
if	fg_pe
		BITT	OUTPUT_PE,BH
		JNZ	L1$
endif
		MOV	EXETYPE_FLAG,DOS4_SEGM_TYPE
		CALL	SELECT_OUTPUT_SEGMENTED_OR_PE
L1$:
		TEST	AL,MASK LNKDIR_OMIT_PUBLICS
		JZ	L2$
		SETT	PCODE_OMIT_PUBLICS,BL
L2$:
		TEST	AL,MASK LNKDIR_RUN_MPC
		JZ	L3$
		SETT	PCODE_RUN_MPC,BL
L3$:
		XOR	EAX,EAX
		MOV	AX,[ESI+1]
		SETT	LNKDIR_FLAG,BL		;LNKDIR DONE
		MOV	LNKDIR_PCODE_CV,EAX
		RET

YES_LNKDIR	ENDP


YES_BIG_ENDIAN	PROC
		;
		;HMM...
		;
		SETT	BIG_ENDIAN_FLAG
		RET

YES_BIG_ENDIAN	ENDP


YES_PCH		PROC
		;
		;THIS FILE CONTAINS PRECOMPILED HEADER CODEVIEW INFO
		;
		SETT	PCH_HERE
		RET

YES_PCH		ENDP


YES_EXPORT	PROC
		;
		;
		;
if	fg_segm OR fg_pe

		MOV	AL,[ESI]
		INC	ESI

		MOV	CH,AL
		AND	AL,1FH

		SHRI	CH,5
		MOV	EXP_PWORDS,AL		;# OF PARAMETER WORDS

		MOV	EDI,OFF IMPEXP_NAM
		MOV	EXP_FLAGS,CH
		;RESIDENT_NAME, NODATA, ORD
		CALL	GET_NAME_HASH_DI	;GET EXPORTED NAME

		MOV	EDI,OFF IMPEXP_INTNAM
		CALL	GET_NAME_HASH_DI	;INTERNAL NAME IF DIFFERENT

		MOV	AL,EXP_FLAGS
		XOR	ECX,ECX

		TEST	AL,MASK ENT_ORD_SPECIFIED;ORDINAL SPECIFIED?
		JZ	L1$

		MOV	CX,[ESI]
		ADD	ESI,2
L1$:
		MOV	EAX,END_OF_RECORD
		MOV	EXP_ORDNUM,ECX

		CMP	EAX,ESI
		JNZ	L19$
L2$:
		BITT	FORCE_DOS_MODE
		JNZ	L9$
		;
		;IF BOTH NAMES PROVIDED, MARK USE_EXTNAM
		;
		MOV	EAX,IMPEXP_INTNAM+4
		MOV	ECX,IMPEXP_NAM+4

		TEST	EAX,EAX
		JZ	L3$

		TEST	ECX,ECX
		JZ	L3$

		OR	EXP_FLAGS,MASK ENT_USE_EXTNAM
		JMP	L5$

L3$:
if	fg_pe
		;Bugzilla 3956
		;IF (OUTPUT_PE || !OUTPUT_SEGMENTED && ANY_USE32)
		;
		BITT	OUTPUT_PE
		JNZ	L4$

		BITT	OUTPUT_SEGMENTED
		JNZ	L5$
		BITT	ANY_USE32
		JZ	L5$
L4$:
		CALL	TWEAK_EXPORT_NAMES
endif
L5$:
		CALL	DEFINE_EXPORT
		CALL	SELECT_OUTPUT_SEGMENTED_OR_PE
L9$:
		RET

L19$:
		CALL	OBJ_PHASE
		JMP	L2$

else
		MOV	AL,NO_IMPORTS_ERR
		push	EAX
		call	_err_abort

endif

YES_EXPORT	ENDP


if	fg_pe

TWEAK_EXPORT_NAMES	PROC
		;
		;IF IMPEXP_INTNAM IS NULL, COPY IMPEXP_NAM
		;
		PUSHM	EDI,ESI,EBX
		MOV	EAX,IMPEXP_INTNAM+4

		TEST	EAX,EAX
		JNZ	L1$

		MOV	ECX,IMPEXP_NAM+4
		MOV	EDI,OFF IMPEXP_INTNAM

		ADD	ECX,11
		MOV	ESI,OFF IMPEXP_NAM

		SHR	ECX,2

		REP	MOVSD
L1$:
		;
		;IF A LEADING UNDERSCORE, AND NO '@', STRIP LEADING '_'
		;
		MOV	AL,BPTR IMPEXP_NAM+8
		MOV	EDI,OFF IMPEXP_NAM+8

		CMP	AL,'_'
		JNZ	L9$

		MOV	ECX,IMPEXP_NAM+4	;LENGTH
		MOV	AL,'@'

		REPNE	SCASB

		MOV	ECX,IMPEXP_NAM+4
		JZ	L9$

		MOV	ESI,OFF IMPEXP_NAM+8+1
		MOV	EDI,OFF IMPEXP_NAM+8

		REP	MOVSB
L9$:
		POPM	EBX,ESI,EDI

		RET

TWEAK_EXPORT_NAMES	ENDP

endif

if	fg_segm OR fg_pe

GET_NAME_HASH_DI	PROC	NEAR
		;
		;THIS NO LONGER DOES CONVERSION OR HASHING, ITS DONE LATER...
		;
		GET_OMF_NAME_LENGTH	;LODSB			;LENGTH
		XOR	EDX,EDX
		MOV	ECX,EAX
		MOV	[EDI],EDX
		MOV	[EDI+4],EAX
		ADD	EDI,8
		REP	MOVSB		;STRING
		MOV	[EDI],ECX	;ZEROS AT END
		RET

GET_NAME_HASH_DI	ENDP

endif


if	fg_segm OR fg_pe


SELECT_OUTPUT_SEGMENTED_OR_PE	PROC	NEAR
		;
		;
		;
if	fg_segm AND fg_pe

		GETT	AL,OUTPUT_SEGMENTED
		GETT	CL,OUTPUT_PE

		OR	AL,CL
		JZ	L1$
		RET

L1$:
		BITT	ANY_USE32
		JNZ	L3$

		CALL	SELECT_OUTPUT_SEGMENTED
		RET

L3$:
		CALL	SELECT_OUTPUT_PE

elseif	fg_segm

		CALL	SELECT_OUTPUT_SEGMENTED

else

		CALL	SELECT_OUTPUT_PE

endif

L9$:
		RET

SELECT_OUTPUT_SEGMENTED_OR_PE	ENDP

endif


YES_EXESTR	PROC
		;
		;TACK THIS STRING ON END OF EXE FILE...
		;
		MOV	ECX,END_OF_RECORD
		MOV	EAX,ESI

		SUB	ECX,ESI
		JBE	L9$

		MOV	EDX,OFF EXESTR_STRUCTURE
		CALL	STORE_EAXECX_EDX_SEQ

		CMP	EXESTR_STRUCTURE._SEQ_PTR,1024K	;1 Mb LIMIT
		JAE	L5$
L9$:
		RET

L5$:
		MOV	AL,EXESTR_ERR
		push	EAX
		call	_err_abort

YES_EXESTR	ENDP


YES_INCERR::
		MOV	AL,INCERR_ERR
		push	EAX
		call	_err_abort


YES_WKEXT1	PROC
		;
		;
		;
		;REPEAT
		;INDEX OF WEAK EXTERNAL
		;INDEX OF DEFAULT RESOLUTION
		;
		;WEAK EXTERNALS DO NOT CAUSE LIBRARY SEARCHES, THOUGH WE MAY SEARCH FOR THE 'DEFAULT'
		;THESE MAY LATER BECOME REAL EXTERNS, SO NEED TO SAVE LIBRARY REFERENCE STUFF
		;
		;(IN NEW TECHNOLOGY, CALL THEM 'PROMISED'???
		;

		DOLONG	A
		DOLONG	B

L1$:
		NEXT_INDEX	A		;WEAK SYMBOL
		ADD	EAX,EXTDEF_DELTA
		CONVERT_LINDEX_EAX_EAX	SYMBOL_LARRAY,EDI
		MOV	ECX,EAX
		NEXT_INDEX	B		;DEFAULT SYMBOL
		ADD	EAX,EXTDEF_DELTA
		PUSH	ESI
		CONVERT_LINDEX_EAX_EAX	SYMBOL_LARRAY,EDI
		MOV	EDX,EAX
		CONVERT	ESI,ECX,SYMBOL_GARRAY
		ASSUME	ESI:PTR SYMBOL_STRUCT

		XOR	EBX,EBX
		CONVERT	EDI,EAX,SYMBOL_GARRAY
		ASSUME	EDI:PTR SYMBOL_STRUCT

		MOV	BL,[ESI]._S_NSYM_TYPE
		OR	[EDI]._S_REF_FLAGS,MASK S_SOFT_REF		;MAKE DEFAULT A SOFT REFERENCE FROM THIS MODULE...
		;
		; IF DEFINED OR ALREADY A REFERENCED EXTERNAL OR REFERENCED LIBRARY ITEM
		;IGNORE IT.
		;
		;ALL I CARE ABOUT ARE:	NSYM_UNDEFINED, NSYM_LIBRARY, NSYM_WEAK_EXTRN
		;
		JMP	WEAK_TABLE[EBX*2]

WT_WEAK:
		;
		;ALREADY WEAK, MAKE SURE DEFAULT SYMBOL MATCHES
		;
		CMP	[ESI]._S_WEAK_DEFAULT_GINDEX,EDX
		JNZ	L5$
		OR	[ESI]._S_REF_FLAGS,MASK S_WEAK_AGAIN
		JMP	L7$

L5$:
		MOV	AL,WEAK_DEF_ERR
		CALL	ERR_RET
		JMP	L7$

WT_LIBRARY:
WT_UNDEFINED:
		;
		;MARK THIS AS POSSIBLE WEAK-LIST ITEM
		;
		MOV	[ESI]._S_WEAK_DEFAULT_GINDEX,EDX
		MOV	[ESI]._S_NSYM_TYPE,NSYM_POS_WEAK
L7$:
		POP	ESI
YES_WKEXT::
		CMP	END_OF_RECORD,ESI
		JA	L1$
		JNZ	ERROR
		RET

ERROR:
		CALL	OBJ_PHASE
		RET


		.CONST

		ALIGN	4

WEAK_TABLE	LABEL	DWORD

		DD	WT_UNDEFINED	;MARK THIS AS POS_WEAK, LINK TO DEFAULT
		DD	L7$		;IGNORE ASEG
		DD	L7$		;IGNORE RELOCATABLE
		DD	L7$		;IGNORE NEAR COMMUNAL
		DD	L7$		;IGNORE FAR COMMUNAL
		DD	L7$		;IGNORE HUGE_COMMUNAL
		DD	L7$		;IGNORE CONST
		DD	WT_LIBRARY	;MARK THIS AS POS_WEAK, LINK TO DEFAULT
		DD	L7$		;IGNORE IMPORTS
		DD	L7$		;IGNORE PROMISED
		DD	L7$		;IGNORE ALREADY REFERENCED AS REAL EXTERNAL
		DD	WT_WEAK		;ALREADY WEAK, FLAG IT WEAK AGAIN
		DD	L5$		;ERROR ALREADY LISTED AS POS_WEAK
		DD	L7$		;IGNORE REFERENCED LIBRARY SYMBOL
		DD	L5$		;CANNOT WEAK REFERENCE
		DD	L7$		;IGNORE ALIASED TO SOMETHING ELSE
		DD	L7$		;IGNORE COMDAT
		DD	WT_WEAK		;ALREADY WEAK-DEFINED, FLAG IT WEAK AGAIN
		DD	WT_WEAK		;WEAK-UNREF, FLAG IT WEAK AGAIN
		DD	L7$		;ALIASED-UNREF, IGNORE
		DD	L5$		;POS-LAZY, ERROR
		DD	WT_WEAK		;LAZY, FLAG IT WEAK AGAIN
		DD	WT_WEAK		;LAZY-UNREF, FLAG IT WEAK AGAIN
		DD	L7$		;ALIAS-DEFINED, IGNORE
		DD	WT_WEAK		;LAZY-DEFINED, FLAG IT WEAK AGAIN
		DD	L7$		;NCOMM-UNREF, IGNORE
		DD	L7$		;FCOMM-UNREF, IGNORE
		DD	L7$		;HCOMM_UNREF, IGNORE
		DD	L7$		;ALREADY REFERENCED, IGNORE
		DD	L7$		;UNDECORATED, IGNORE

.ERRNZ	($-WEAK_TABLE)-NSYM_SIZE*2


		.CODE	PASS1_TEXT

YES_WKEXT1	ENDP


YES_PHARLAP	PROC
		;
		;IF '80386' IS STRING, SET THIS MODULE FOR PHARLAP SUPPORT
		;
		MOV	EAX,DPTR [ESI]
		ADD	ESI,4
		CMP	EAX,'8308'
		JNZ	L9$
		MOV	AL,BYTE PTR[ESI]
		CMP	AL,'6'
		JNZ	L9$
		MOV	DEFAULT_SIZE,MASK BIT_32
L9$:
		RET

YES_PHARLAP	ENDP


YES_LZEXT1	PROC
		;
		;LIKE WEAK, EXCEPT DOES LIBRARY SEARCH FOR ME, USES DEFAULT AS LAST RESORT
		;

		DOLONG	A
		DOLONG	B

L1$:
		NEXT_INDEX	A		;LAZY SYMBOL
		ADD	EAX,EXTDEF_DELTA
		CONVERT_LINDEX_EAX_EAX	SYMBOL_LARRAY,EDI
		MOV	ECX,EAX
		NEXT_INDEX	B		;DEFAULT SYMBOL
		ADD	EAX,EXTDEF_DELTA
		PUSH	ESI
		CONVERT_LINDEX_EAX_EAX	SYMBOL_LARRAY,EDI
		MOV	EDX,EAX
		CONVERT	ESI,ECX,SYMBOL_GARRAY
		ASSUME	ESI:PTR SYMBOL_STRUCT

		XOR	EBX,EBX
		CONVERT	EDI,EAX,SYMBOL_GARRAY
		ASSUME	EDI:PTR SYMBOL_STRUCT

		MOV	BL,[ESI]._S_NSYM_TYPE
		OR	[EDI]._S_REF_FLAGS,MASK S_SOFT_REF		;MAKE DEFAULT A SOFT REFERENCE FROM THIS MODULE...
		;
		JMP	LAZY_TABLE[EBX*2]

LZ_UNDEFINED:
		;
		;MARK THIS AS POSSIBLE WEAK-LIST ITEM
		;
		MOV	[ESI]._S_LAZY_DEFAULT_GINDEX,EDX
		MOV	[ESI]._S_NSYM_TYPE,NSYM_POS_LAZY
L7$:
		POP	ESI
YES_LZEXT::
		CMP	END_OF_RECORD,ESI
		JA	L1$
		JNZ	ERROR1
		RET

ERROR1:
		CALL	OBJ_PHASE
		RET

LZ_WEAK_DEFINED:
		PUSH	EDX		;SAVE DEFAULT GINDEX
		MOV	EAX,ECX
		MOV	ECX,ESI
		CALL	REMOVE_FROM_WEAK_DEFINED_LIST
		POP	EDX
		MOV	ESI,ECX
		JMP	LZ_UNDEFINED

LZ_WEAK:
		;
		;WEAK, LAZY OVERIDES THIS...
		;
		PUSH	EDX
		MOV	EAX,ECX
		MOV	ECX,ESI
		CALL	REMOVE_FROM_WEAK_LIST
		POP	EDX
		MOV	ESI,ECX
		JMP	LZ_UNDEFINED

LZ_LAZY:
		;
		;ALREADY LAZY, MAKE SURE DEFAULT SYMBOL MATCHES
		;
		CMP	[ESI]._S_LAZY_DEFAULT_GINDEX,EDX
		JNZ	L5$
		OR	[ESI]._S_REF_FLAGS,MASK S_WEAK_AGAIN
		JMP	L7$

L5$:
		MOV	AL,WEAK_DEF_ERR
		CALL	ERR_RET
		JMP	L7$


		.CONST

		ALIGN	4

LAZY_TABLE	LABEL	DWORD

		DD	LZ_UNDEFINED	;MARK THIS AS POS_LAZY, LINK TO DEFAULT
		DD	L7$		;IGNORE ASEG
		DD	L7$		;IGNORE RELOCATABLE
		DD	L7$		;IGNORE NEAR COMMUNAL
		DD	L7$		;IGNORE FAR COMMUNAL
		DD	L7$		;IGNORE HUGE COMMUNAL
		DD	L7$		;IGNORE CONST
		DD	L7$		;IGNORE IN LIBRARY
		DD	L7$		;IGNORE IMPORTS
		DD	L7$		;IGNORE PROMISED
		DD	L7$		;IGNORE ALREADY REFERENCED AS REAL EXTERNAL
		DD	LZ_WEAK		;ALREADY REFERENCED WEAK, MAKE IT LAZY
		DD	L5$		;ERROR ALREADY LISTED AS POS_WEAK
		DD	L7$		;IGNORE REFERENCED LIBRARY SYMBOL
		DD	L5$		;__imp__UNREF, CANNOT LAZY REFERENCE
		DD	L7$		;IGNORE, ALIASED TO SOMETHING ELSE
		DD	L7$		;IGNORE COMDAT
		DD	LZ_WEAK_DEFINED	;WEAK-DEFINED, MAKE IT LAZY
		DD	LZ_UNDEFINED	;UNREFERENCED WEAK, MARK IT POS_LAZY
		DD	L7$		;UNREFERENCED ALIAS, IGNORE
		DD	L5$		;ALREADY POS_LAZY, ERROR
		DD	LZ_LAZY		;ALREADY LAZY, MARK IT LAZY AGAIN
		DD	LZ_LAZY		;ALREADY UNREF_LAZY, MARK IT LAZY AGAIN
		DD	L7$		;ALIAS-DEFINED, IGNORE
		DD	LZ_LAZY		;LAZY-DEFINED, MARK IT LAZY AGAIN
		DD	L7$		;NCOMM-UNREF, IGNORE
		DD	L7$		;FCOMM-UNREF, IGNORE
		DD	L7$		;HCOMM-UNREF, IGNORE
		DD	L7$		;__imp__, IGNORE
		DD	L7$		;UNDECORATED, IGNORE

.ERRNZ	($-LAZY_TABLE)-NSYM_SIZE*2

		.CODE	PASS1_TEXT

YES_LZEXT1	ENDP


		END

