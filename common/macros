.xlist
	page	,127

.586

debug		EQU	0

V5		EQU	0-1

V6		EQU	0-1

ifndef	J
J	equ	0
endif

K		EQU	*1024
k		EQU	*1024

SOFT		EQU	<>

fg_td		=	-1
fg_cfg		=	-1
fg_pe		=	0-1
fg_dosx		=	-1
fg_cvpack	EQU	V6

_PRODUCT	EQU	12


if	_PRODUCT	EQ	3	;OPTLINK FOR DOS

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	0
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	0

elseif	_PRODUCT EQ 5	;OS2LINK FOR DOS

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	-1
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	-1		;HAS A DEF FILE
fg_slrpack	EQU	0
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	-1
fg_winpack	EQU	0
fg_dospack	EQU	0

elseif _PRODUCT EQ 7

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	-1		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	-1

elseif _PRODUCT EQ 9

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	-1		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	-1
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	-1

elseif _PRODUCT EQ 10			;OPTIMP

fg_td		=	0
fg_cfg		=	0

fg_xref		EQU	0
fg_cv		EQU	0
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	-1		;HAS A DEF FILE
fg_slrpack	EQU	0
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	-1
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	0

elseif _PRODUCT EQ 12			;WINPACK

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	-1
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	-1		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	-1
fg_winpack	EQU	-1
fg_dospack	EQU	0

endif

% ifidni	<HOS>,<OS2>

fgh_os2		EQU	-1
fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	0
fgh_windll	EQU	0
fgh_thread	EQU	-1
fg_virt		EQU	0
fg_sym_virt	EQU	0
FF_COUNT	EQU	10
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14

% elseifidni	<HOS>,<DPMI>

fgh_os2		EQU	0
fgh_prot	EQU	-1
fgh_dpmi	EQU	-1
fgh_win		EQU	0
fgh_windll	EQU	0
fgh_thread	EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14

% elseifidni	<HOS>,<WIN>

fgh_os2		EQU	0
fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	-1
fgh_windll	EQU	0
fgh_thread	EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14

% elseifidni	<HOS>,<WINDLL>

fgh_os2		EQU	0
fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	-1
fgh_windll	EQU	-1
fgh_thread	EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14
fg_td		=	0

% elseifidni	<HOS>,<W32>

		.MODEL	FLAT

fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	0
;fgh_windll	EQU	0
fgh_win32	EQU	-1
fgh_win32dll	EQU	0
fgh_dosx	EQU	0
fgh_inthreads	EQU	-1
fgh_outhreads	EQU	0	;OUTPUT THREADS
fgh_mapthread	EQU	-1
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14
fg_td		=	0

% elseifidni	<HOS>,<W32D>

		.MODEL	FLAT

fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	0
;fgh_windll	EQU	0
fgh_win32	EQU	-1
fgh_win32dll	EQU	-1
fgh_dosx	EQU	0
fgh_inthreads	EQU	-1
fgh_outhreads	EQU	0
fgh_mapthread	EQU	-1
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14
fg_td		=	0

% elseifidni	<HOS>,<DOSX>

		.MODEL	TINY

fgh_os2		EQU	0
fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	0
fgh_windll	EQU	0
fgh_win32	EQU	0
fgh_win32dll	EQU	0
fgh_dosx	EQU	-1
fgh_inthreads	EQU	0
fgh_outhreads	EQU	0
fgh_mapthread	EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14
fg_td		=	0


FILEPARSE_TEXT	EQU	<>
ROOT_TEXT	EQU	<>
PASS1_TEXT	EQU	<>
MIDDLE_TEXT	EQU	<>
PASS2_TEXT	EQU	<>
STARTUP_TEXT	EQU	<>
PHASE1_TEXT	EQU	<>
CVPACK_TEXT	EQU	<>

else

.err
%out	'unknown host'

fgh_os2		EQU	0
fgh_prot	EQU	0
fgh_dpmi	EQU	0
fgh_win		EQU	0
fgh_windll	EQU	0
fgh_thread	EQU	0
fg_virt		EQU	-1
fg_sym_virt	EQU	-1
if	fg_implib
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
PAGE_BITS	EQU	14
else
page_size	EQU	8K
PAGE_SIZE	EQU	8K
PAGE_SHIFT	EQU	3
PAGE_BITS	EQU	13
endif

endif

fgh_anythreads	EQU	fgh_inthreads OR fgh_outhreads OR fgh_mapthread

ifdef	Sver

% ifidn	<Sver>,<Symc>

fg_symc		EQU	-1
fg_td		=	0

endif
endif

ifndef	fg_symc

fg_symc		EQU	0

endif

if	fg_dospack

fg_hufpack	EQU	-1

else

fg_hufpack	EQU	0

endif

if	PAGE_SIZE EQ 16K

PAGE_POWER	EQU	14
PAGE_MASK	EQU	3FFFH

else

PAGE_POWER	EQU	13
PAGE_MASK	EQU	1FFFH

endif

GMEM_FIXED	EQU	0000H
GMEM_MOVEABLE	EQU	0002H
GMEM_ZEROINIT	EQU	0040H
GMEM_NOCOMPACT	EQU	0010H
GMEM_NODISCARD	EQU	0020H
GMEM_MODIFY	EQU	0080H
GMEM_DISCARDABLE EQU	0100H
GMEM_NOT_BANKED	EQU	1000H
GMEM_SHARE	EQU	2000H
GMEM_DDESHARE	EQU	2000H
GMEM_NOTIFY	EQU	4000H
GMEM_LOWER	EQU	GMEM_NOT_BANKED


INBUF_LEN		EQU	1024
SYMBOL_TEXT_SIZE	EQU	8K
NFN_TEXT_SIZE		EQU	320
LONG_OMF_DELTA		EQU	3

INDIRECT_NEST_LIMIT	EQU	10

NEW_FIXUPP_SIZE		EQU	1K

CV_TEMP_SIZE		EQU	9K
TEMP_SIZE		EQU	1K

FILENAME_HASH_SIZE	EQU	0FBH
THEADR_HASH_SIZE	EQU	61
VIRDEF_MCD_HASH_SIZE	EQU	0FBH

CASE_SENSITIVE	EQU	0
MAX_RECORD_LEN	EQU	1024+64+6K	;FOR BORLAND
SLRIB		EQU	0		;NOT OPTLIB
OPTLIB		EQU	0

MAX_LEDATA_LEN	EQU	2K

BLOCK_BASE	EQU	8		;STARTING OFFSET FOR FAR BLOCKS (FIRST DWORD IS USAGE COUNT, NEXT IS NEXT_PTR)
					;**** FARCALLTRANSLATE MAY NOT HANDLE CHANGE CORECTLY ****

EMS_XMS_DELTA	EQU	1K/(PAGE_SIZE/(1K))*2

N_R_THREADS	EQU	4		;# OF OPEN-READ THREADS
N_W_THREADS	EQU	4

;PHYS_TABLE_SIZE EQU	4		;# OF 16K BLOCKS RELEASED LOCALLY OS/2

;MAX_VECTORS	EQU	32K/VECTOR_SIZE*2

M1	EQU	-1

ifndef		_RT

_RT	EQU	<0>

endif
ifndef	_AI

_AI	EQU	<0>

endif

% ifidni	<MYMODEL>,<SMALL>

DCA		EQU	DW
EXTCA		EQU	EXTW
@@CODESIZE	EQU	WORD
FILEPARSE_TEXT	EQU	<>
ROOT_TEXT	EQU	<>
PASS1_TEXT	EQU	<>
MIDDLE_TEXT	EQU	<>
PASS2_TEXT	EQU	<>
STARTUP_TEXT	EQU	<>
PHASE1_TEXT	EQU	<>

else

DCA		EQU	DD
EXTCA		EQU	EXTD
@@CODESIZE	EQU	DWORD

endif

;FG_VIRT 	EQU	_VM*M1		;VIRTUAL MEMORY
;FG_XREF 	EQU	_XR*M1		;CROSS REFERENCE
;FG_CV		EQU	_CV*M1		;CODEVIEW SUPPORT
;FG_SYM_VIRT	EQU	_VM*M1		;SYMBOLS VIRTUAL
;FG_SEGM 	EQU	_SG*M1		;SEGMENTED EXE
;FG_AI		EQU	_AI*M1		;AI ARCHITECTS
;FG_RAT		EQU	_RT*M1		;RATIONAL
;FG_OV		EQU	_O1*M1		;SINGLE LEVEL OVERLAYS
;FG_OS2		EQU	_O2*M1		;OS2 HOST
;FG_ROM		EQU	_RM*M1		;OPTLOC
;FG_DEF		EQU	_DF*M1		;.DEF FILE
;FG_SLRPACK	EQU	_SP*M1		;SLR LZW PACKING
;FG_PLINK	EQU	_PL*M1		;PLINK COMPATIBLE
;FG_MSCMD	EQU	_MS*M1		;MS CMDLINE SUPPORT
;
;FG_IMPLIB	EQU	0

;FG_PHAR 	EQU	0

PUSHM	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P
	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	PUSH	XX
	ENDM
	ENDM


POPM	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P
	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	POP	XX
	ENDM
	ENDM


EXTB	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P

	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	EXTRN	XX:BYTE
	ENDM

	ENDM


EXTD	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P

	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	EXTRN	XX:DWORD
	ENDM

	ENDM


EXTQ	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P

	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	EXTRN	XX:QWORD
	ENDM

	ENDM


EXTP	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P

	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	EXTRN	XX:PROC
	ENDM

	ENDM


EXTA	MACRO	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P

	IRP	XX,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
	IFB	<XX>
	EXITM
	ENDIF
	EXTRN	XX:ABS
	ENDM

	ENDM


if	0;fgh_os2

	SOFT	EXTF	DOSREAD,DOSWRITE,DOSCHGFILEPTR,DOSOPEN,DOSNEWSIZE,DOSREALLOCSEG,DOSSETSIGHANDLER
	SOFT	EXTF	DOSEXIT,DOSCLOSE,DOSSEMCLEAR,DOSSEMSET,DOSSEMWAIT
	SOFT	EXTF	DOSSEMREQUEST,DOSENTERCRITSEC,DOSEXITCRITSEC
	SOFT	EXTF	DOSFREESEG,DOSSETPRTY,DOSALLOCSEG,DOSCREATETHREAD
	SOFT	EXTF	DOSQCURDISK,DOSDELETE,DOSFINDFIRST,DOSFINDNEXT
	SOFT	EXTF	DOSQFILEINFO,DOSSETFILEINFO,DOSSLEEP,DOSSETMAXFH

endif

if	fgh_win

	.286P

	SOFT	EXTF	INITAPP,INITTASK,GLOBALALLOC,GLOBALLOCK,GLOBALHANDLE,GLOBALFREE,WAITEVENT,DOS3CALL,GETDOSENVIRONMENT
	SOFT	EXTF	GETEXEPTR

endif

	PUBLIC	fg_ov,fg_virt,fg_xref,fg_sym_virt,fg_cv,fg_def,fg_rom,fg_implib,fg_pe,fg_cvpack
	PUBLIC	fg_segm,fg_ai,fg_rat,fg_slrpack,fg_plink,fg_mscmd,fgh_dpmi,fg_td,fg_cfg

fg_prot 		EQU	(fg_segm OR fg_ai OR fg_rat)

ife	(fg_rat or fg_ai)
fg_norm_exe		EQU	-1
else
fg_norm_exe	EQU	0
endif

if	fg_plink OR fg_ov
any_overlays		EQU	-1
else
any_overlays		EQU	0
endif

alloc_support		EQU	any_overlays

fg_pack_zero		EQU	-1

exepack_support EQU	-1

if	fgh_prot
data_in_codeseg		EQU	0
;CDATA			EQU	DGROUP
else
data_in_codeseg		EQU	-1
;CDATA			EQU	CODE
endif

if	fg_ai

MOVABLE_MASK	EQU	0

endif

BPTR	EQU	BYTE PTR
WPTR	EQU	WORD PTR
DPTR	EQU	DWORD PTR
BPT	EQU	BYTE PTR
WPT	EQU	WORD PTR
OFF	EQU	OFFSET
DWORDP	EQU	DWORD

LE_REC		RECORD	BIT_CONT:1,BIT_ME:1,BIT_LE:1,BIT_LI:1,BIT_FI:1,BIT_FR:1,BIT_32:1

		;BIT_CONT		;RECORD IS CONTINUED ON NEXT BLOCK
		;BIT_2R
		;BIT_ME
		;BIT_LE			;LEDATA
		;BIT_LI			;LIDATA
		;BIT_FI			;FIXUPP
		;BIT_FR			;FORREF
		;BIT_32			;32-BIT RECORD

;RECTYP_CLASS	EQU	1
;RECTYP_GROUP	EQU	2
;RECTYP_MODULE	EQU	3
;RECTYP_OUTFILE	EQU	4
;RECTYP_SEGMENT	EQU	5
;RECTYP_COMDAT	EQU	6

PRETEXT_PTR_STRUCT	STRUC

		DD	?

PRETEXT_PTR_STRUCT	ENDS

_PTP_MCD	EQU	-4

TPTR_STRUCT	STRUC

_TP_FLAGS	DD	?		;LOCALNESS
_TP_HASH	DD	?
_TP_LENGTH	DD	?
_TP_TEXT	DD	?

TPTR_STRUCT	ENDS

if	any_overlays

LIBALLOC_STRUCT 	STRUC

_LIBALLOC_NEXT_HASH	DD	?
_LIBALLOC_NEXT		DD	?	;NEXT REFERENCING SEGMOD
_LIBALLOC_FROM		DD	?	;REFERENCING SEGMOD
_LIBALLOC_TO		DD	?	;REFERENCED SEGMOD

LIBALLOC_STRUCT 	ENDS

PUBALLOC_STRUCT 	STRUC

_PUBALLOC_NEXT_HASH	DD	?
_PUBALLOC_NEXT		DD	?	;NEXT REFERENCING SEGMOD
_PUBALLOC_FROM		DD	?	;REFERENCING SEGMOD
_PUBALLOC_TO		DD	?	;REFERENCED SYMBOL

PUBALLOC_STRUCT 	ENDS

CACHE_STRUCT	STRUC

_CACHE_FLAGS	DB	?
_CACHE_ORDER	DB	?
_CACHE_MIN_SIZE DW	?
_CACHE_MAX_SIZE DW	?

CACHE_STRUCT	ENDS

CACHE_FLAGS	RECORD	CCH_MIN_PCNT:1, CCH_MAX_PCNT:1

endif

ALLOCS_STRUCT	STRUC

ALLO_LAST_LIST	DD	?		;LAST STORED LIST OF BLOCKS
ALLO_PTR	DD	?		;LOGICAL PTR TO NEXT AVAILABLE BYTE
ALLO_CNT	DD	?		;BYTES LEFT THIS BLOCK
ALLO_SUB_CNT	DD	?
ALLO_SUB_PTR	DD	?
ALLO_NEXT_BLK	DD	?		;PTR TO STORE NEXT BLOCK LOCALLY
ALLO_HASH_TABLE_PTR	DD	?	;HASH TABLE IF IT EXISTS
ALLO_HASH	DD	?		;HASH IF IT EXISTS
ALLO_BLK_CNT	DD	?		;ALLOCATED BLOCK COUNT
ALLO_BLK_LIST	DD	8 DUP(?)	;LIST OF UP TO 8 ALLOCATED BLOCKS

ALLOCS_STRUCT	ENDS


LKD_ALLOC_STRUCT	STRUC

_LKD_ALLOC_PTR	DD	?		;NEXT AVAILABLE BYTE
_LKD_AVAIL_1K	DD	?		;LIST OF AVAILABLE BLOCKS
_LKD_AVAIL_2K	DD	?		;
_LKD_AVAIL_MISC	DD	?		;LIST OF MISCELLANEOUS SIZED BLOCKS
_LKD_ALLOC_CNT	DD	?		;BYTES LEFT THIS BLOCK
_LKD_BLKS_COUNT2 DD	?		;# OF BLOCKS OWNED * 2
_LKD_BLKS_OWNED	DD	16 DUP(?)	;MAX LOCKED STORAGE

LKD_ALLOC_STRUCT	ENDS


SEQ_STRUCT	STRUC

_SEQ_PTR	DD	?		;NEXT ADDRESS TO WRITE TO
_SEQ_TABLE	DD	32K/PAGE_SIZE*4 DUP(?)	;128K MAX DATA THIS TYPE
_SEQ_TARGET	DD	?		;PTR TO NEXEHEADER OFFSET OF OFFSET...
_SEQ_NEXT_TARGET DD	?		;

SEQ_STRUCT	ENDS


DTA_STRUCT	STRUC

FDATECREATION	DW	?
FTIMECREATION	DW	?
FDATELASTACCESS DW	?
FTIMELASTACCESS DW	?
FDATELASTWRITE	DW	?
FTIMELASTWRITE	DW	?
CBFILE		DD	?
CBFILEALLOC	DD	?
ATTRFILE	DW	?
CCHNAME 	DB	?
ACHNAME 	DB	13 DUP(?)

DTA_STRUCT	ENDS

CMDLINE_STRUCT	STRUC

CMD_SELECTED	DCA	?	;USE SRCNAM (NZ) OR NUL
CMD_EXTENT	DD	?	;DEFAULT EXTENT
if	fg_mscmd
;CMD_PREPROC	DW	?	;LOOK FOR LEADING COMMAND CHARS?
;CMD_POSTPROC	DW	?	;ROUTINE AFTER FILENAME FOUND
;CMD_DESTINATION DW	?	;FN STRUCTURE
CMD_DESIRED	DCA	?	;WANT AT ALL?  LIKE OUTPUT LIBRARY NAME
CMD_PMSG	DD	?	;PROMPT MESSAGE
endif

CMDLINE_STRUCT	ENDS

;LNAME_ARRAY_BLOCK_SIZE	EQU 2048		;room for 128 more

;LNAME_STRUCT	STRUC
;
;_LNAME_NEXT		DD	?		;PTR TO NEXT WITH SAME HASH
;_LNAME_HASH		DW	?		;4 MORE HASH BITS
;_LNAME_TEXT		DW	?		;AT LEAST TWO ZEROS...
;
;LNAME_STRUCT	ENDS

;SMALL_LNAME_HASH	EQU	3fdh	;PRIME NUMBER???

if page_size eq 16k
PAGE_SIZE_4_HASH	EQU	0FFDH
PAGE_SIZE_8_HASH	EQU	7F7H
SMALL_TEXT_HASH 	EQU	0ffdh	;PRIME?????
SMALL_SYM_HASH		EQU	0FFDH	;1fffh	;0ffdh	;PRIME?????
SMALL_RAINBOW_HASH	EQU	0ffdh	;PRIME?????
elseif page_size eq 8k
PAGE_SIZE_4_HASH	EQU	7F7H
PAGE_SIZE_8_HASH	EQU	3FDH
;SMALL_TEXT_HASH 	EQU	7F7H
SMALL_SYM_HASH		EQU	0ffdh	;7F7H
;SMALL_RAINBOW_HASH	EQU	7F7H
else
.err
endif
;LARGE_LNAME_HASH	EQU	7F7H
;LARGE_FAR_HASH 	EQU	1FFFH
;HUGE_FAR_HASH		EQU	3FFDH

PRIME_128		EQU	007FH
PRIME_256		EQU	00FBH
PRIME_512		EQU	01FDH
PRIME_1K		EQU	03FDH
PRIME_2K		EQU	07F7H
PRIME_4K		EQU	0FFDH

SEGMENT_HASH_SIZE	EQU	0FFFH
SEGMENT_HASH_DXLIMIT	EQU	0FFFH

FIXDS	MACRO
;;	APUSH	SS
;;	APOP	DS
	ENDM

FIXES	MACRO
;;	APUSH	SS
;;	APOP	ES
	ENDM

APUSH	MACRO	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	PUSHAS	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	IRP	X,<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10>
	IFNB	<X>
	PUSH	X
	ENDIF
	ENDM
	ENDM

APOP	MACRO	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	POPAS	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	IRP	X,<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10>
	IFNB	<X>
	POP	X
	ENDIF
	ENDM
	ENDM


	.SALL

LONGST		STRUC
LW		DW	?
HW		DW	?
LONGST		ENDS

LONGB		STRUC
LB		DB	?
HB		DB	?
LONGB		ENDS


LARRAY_STRUCT	STRUC

_LARRAY_NEXT 	DD	?	;		NEXT PLACE TO STORE ENTRY
_LARRAY_LIMIT	DD	?	;		# OF VALID ENTRIES IN TABLE
_LARRAY_COUNT	DD	?	;		# LEFT TO ALLOCATE THIS BLOCK
_LARRAY_NEXT_BASE	DD	?
_LARRAY_BASES	DD	32K/(PAGE_SIZE/4) DUP(?)	;POINTS TO DGROUP 512-BYTE ALLOCATION

LARRAY_STRUCT	ENDS


STD_PTR_S	STRUC				;USED BY LIBRARIES, SOON MASTER GROUPS, SEGMENTS, CLASSES, POSSIBLY EVEN SYMBOLS, OTHERS

_STD_BASE_NEXT 	DD	?	;		NEXT PLACE TO STORE BLOCK POINTER
_STD_NEXT 	DD	?	;		NEXT PLACE TO STORE PTR
_STD_LIMIT	DD	?	;		# OF VALID ENTRIES IN TABLE
_STD_COUNT	DD	?	;		# LEFT TO ALLOCATE THIS BLOCK
_STD_ALLOC_ROUTINE	DCA	?	;	ALLOCATE MEMORY FOR PTRS
_STD_TYPE_TEXT	DD	?
_STD_INSTALL_ROUTINE	DCA	?	;	INSTALL NEXT ENTRY INTO TABLE
_STD_INSTALL_RANDOM_ROUTINE	DCA	?	;
_STD_AX_TO_DSSI	DCA	?	;		CONVERT AX TO PTR IN DS:SI PHYSICAL
_STD_AX_TO_ESDI	DCA	?	;		CONVERT AX TO PTR IN ES:DI PHYSICAL
if	0	;fgh_os2
_STD_AX_TO_DSSI_THREAD	DCA	?	;	CONVERT FROM THREAD (SS!=DGROUP)
endif
_STD_EAX_TO_EBX	DD	?
_STD_PTRS	DD	16 DUP(?)	;	INITIALLY PTRS, THEN PTRS TO BLOCKS, THEN PTR TO MASTER BLOCK

STD_PTR_S	ENDS


PAR_PTR_S	STRUC		;USED FOR PARALLEL STRUCTURES

_PAR_PTRS_PTR	DD	?	;ADDRESS OF BLOCK POINTERS
_PAR_TO_DSSI	DCA	?
_PAR_TO_ESDI	DCA	?
_PAR_SHIFTS	DW	?	;
_PAR_MASK	DW	?	;
_PAR_BLOCKS	DW	?	;# OF BLOCKS MAX
_PAR_LIMIT	DW	?	;FOR RANDOM INSTALLERS

PAR_PTR_S	ENDS


;CONVERT_PAR_GINDEX_AX_DSSI	MACRO	XX
;
;		LEA	SI,XX
;		CALL	DGROUP:[SI]._PAR_TO_DSSI
;
;		ENDM

;CONVERT_PAR_GINDEX_AX_ESDI	MACRO	XX
;
;		LEA	DI,XX
;		CALL	DGROUP:[DI]._PAR_TO_ESDI
;
;		ENDM


FA_S		STRUC

FA_PTR		DD	?
FA_CNT		DD	?
FA_BASE		DD	?

FA_S		ENDS

if	0;fgh_os2

SEMAPHORE_STRUCT	STRUC

_SEM_ITSELF	DD	?
_SEM_COUNTER	DW	?
_SEM_NOTHING	DW	?

SEMAPHORE_STRUCT	ENDS

endif

PLTYPES 	RECORD	SEG_OVERLAYABLE:1,SECTION_ASSIGNED:1,LEVEL_0_SECTION:1


LDATA_HEADER_TYPE STRUC

_LD_BLOCK_BASE	DD	?	;ADDRESS AT START OF PAGE_SIZE BLOCK
_LD_NEXT_LDATA	DD	?	;NEXT LDATA THIS SEGMOD, OR FIXUPP
_LD_LENGTH	DW	?	;LENGTH OF DATA RECORD
_LD_TYPE	DB	?	;LEDATA, FIXUPP, LIDATA, 32 VS 16 BIT,FR, ETC
		DB	?
_LD_OFFSET	DD	?	;IF DATA, THIS IS SEGMOD OFFSET

LDATA_HEADER_TYPE ENDS


FIXUPP_HEADER_TYPE STRUC

_FH_BLOCK_BASE	DD	?	;ADDRESS AT START OF PAGE_SIZE BLOCK
_FH_NEXT_FIXUPP DD	?

_FH_LENGTH	DW	?
_FH_TYPE	DB	?
_FH_XTRA	DB	?

FIXUPP_HEADER_TYPE ENDS


FORREF_HEADER_TYPE STRUC

_FR_BLOCK_BASE	DD	?	;ADDRESS AT START OF PAGE_SIZE BLOCK
_FR_NEXT_FORREF DD	?

_FR_LENGTH	DW	?
_FR_TYPE	DB	?
_FR_XTRA	DB	?	;TYPE OF DATA TO FIXUPP

FORREF_HEADER_TYPE ENDS


LINNUM_HEADER_TYPE STRUC

_LN_BLOCK_BASE	DD	?
_LN_NEXT_LINNUM DD	?	;NEXT LINNUM RECORD THIS SEG_SRC_MOD

_LN_LENGTH	DW	?	;LENGTH AFTER HEADER
_LN_TYPE	DB	?	;16 OR 32 BIT
		DB	?

_LN_SRC_GINDEX	DD	?	;SOURCE FILE INDEX FOR THESE LINES

LINNUM_HEADER_TYPE ENDS


FARCALL_HEADER_TYPE STRUC

_FC_BLOCK_BASE		DD	?
_FC_NEXT_FARCALL	DD	?
_FC_LENGTH		DD	?
_FC_SEGMOD_GINDEX	DD	?

FARCALL_HEADER_TYPE ENDS


LINK_TARGETS_STRUC	STRUC

_LT_SEG_CLASS	DD	?
_LT_NEXT	DD	?
_LT_TYPE	DW	?

LINK_TARGETS_STRUC	ENDS

SSSS		STRUC

ADDER		DW	?
AMASK		DW	?

SSSS		ENDS


CMDLINE_PTR	EQU	CURN_INPTR
CMDLINE_LENGTH	EQU	CURN_COUNT

MAP_RECORD	RECORD	MAP_A:1,MAP_E:1,MAP_N:1,MAP_M:1,MAP_S:1,MAP_L:1,MAP_D:1

if	fg_segm

FLG0C	RECORD	APPTYPE:1,\	;0=PROGRAM, 1=DLL
		APP??:1,\	;UNKNOWN
		APPERRORS:1,\	;ERRORS DURING LINK
		APP???:3,\	;UNKNOWN
		APPWINFLAGS:2,\ ;WINDOWAPI, WINDOWCOMPAT, NOTWINDOWCOMPAT
		APPFLOATS:1,\	;FLOATS USED?
		APP386:1,\	;386 INSTRUCTIONS
		APP286:1,\	;286 INSTRUCTIONS
		APP86:1,\	;8086-ONLY
		APPPROT:1,\	;PROTMODE APP
		APPINSTANCE:1,\ ;INSTANCE DATA
		APPMULTI:1,\	;MULTIPLE DATA (NONSHARED)
		APPSOLO:1	;SOLO DATA (SHARED)

endif

OFFS		EQU	WORD PTR 0
SEGM		EQU	WORD PTR 2
PHYS		EQU	WORD PTR 4


GLOBALSEM_STRUCT	STRUC

_SEM_ITSELF	DD	?
_SEM_COUNTER	DD	?

GLOBALSEM_STRUCT	ENDS


if	fg_virt

EMS_STRUC	STRUC

_EMS_LENGTH	DD	?	;LENGTH OF REGION
_EMS_SRC_TYPE	DB	?	;0 = CONVENTIONAL, 1 = EMS
_EMS_SRC_HANDLE DW	?	;
_EMS_SRC_OFFSET DW	?
_EMS_SRC_SEG	DW	?
_EMS_DST_TYPE	DB	?
_EMS_DST_HANDLE DW	?
_EMS_DST_OFFSET DW	?
_EMS_DST_SEG	DW	?

EMS_STRUC	ENDS

EMS_XMS_STRUCT	STRUC

_EX_PREV_BLOCK	DW	?
_EX_NEXT_BLOCK	DW	?
_EX_TO_LOG	DW	?

EMS_XMS_STRUCT	ENDS

XMS_STRUC	STRUC

XMS_PAGES	DW	?	;# OF PAGES FOR THIS GUY
XMS_HANDLE	DW	?	;HANDLE FOR THIS GUY

XMS_STRUC	ENDS

endif

ALLOC_STRUC	STRUC
_A_PTR		DW	?
_A_RELEASED	DW	?
ALLOC_STRUC	ENDS

GET_OMF_NAME_LENGTH	MACRO

;if	fg_symc

		EXTERNDEF	GET_OMF_NAME_LENGTH_ROUTINE:PROC

		CALL	GET_OMF_NAME_LENGTH_ROUTINE

;else
;		LODSB
;		XOR	AH,AH
;endif

		ENDM

GET_OMF_NAME_LENGTH_EAX	MACRO
		LOCAL	L1

		EXTERNDEF	TOO_LONG:PROC

		MOV	ECX,EAX
		MOV	AL,BPTR [EAX]

		INC	ECX
		AND	EAX,0FFH

		CMP	AL,-1
		JNZ	L1

		CMP	BPTR [ECX],AH
		JNZ	L1

		MOV	AX,[ECX+1]
		ADD	ECX,3

		CMP	EAX,SYMBOL_TEXT_SIZE
		JA	TOO_LONG

L1:
		ENDM


GET_NAME_HASH	MACRO	;SYM_TOO_LONG
;;GET NAME FROM ESI INTO SYMBOL_TPTR IN EDI
		;;ES=SS=DGROUP
		;;DS:SI IS SOURCE TEXT, SYMBOL_LENGTH&SYMBOL_TEXT ARE DESTIN
		GET_OMF_NAME_LENGTH
		MOV	[EDI]._TP_LENGTH,EAX	;;STORE SYMBOL LENGTH
		LEA	EDI,[EDI]._TP_TEXT
		CALL	OPTI_MOVE		;;GO THRU JUMP TABLE U/L

		ENDM

GET_NAME_HASHD	MACRO
;;GET NAME FROM DS:SI INTO SYMBOL_TEXT IN DATA SEGMENT
		;;ES=SS=DGROUP
		;;DS:SI IS SOURCE TEXT, SYMBOL_LENGTH&SYMBOL_TEXT ARE DESTIN
		MOV	EAX,[ESI]		;;SYMBOL LENGTH
		ADD	ESI,4
		MOV	[EDI],EAX
		ADD	EDI,4
		CALL	OPTI_MOVE		;;GO THRU JUMP TABLE U/L
		ENDM

INSTALL_POINTER_LINDEX	MACRO	XX		;;INSTALL AX:BX=PTR, RETURN AX=LINDEX

		PUSH	ECX
		MOV	ECX,OFF XX
		EXTERNDEF	LOCAL_PTR_INSTALL:PROC
		CALL	LOCAL_PTR_INSTALL
		POP	ECX
		ENDM

INSTALL_POINTER_GINDEX	MACRO	XX		;;INSTALL AX:BX=PTR, RETURN AX=GINDEX
;;		IFIDN	<_FILE_LIST_GARRAY>,<XX>
;;		ELSEIFIDN	<AREA_GARRAY>,<XX>
		IFIDNI	<XX>,<CV_LTYPE_GARRAY>
		EXTERNDEF	INSTALL_LTYPE_POINTER:PROC
		CALL	INSTALL_LTYPE_POINTER
		ELSEIFIDNI	<XX>,<CV_GTYPE_GARRAY>
		EXTERNDEF	INSTALL_GTYPE_POINTER:PROC
		CALL	INSTALL_GTYPE_POINTER
		ENDIF
		ENDM


INSTALL_POINTER_RANDOM_GINDEX	MACRO	X
		;
		;EAX IS POINTER TO STORE OFF GINDEX (ECX)
		;
		PUSH	ECX
		DEC	ECX

		PUSH	EDX
		MOV	EDX,ECX

		SHR	EDX,PAGE_BITS-2
		AND	ECX,PAGE_MASK SHR 2

		MOV	EDX,X[EDX*4]._STD_PTRS

		MOV	DPTR [EDX+ECX*4],EAX
		POP	EDX

		POP	ECX

		ENDM


INSTALL_GINDEX_LINDEX	MACRO	XX		;;INSTALL AX=GINDEX, RETURN AX=LINDEX
		IFIDN	<LNAME_LARRAY>,<XX>
		.ERR
		ELSE
		PUSH	ECX
		MOV	ECX,OFF XX
		EXTERNDEF	LOCAL_PTR_INSTALL:PROC
		CALL	LOCAL_PTR_INSTALL
		POP	ECX
		ENDIF
		ENDM

NEW_ARRAY	MACRO	XX,YY
		PUSH	BX
		PUSH	AX
		LEA	BX,XX
		MOV	AX,YY
		EXTERNDEF	DO_NEW_ARRAY:PROC
		CALL	DO_NEW_ARRAY
		POPM	AX,BX
		ENDM

INIT_ARRAY	MACRO	XX,SIZE
		MOV	AX,XX&_ARRAY.SP_BASE
;;		ADD	AX,SIZE
		MOV	XX&_ARRAY.SP_NEXT,AX
		ENDM

NEXT_INDEXI	MACRO
		;;THIS MACRO ASSUMES RANDOM INDEX SIZE
		LOCAL	LOC1

		XOR	EAX,EAX
		MOV	AL,[ESI]
		INC	ESI
		TEST	AL,AL
		JNS	LOC1
		MOV	AH,AL
		MOV	AL,[ESI]
		INC	ESI
		AND	AH,7FH
LOC1:
		ENDM

NEXT_INDEX	MACRO	ZZ
		XOR	EAX,EAX

		MOV	AL,[ESI]
		INC	ESI

		TEST	AL,AL
		JS	ZZ
ZZ&_RET:
		ENDM

DOLONG		MACRO	ZZ
ZZ:
		MOV	AH,AL
		MOV	AL,[ESI]

		INC	ESI
		AND	AH,7FH

		JMP	ZZ&_RET
		ENDM

CONVERT_MYCOMDAT_EAX_ECX	MACRO
		EXTERNDEF	MYCOMDAT_SEARCH:PROC
		CALL	MYCOMDAT_SEARCH
		ENDM


CONVERT		MACRO	XX,YY,ZZ
		IFIDNI	<ZZ>,<CV_LTYPE_GARRAY>
		CONVERT_TYPE	XX,YY,ZZ

		ELSEIFIDNI	<ZZ>,<CV_GTYPE_GARRAY>
		CONVERT_TYPE	XX,YY,ZZ

		ELSE

		MOVV	XX,YY

		ENDIF

		ENDM


CONVERT_TYPE	MACRO	XX,YY,ZZ

		IFIDNI	<XX>,<YY>
		.ERR
		ENDIF

		PUSH	YY
		DEC	YY

		MOV	XX,YY

		SHR	XX,PAGE_BITS-2
		AND	YY,PAGE_MASK SHR 2

		MOV	XX,ZZ[XX*4]._STD_PTRS

		MOV	XX,DPTR [XX+YY*4]
		POP	YY

		ENDM


MOVV		MACRO	XX,YY
		IFIDN	<XX>,<YY>
		ELSE
		MOV	XX,YY
		ENDIF
		ENDM


;CONVERT_GINDEX_AX_DSSI	MACRO	XX
;
;		PUSH	ECX
;		MOV	ECX,EAX
;		PUSH	EAX
;		SHR	EAX,14
;		AND	ECX,16K-1
;		MOV	ESI,XX[EAX*4]._STD_PTRS
;		POP	EAX
;		MOV	ESI,DPTR [ESI+ECX*4]
;		POP	ECX
;
;		ENDM
;
;CONVERT_GINDEX_EAX_EBX	MACRO	XX
;
;		PUSH	ECX
;		MOV	ECX,EAX
;		PUSH	EAX
;		SHR	EAX,14
;		AND	ECX,16K-1
;		MOV	EBX,XX[EAX*4]._STD_PTRS
;		POP	EAX
;		MOV	EBX,DPTR [EBX+ECX*4]
;		POP	ECX
;
;		ENDM


;CONVERT_GINDEX_EAX_ECX	MACRO	XX
;
;		PUSH	EBX
;		MOV	EBX,EAX
;		PUSH	EAX
;		SHR	EAX,14
;		AND	EBX,16K-1
;		MOV	ECX,XX[EAX*4]._STD_PTRS
;		POP	EAX
;		MOV	ECX,DPTR [ECX+EBX*4]
;		POP	EBX
;
;		ENDM
;
;CONVERT_GINDEX_EAX_EAX	MACRO	XX
;
;		PUSH	ECX
;		MOV	ECX,EAX
;		SHR	EAX,14
;		AND	ECX,16K-1
;		MOV	EAX,XX[EAX*4]._STD_PTRS
;		MOV	EAX,DPTR [EAX+ECX*4]
;		POP	ECX
;
;		ENDM

;TCONVERT_GINDEX_AX_DSSI	MACRO	XX
;		CAPTURE	TCONVERT_SEM
;		MOV	ESI,OFF XX
;		CALL	XX._STD_AX_TO_DSSI_THREAD
;		RELEASE	TCONVERT_SEM
;		ENDM

;TSCONVERT_GINDEX_AX_DSSI	MACRO	XX
;		MOV	ESI,OFF XX
;		CALL	XX._STD_AX_TO_DSSI_THREAD
;		ENDM

;CONVERT_GINDEX_AX_ESDI	MACRO	XX
;
;		PUSH	ECX
;		MOV	ECX,EAX
;		PUSH	EAX
;		SHR	EAX,14
;		AND	ECX,16K-1
;		MOV	EDI,XX[EAX*4]._STD_PTRS
;		POP	EAX
;		MOV	EDI,DPTR [EDI+ECX*4]
;		POP	ECX
;
;		ENDM


CONVERT_LINDEX_EAX_EAX	MACRO	ARRAY_ID,REG

		EXTERNDEF	INDEX_RANGE:PROC

		DEC	EAX
		MOV	REG,ARRAY_ID._LARRAY_LIMIT

		CMP	REG,EAX
		JBE	INDEX_RANGE

		MOV	REG,EAX

		SHR	EAX,12
		AND	REG,4K-1

		MOV	EAX,ARRAY_ID[EAX*4]._LARRAY_BASES

		MOV	EAX,DPTR [EAX+REG*4]
		ENDM


P1ONLY_POOL_ALLOC	MACRO	XX		;;USED ONLY ON PASS1, THEN CAN BE DELETED
		EXTERNDEF	P1ONLY_POOL_GET:PROC
		CALL	P1ONLY_POOL_GET
		ENDM

SECTION_POOL_ALLOC	MACRO	XX
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	SECTION_POOL_GET:PROC
		CALL	SECTION_POOL_GET

		ENDM

TILLP2_POOL_ALLOC	MACRO	XX		;;PROBABLY NOT NEEDED AGAIN TILL PASS2
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	TILLP2_POOL_GET:PROC
		CALL	TILLP2_POOL_GET

		ENDM

TILLMIDDLE_POOL_ALLOC	MACRO	XX		;;PROBABLY NOT NEEDED AGAIN TILL MIDDLE
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	TILLMIDDLE_POOL_GET:PROC
		CALL	TILLMIDDLE_POOL_GET

		ENDM

CLASS_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	CLASS_POOL_GET:PROC
		CALL	CLASS_POOL_GET

		ENDM

SEGMENT_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	SEGMENT_POOL_GET:PROC
		CALL	SEGMENT_POOL_GET

		ENDM

SEGMOD_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	SEGMOD_POOL_GET:PROC
		CALL	SEGMOD_POOL_GET

		ENDM

MODULE_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	MODULE_POOL_GET:PROC
		CALL	MODULE_POOL_GET

		ENDM

GROUP_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	GROUP_POOL_GET:PROC
		CALL	GROUP_POOL_GET

		ENDM

SSYM_POOL_ALLOC MACRO	XX
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	SSYM_POOL_GET:PROC
		CALL	SSYM_POOL_GET

		ENDM

TEXT_POOL_ALLOC MACRO	XX			;USED FOR LNAME TEXT,
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	TEXT_POOL_GET:PROC
		CALL	TEXT_POOL_GET
		ENDM

LTEXT_POOL_ALLOC MACRO	XX			;USED FOR LOCAL LNAME TEXT,
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
		EXTERNDEF	LTEXT_POOL_GET:PROC
		CALL	LTEXT_POOL_GET
		ENDM

TEXT_POOL_ALLOC_FIX	MACRO	XX
		ENDM

SYM_POOL_ALLOC_FIX	MACRO	XX
		ENDM

SSYM_POOL_ALLOC_FIX	 MACRO	 XX
		ENDM

HASHDIV		MACRO	XX

		DIV	XX

;;		MOV	EDX,EAX
;;
;;		SHR	EAX,16
;;
;;		XOR	EAX,EDX
;;		MOV	EDX,XX
;;
;;		XOR	AL,AH
;;		DEC	EDX
;;
;;		AND	EDX,EAX
;;
;;		DIV	WPTR XX

		ENDM

OPTIMOVE	MACRO
		LOCAL	L1,L2

		CMP	ECX,8
		JB	L1
		PUSH	ECX
		SHR	ECX,2
		REP	MOVSD
		POP	ECX
		AND	ECX,3
		JZ	L2
L1:
		REP	MOVSB
L2:
		ENDM

OPTI_MOVSB	EQU	OPTIMOVE

;OPTI_MOVSW_386	MACRO			;;WORD MOVE LARGE ENOUGH TO GET ADVANTAGE FROM 386
;		REP	MOVSW		;;SO WHAT FOR NOW
;		ENDM

;OPTI_MOVSW	MACRO
;		LOCAL	L1
;		SHR	ECX,1
;		REP	MOVSD		;;USE SHR CX,1 REP MOVSD ON 386
;		JNC	L1
;		MOVSW
;L1:
;		ENDM

OPTI_MOVSD	MACRO
		REP	MOVSD
		ENDM

OPTI_STOSD	MACRO
;		LOCAL	L1,L2
;		CMP	ECX,8
;		JB	L1
;
;		PUSH	ESI
;		MOV	[EDI],EAX
;
;		MOV	ESI,EDI
;		ADD	EDI,4
;
;		DEC	ECX
;
;		REP	MOVSD
;
;		POP	ESI
;		JMP	L2
;
;L1:
		REP	STOSD
;L2:
		ENDM


;OPTI_STOSW	MACRO
;		LOCAL	L1
;		SHR	ECX,1
;		REP	STOSD
;		JNC	L1
;		STOSW
;L1:
;		ENDM

OPTI_STOSB	MACRO
		LOCAL	L1,L2

		CMP	ECX,8
		JB	L1
		PUSH	ECX
		SHR	ECX,2
		REP	STOSD
		POP	ECX
		AND	ECX,3
		JZ	L2
L1:
		REP	STOSB
L2:
		ENDM

SKIP_INDEX	MACRO

		MOV	AL,[ESI]
		INC	ESI
		ROL	AL,1
		SBB	EAX,EAX
		SUB	ESI,EAX
		ENDM

SETT	MACRO	XX,YY
;;	OR	BPTR (XX/8)-80H[BP],1 SHL (XX MOD 8)
	EXTERNDEF	XX:BYTE
	IFB	<YY>
	MOV	XX,-1
	ELSE
	MOV	XX,YY
	ENDIF
	ENDM

GETT	MACRO	XX,YY
	EXTERNDEF	YY:BYTE
	MOV	XX,YY
	ENDM

BITT	MACRO	XX,YY
	EXTERNDEF	XX:BYTE
	IFB	<YY>
	TEST	XX,-1
	ELSE
	CMP	XX,YY
	ENDIF
	ENDM

RESS	MACRO	XX,YY
;;	AND	BPTR (XX/8)-80H[BP],NOT (1 SHL (XX MOD 8))
	EXTERNDEF	XX:BYTE
	IFB	<YY>
	MOV	XX,0
	ELSE
	MOV	XX,YY
	ENDIF
	ENDM

;BITT2	MACRO	XX
;	TEST	BPTR (XX/8)[STACK_VARIABLES],1 SHL (XX MOD 8)
;	ENDM

	if	fg_virt

LOCKIT		MACRO
		EXTERNDEF	LOCK_BLOCK:PROC
		CALL	LOCK_BLOCK
		ENDM

UNLOCKIT		MACRO
		EXTERNDEF	UNLOCK_BLOCK:PROC
		CALL	UNLOCK_BLOCK
		ENDM

MCONVERT_BX_TO_DX	MACRO
		EXTERNDEF	CONVERT_BX_TO_DX:PROC
		CALL	CONVERT_BX_TO_DX
		ENDM

CONV_ES 	MACRO
		EXTERNDEF	CONVERT_ES_TO_ES:PROC
		CALL	CONVERT_ES_TO_ES
		ENDM

CONV_ES_AX		MACRO
		EXTERNDEF	CONVERT_ES_TO_ES:PROC
		PUSH	AX
		CALL	CONVERT_ES_TO_ES
		POP	AX
		ENDM

CONV_DS 	MACRO

		EXTERNDEF	CONVERT_DS_TO_DS:PROC
		CALL	CONVERT_DS_TO_DS

		ENDM

VIRT_?		EQU

	else

LOCKIT		MACRO
		ENDM
UNLOCKIT	MACRO
		ENDM
MCONVERT_BX_TO_DX	MACRO
		MOV	DX,BX
		ENDM
CONV_ES 	MACRO
		ENDM
CONV_ES_AX	MACRO
		ENDM
CONV_DS 	MACRO
		ENDM

VIRT_?		EQU	<;>

	endif

if	fg_sym_virt

SYM_ALIGN	EQU	<ALIGN	4,,1>

SYM_?		EQU			;ALLOW THIS INSTRUCTION

NOT_SYM_?	EQU	<;>

SYM_CONV_DS	MACRO

		EXTERNDEF	CONVERT_DS_TO_DS:PROC
		CALL	CONVERT_DS_TO_DS

		ENDM

SYM_LOCKIT	MACRO
		EXTERNDEF	SYM_LOCK_BLOCK:PROC
		CALL	SYM_LOCK_BLOCK
		ENDM

SYM_UNLOCKIT	MACRO
		EXTERNDEF	SYM_UNLOCK_BLOCK:PROC
		CALL	SYM_UNLOCK_BLOCK
		ENDM

SYM_CONV_ES	MACRO

		EXTERNDEF	CONVERT_ES_TO_ES:PROC
		CALL	CONVERT_ES_TO_ES

		ENDM

SYM_CONV_DS_AX	MACRO

		EXTERNDEF	CONVERT_DS_TO_DS:PROC
		PUSH	AX
		CALL	CONVERT_DS_TO_DS
		POP	AX

		ENDM

SYM_CONV_ES_AX	MACRO

		EXTERNDEF	CONVERT_ES_TO_ES:PROC
		PUSH	AX
		CALL	CONVERT_ES_TO_ES
		POP	AX

		ENDM

else

SYM_ALIGN	EQU	<ALIGN	4>

SYM_?		EQU	<;>

NOT_SYM_?	EQU

SYM_CONV_DS	EQU	<;>

SYM_CONV_ES	EQU	<;>

SYM_LOCKIT	EQU	<;>
SYM_UNLOCKIT	EQU	<;>

SYM_CONV_DS_AX	EQU	<;>

SYM_CONV_ES_AX	EQU	<;>

endif

if fgh_prot

PUSHI		MACRO	XX,Y,Z,A,B,C,D,E,F,G
		PUSH	Y Z A B C D E F G
		ENDM

ROLI		MACRO	XX,Y,Z,A,B,C,D
		ROL	XX,Y Z A B C D
		ENDM

RORI		MACRO	XX,Y,Z,A,B,C,D
		ROR	XX,Y Z A B C D
		ENDM

SHRI		MACRO	XX,Y,Z,A,B,C,D
		SHR	XX,Y Z A B C D
		ENDM

SHLI		MACRO	XX,Y,Z,A,B,C,D
		SHL	XX,Y Z A B C D
		ENDM

RCRI		MACRO	XX,Y,Z,A,B,C,D
		RCR	XX,Y,Z,A,B,C,D
		ENDM

else

PUSHI		MACRO	XX,Y,Z,A,B,C,D,E,F,G
		MOV	XX,Y Z A B C D E F G
		PUSH	XX
		ENDM

ROLI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		ROL	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		ROL	XX,1
		ENDM
		ENDIF
		ENDM

RORI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		ROR	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		ROR	XX,1
		ENDM
		ENDIF
		ENDM

SHRI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		SHR	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		SHR	XX,1
		ENDM
		ENDIF
		ENDM

SHLI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		SHL	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		ADD	XX,XX
		ENDM
		ENDIF
		ENDM

RCRI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		RCR	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		RCR	XX,1
		ENDM
		ENDIF
		ENDM

endif

if	fgh_anythreads

CAPTURE		MACRO	XX		;CAPTURE THIS SEMAPHORE

		PUSH	EAX

		push	ECX
		push	EDX
		push	OFF XX
		CALL	_capture_eax
		add	ESP,4
		pop	EDX
		pop	ECX

		;MOV	EAX,OFF XX
		;CALL	CAPTURE_EAX

		POP	EAX

		ENDM

RELEASE		MACRO	XX		;RELEASE THIS SEMAPHORE

		PUSH	EAX

		push	ECX
		push	EDX
		push	OFF XX
		call	_release_eax
		add	ESP,4
		pop	EDX
		pop	ECX

		;MOV	EAX,OFF XX
		;CALL	RELEASE_EAX

		POP	EAX

		ENDM

RELEASE_BUMP	MACRO	XX		;RELEASE THIS SEMAPHORE

		PUSH	EAX

		push	ECX
		push	EDX
		push	OFF XX
		call	_release_eax_bump
		add	ESP,4
		pop	EDX
		pop	ECX

		;MOV	EAX,OFF XX
		;CALL	RELEASE_EAX_BUMP

		POP	EAX

		ENDM

else

CAPTURE		MACRO	XX
		ENDM

RELEASE		MACRO	XX
		ENDM

RELEASE_BUMP	MACRO	XX
		ENDM

endif

INT21		MACRO
if	fgh_dpmi
		EXTERNDEF	INT21_ROUTINE:PROC
		CALL	INT21_ROUTINE
elseif fgh_win
		CALL	DOS3CALL
elseif	fgh_dosx
		INT	21H
		CLD
else
		INT	21H
		CLD
endif
		ENDM

INT31		MACRO
if	fgh_dpmi
if	debug
		EXTERNDEF	INT31_ROUTINE:PROC
		CALL	INT31_ROUTINE
else
		INT	31H
		CLD
endif
else
		.ERR
endif
		ENDM

DOS		MACRO
		EXTERNDEF	DOS_ROUTINE:PROC
		CALL	DOS_ROUTINE
		ENDM

if	fgh_win32dll

YIELD		MACRO

		EXTERNDEF	REPORT_PROGRESS:PROC
		CALL	REPORT_PROGRESS

		ENDM

SUSPEND_CANCEL	MACRO
		ENDM

RESUME_CANCEL	MACRO
		ENDM
else

YIELD		MACRO
		ENDM

SUSPEND_CANCEL	MACRO
		ENDM

RESUME_CANCEL	MACRO
		ENDM
endif

DO_FILE_ALIGN_EAX	MACRO

		ADD	EAX,SEG_PAGE_SIZE_M1

		AND	EAX,NOT_SEG_PAGE_SIZE_M1

		ENDM


CONVERT_GINDEX_BXAX_DSSI	MACRO	XX
		EXTERNDEF	STD32_BXAX_TO_DSSI:PROC
		LEA	SI,XX
		CALL	STD32_BXAX_TO_DSSI
		ENDM

CONVERT_GINDEX_BXAX_ESDI	MACRO	XX
		EXTERNDEF	STD32_BXAX_TO_ESDI:PROC
		LEA	DI,XX
		CALL	STD32_BXAX_TO_ESDI
		ENDM

INSTALL_POINTER_GINDEX32	MACRO	XX
		EXTERNDEF	STD32_INSTALL_PTR_ROUTINE:PROC
		PUSH	SI
		LEA	SI,XX
		CALL	STD32_INSTALL_PTR_ROUTINE
		POP	SI
		ENDM

STD32_PTR_S		STRUC		;USED BY TDBG_NAMES,

_STD32_BASE 		DD	?	;PTR TO MASTER BLOCK OF POINTERS
_STD32_NEXT 		DD	?	;NEXT PLACE TO STORE PTR
_STD32_LIMIT		DD	?	;# OF VALID ENTRIES IN TABLE
_STD32_BASES		DD	?	;PLACE TO STORE NEXT BASE PTR
_STD32_ALLOCATE		DCA	?	;ALLOCATE MEMORY FOR THIS DATA TYPE
_STD32_COUNT		DW	?	;# LEFT TO ALLOCATE THIS BLOCK
_STD32_STUFF_PTR	DW	?	;

STD32_PTR_S		ENDS

TO_UPPER		MACRO
			LOCAL	L1
		CMP	AL,'a'
		JC	L1
		CMP	AL,'z'+1
		JNC	L1
		SUB	AL,20H
L1:
		ENDM

OPTION	NOKEYWORD:<PUSHF POPF PUSHA POPA>		;USE PUSHFD AND POPFD



.LIST

