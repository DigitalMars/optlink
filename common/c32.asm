		TITLE	SLR-COMPRESSOR Copyright (c) SLR Systems, Inc 1994

		INCLUDE MACROS
		INCLUDE SLR32
		INCLUDE	SEGMSYMS
if	fg_winpack
		INCLUDE	SEGMENTS
endif

		PUBLIC	COMPRESS


		.DATA

		EXTERNDEF	HUF_MINI_BUFFER:BYTE

		EXTERNDEF	SLR_PREV_SEG:DWORD,DONT_PACK:DWORD,PUTSTUFF_SMALL:DWORD,PUTSTUFF:DWORD,SLR_FLUSHSTUFF:DWORD
		EXTERNDEF	FIX_BUFFERS:DWORD,COMPRESS_TABLE:DWORD,SLR_NEXT_SEG:DWORD,OLD_MATCHED_COUNT:DWORD,OLD_OFFSET:DWORD
		EXTERNDEF	NEXT_AVAIL:DWORD,NEXT_AVAIL_2:DWORD,SLR_CPOS:DWORD,SLR_VARS:DWORD,SLR_DATA:DWORD
		EXTERNDEF	SLR_INBUF_LIMIT:DWORD,SLR_WORD:DWORD,SLR_SCAN_LIMIT:DWORD,DEL_INST_COUNT:DWORD,SLR_DICT_COUNT:DWORD
		EXTERNDEF	SLR_DICT2_COUNT:DWORD,PUTBYTE_ADDR1:DWORD,PUTBYTE_ADDR2:DWORD,PUTBYTE_TEMP:DWORD,SLR_MASK:DWORD
		EXTERNDEF	LAST_SEG_OS2_NUMBER:DWORD,SEED_SIZE:DWORD,SLRBUF_PTR:DWORD,NEW_REPT_ADDR:DWORD,SLR_BYTES_LEFT:DWORD
		EXTERNDEF	SLR_TMP_PTR:DWORD,SLR_INPUT_PTR_OFFSET:DWORD,HUF_PUT_PTR:DWORD,SLR_HASHES_BASE:DWORD
		EXTERNDEF	SLR_DICTIONARY_BASE:DWORD,SLR_STRUCT_BASE:DWORD,SLR_INPUT_PTR_BASE:DWORD,HASH_TABLE2_OFFSET:DWORD

		EXTERNDEF	EXEPACK_STRUCTURE:SEQ_STRUCT,SLR2_TABLE:SLR2_STRUCT,SEGMENT_TABLE:SEGTBL_STRUCT

		EXTERNDEF	COMPRESS_TABLE_LENGTH:ABS


HASH_DX 	MACRO

		MOV	EBX,EDX
		MOV	AL,[ESI+2]

		SHL	EBX,5
		XOR	AL,DH

		XOR	BL,AL

		AND	EBX,HTW_SIZE-1

		ENDM


		.CODE	PASS2_TEXT

		EXTERNDEF	PUTSTUFF_SMALL_QUIK32:PROC,PUTSTUFF_SLR32:PROC,FLUSHSTUFF_SLR32:PROC,FIX_BUFFERS_SLR32:PROC
		EXTERNDEF	PUTSTUFF_QUIK32:PROC,FLUSHSTUFF_QUIK32:PROC,FIX_BUFFERS_QUIK32:PROC,PUTSTUFF_SMALL_SLR32:PROC
		EXTERNDEF	_get_large_segment:proc,CONVERT_SUBBX_TO_EAX:PROC,LOUTALL_CON:PROC,_oom_error:proc
		EXTERNDEF	RELEASE_BLOCK:PROC,MOVE_EAX_TO_FINAL_HIGH_WATER:PROC,_release_large_segment:proc,SLR_MOVER:PROC


QUIK_TABLE	DD	PUTSTUFF_SMALL_QUIK32
		DD	PUTSTUFF_QUIK32
		DD	FLUSHSTUFF_QUIK32
		DD	FIX_BUFFERS_QUIK32

if	fg_hufpack
SLR_TABLE	DD	PUTSTUFF_SMALL_SLR32
		DD	PUTSTUFF_SLR32
		DD	FLUSHSTUFF_SLR32
		DD	FIX_BUFFERS_SLR32
endif

SLR_OOM2:
		;
		;RESIZE DICT_SIZE?
		;
SLR_OOM1:
		XOR	EAX,EAX
if	fg_hufpack
		XCHG	EAX,SLRBUF_BASE

		TEST	EAX,EAX
		JNZ	SLR_OOM3
endif
		XCHG	EAX,SLR_STRUCT_BASE
		MOV	ECX,256K

		TEST	EAX,EAX
		JZ	SLR_OOM
SLR_OOM3:
		;AT LEAST ENOUGH TO ABORT...
		PUSHM	EDX,ECX
		push	EAX
		call	_release_large_segment
		add	ESP,4
		POPM	ECX,EDX
SLR_OOM:
		call	_oom_error
		ret


COMPRESS	PROC
		;
		;GET SET UP FOR DOING A COMPRESS JOB...
		;
		SUSPEND_CANCEL			;DONT ALLOW BREAK TILL THIS SEGMENT IS COMPRESSED

		PUSHM	EDI,ESI,EBX
		XOR	EAX,EAX

		RESS	NO_SLRPACKING_DONE,AL
		RESS	DICT2_FULL,AL

		RESS	DICT_FULL,AL
		RESS	COMP_FIRST_INPUT,AL
		;
		;SET UP JUMP TABLE FOR PROPER COMPRESSION TYPE
		;
		MOV	EDI,OFF COMPRESS_TABLE
		MOV	ECX,COMPRESS_TABLE_LENGTH

		SHR	ECX,2
if	fg_hufpack
		MOV	ESI,OFF SLR_TABLE

		BITT	QUIKPACK_FLAG
		JZ	L00$
endif
		MOV	ESI,OFF QUIK_TABLE
L00$:
		REP	MOVSD
		;
		;ALLOCATE CONTIGUOUS MEMORY CHUNKS
		;
if	fg_hufpack
		BITT	QUIKPACK_FLAG
		JNZ	L01$

		MOV	EAX,64K

		;GET SELECTOR FOR SLR_BUFFER - ONLY FOR SLRPACK
		pushm	EDX,ECX
		push	EAX
		call	_get_large_segment
		add	ESP,4
		popm	ECX,EDX

		JC	SLR_OOM

		MOV	SLRBUF_PTR,EAX
		MOV	SLRBUF_BASE,EAX

endif

L01$:
		MOV	EAX,256K		;FOR SLR_STRUCT

		;GET SELECTOR IN AX TO LOCKED SEG
		push	EDX
		push	ECX
		push	EAX
		call	_get_large_segment
		add	ESP,4
		pop	ECX
		pop	EDX

		MOV	SLR_STRUCT_BASE,EAX
		JC	SLR_OOM2

		MOV	EAX,128K
		;INPUT BUFFER
		push	EDX
		push	ECX
		push	EAX
		call	_get_large_segment
		add	ESP,4
		pop	ECX
		pop	EDX

		MOV	SLR_DICTIONARY_BASE,EAX
		JC	SLR_OOM2

		ADD	EAX,64K

		MOV	SLR_HASHES_BASE,EAX
		MOV	EDI,EAX

		MOV	EAX,-1
		MOV	ECX,HTW_SIZE

		REP	STOSD

		MOV	EDI,OFF HASH_TABLE2_OFFSET
		MOV	ECX,HTW2_SIZE

		REP	STOSD

		INC	EAX

		MOV	DEL_INST_COUNT,EAX		;BYTES SINCE PTRS ADJUSTED
		MOV	SLR_WORD,EAX			;# OF BITS IN OUTPUT SO FAR, HIGH = OUTPUT SO FAR
if	fg_hufpack
		MOV	SLRBUF_PTR.OFFS,AX		;TO STORE NEXT TOKEN
endif
		MOV	NEXT_AVAIL,-SIZE SLR_STRUCT

		MOV	NEXT_AVAIL_2,OFF SLR2_TABLE-SIZE SLR2_STRUCT

		MOV	SLR_MASK,8000H			;DO WORD AT A TIME

		MOV	EDI,OFF HUF_MINI_BUFFER

		MOV	SLR_CPOS,EDI

		STOSW

		MOV	SLR_TMP_PTR,EDI

if	fg_hufpack
		BITT	QUIKPACK_FLAG
		JNZ	02$
		;
		;ZERO VARIABLES
		;
		MOV	DI,HUF_FREQ_CHAR
		MOV	CX,CHARSET_SIZE*3
		XOR	AX,AX
		REP	STOSW
		MOV	CX,(1 SHL POS_BITS)*3
		MOV	DI,HUF_FREQ_POS
		REP	STOSW
endif

L02$:
		;
		;COPY UNPACKED BYTES
		;
		MOV	EBX,OFF EXEPACK_STRUCTURE._SEQ_TABLE
		XOR	ESI,ESI
		;
		;USE SMALLER OF NEW_REPT_ADDR AND DONT_PACK
		;
		MOV	ECX,DONT_PACK

		TEST	ECX,ECX
		JZ	L03$

		ADD	ECX,0FH			;ROUND TO A PARAGRAPH SIZE

		AND	CL,0F0H

		CMP	NEW_REPT_ADDR,ECX
		JA	L021$

		MOV	ECX,NEW_REPT_ADDR
		;
		;ECX IS NUMBER OF BYTES TO WRITE
		;
L021$:
		SUB	NEW_REPT_ADDR,ECX
L022$:
		MOV	EAX,[EBX]
		;
		;IF CX > PAGE_SIZE, WRITE PAGE_SIZE
		;
		PUSH	ECX
		ADD	EAX,ESI

		CMP	ECX,PAGE_SIZE
		JB	L023$

		MOV	ECX,PAGE_SIZE
L023$:
		PUSHM	ECX
		CALL	MOVE_EAX_TO_FINAL_HIGH_WATER

		POPM	EAX,ECX

		ADD	ESI,EAX
		XOR	EDX,EDX

		CMP	ESI,PAGE_SIZE
		JNZ	L03$

		PUSH	EAX
		MOV	EAX,[EBX]

		MOV	[EBX],EDX
		CALL	RELEASE_BLOCK

		POP	EAX
		XOR	ESI,ESI

		ADD	EBX,4
		SUB	ECX,EAX

		JNZ	L022$
L03$:
		MOV	SLR_INPUT_PTR_OFFSET,ESI
		MOV	SLR_INPUT_PTR_BASE,EBX

		MOV	ESI,SLR_DICTIONARY_BASE
		MOV	EAX,NEW_REPT_ADDR

		MOV	SLR_INBUF_LIMIT,ESI
		MOV	SLR_BYTES_LEFT,EAX

		MOV	SLR_DICT_COUNT,DICT_SIZE

		MOV	SLR_DICT2_COUNT,256

;		MOV	EAX,OFF HUF_PUT_BUF

;		MOV	PUTBYTE_ADDR1,EAX
;		INC	EAX

;		MOV	PUTBYTE_ADDR2,EAX
;		INC	EAX

;		MOV	HUF_PUT_PTR,EAX
		MOV	EAX,SLR_BYTES_LEFT

		TEST	EAX,EAX
		JZ	L09$

		XOR	ESI,ESI
		CALL	QFIX_INPUT	;READ INPUT DATA
		;
		;DS IS SLR_DATA
		;ES IS SLR_VARS
		;
		MOV	OLD_MATCHED_COUNT,-1	;MARK NOTHING FOUND

		MOV	ECX,SEED_SIZE

		TEST	ECX,ECX
		JZ	L05$
L04$:
		CALL	DEL_INST

		INC	ESI
		MOV	EAX,SLR_INBUF_LIMIT

		CMP	EAX,ESI
		JZ	L06$
L045$:
		DEC	SEED_SIZE
		JNZ	L04$
L05$:
		JMP	L1$

L06$:
		CALL	QFIX_INPUT

		JNZ	L045$

		JMP	QUIKPACK_DONE

L09$:
		SETT	NO_SLRPACKING_DONE
		JMP	SLRPACK_DONE_5

L102$:
		SUB	DEL_INST_COUNT,16K
		CALL	FIX_BUFFERS

		JMP	L1029$

if	support2
		ASSUME	EBX:PTR SLR2_STRUCT
L10$:
		MOV	EBX,[EBX].SLR2_NEXT
		AND	EDX,0FFFFH

		CMP	EBX,-1
		JZ	L119$
L11$:
		CMP	[EBX].SLR2_VALUE,EDX
		JNZ	L10$
L12$:
		;
		;FOUND 2-BYTE MATCH!
		;
		;
		;MAKE SURE NOT BEYOND SCAN_LIMIT
		;
		LEA	EAX,[ESI+2]
		MOV	ECX,SLR_SCAN_LIMIT

		CMP	ECX,EAX
		JC	JUST_DEL_INST

		SUB	EBX,OFF SLR2_TABLE
		ASSUME	EBX:NOTHING

		SHR	EBX,4
		LEA	EAX,[ESI-1]

		SUB	EAX,EBX
		MOV	ECX,MAX_MATCH-2

		AND	EAX,0FFH
		MOV	OLD_MATCHED_COUNT,ECX

		INC	EAX

		MOV	OLD_OFFSET,EAX

		HASH_DX
		MOV	EAX,SLR_HASHES_BASE
		;
		;SEE IF A MATCH EXISTS
		;
		MOV	EBX,[EAX+EBX*4]		;-1 MEANS EMPTY
		XOR	ECX,ECX

		INC	EBX
		JNZ	L62$

ENDIF

JUST_DEL_INST:
		MOV	EAX,OLD_MATCHED_COUNT

		INC	EAX
		JZ	L6$

		JMP	L7$

L1$:
		CMP	DEL_INST_COUNT,16K
		JA	L102$
L1029$:
		;
		;ESI POINTS TO DATA
		;
		MOV	BL,[ESI] 	;HASH ON THRESHOLD BYTES

		MOV	BH,[ESI+1]

		MOV	EDX,EBX
		;
		;FIRST CHECK FOR 2-BYTE MATCH
		;
if	support2
		XOR	BL,BH

		AND	EBX,HTW2_SIZE-1
		AND	EDX,0FFFFH

		MOV	EBX,HASH_TABLE2_OFFSET[EBX*4]		;-1 MEANS EMPTY

		CMP	EBX,-1
		JNZ	L11$		;YES, POSSIBLE 2-BYTE MATCH
endif
L119$:
		HASH_DX
		MOV	EAX,SLR_HASHES_BASE
		;
		;SEE IF A MATCH EXISTS
		;
		MOV	EBX,DPTR [EAX+EBX*4]		;-1 MEANS EMPTY
		XOR	ECX,ECX

		INC	EBX
		JNZ	L62$
L6$:
		;
		;NO MATCH, JUST STICK THIS GUY IN TABLE PLEASE
		;
		;DS = SLR_DATA, ES = SLR_VARS
		;
		CALL	DEL_INST
		;
		;GENERATE BYTE, UPDATE PTRS ETC
		;
		MOV	AL,[ESI]		;GET BYTE
		CALL	PUTSTUFF_SMALL		;0-255

		INC	ESI
		MOV	EAX,SLR_INBUF_LIMIT

		CMP	EAX,ESI			;TIME TO FILL INBUF?
		JNZ	L1$

		CALL	QFIX_INPUT		;GO FIX INBUF...

		JNZ	L1$

		JMP	QUIKPACK_DONE

		ASSUME	EBX:PTR SLR_STRUCT
L2$:
 		MOV	EBX,[EBX].SLR_NEXT-1

		INC	EBX
		JZ	JUST_DEL_INST
L62$:
		MOV	EDI,EBX
		MOV	EAX,SLR_STRUCT_BASE

		SUB	EDI,EAX
		MOV	EAX,SLR_DICTIONARY_BASE

		SHR	EDI,3
		ADD	EAX,DICT_SIZE

		ADD	EDI,EAX

		CMP	ESI,EDI
		JA	L21$

		SUB	EDI,DICT_SIZE
L21$:
		CMP	[EDI+ECX],DX
		JNZ	L2$

		PUSHM	ESI,ECX

		MOV	ECX,MAX_MATCH		;-NTHRESHOLD ;MAX WE CAN MATCH...
		MOV	EBP,SLR_SCAN_LIMIT

		REPE	CMPSB

		MOV	EAX,ESI
		JE	L35$

		INC	ECX
L35$:
		CMP	EBP,ESI
		JAE	L351$

		SUB	EAX,EBP

		SUB	ESI,EAX
		SUB	EDI,EAX

		ADD	ECX,EAX
L351$:
		CMP	OLD_MATCHED_COUNT,ECX
		JBE	L4$			;OLD BETTER OR SAME

		CMP	ECX,MAX_MATCH-3
		JA	L4$

		SUB	ESI,EDI

		CMP	ESI,16K
		JBE	L36$

		CMP	ECX,MAX_MATCH-3		;IF >16K, SKIP 4-BYTE MATCH
		JZ	L39$
L36$:
		MOV	OLD_OFFSET,ESI
		MOV	OLD_MATCHED_COUNT,ECX

		TEST	ECX,ECX
		JZ	L5$			;MAX, JUMP
L39$:
		ADD	ESI,EDI

		CMP	EBP,ESI			;SLR_SCAN_LIMIT
		JBE	L5$
		;
		;OK, NEW OFFSET AND DX DATA NEEDED
		;
		POPM	ECX,EAX			;OLD OFFSET, OLD ESI

		MOV	DL,[ESI-2] 		;
		LEA	ECX,[ESI-2]

		MOV	DH,[ESI-1]
		SUB	ECX,EAX

		MOV	ESI,EAX
		JMP	L2$

L4$:
		POPM	ECX,ESI

		JMP	L2$

L5$:
		;
		;	MAX MATCH, DON'T LOOK ANY FURTHER...
		;
		POPM	ECX,ESI

		JMP	JUST_DEL_INST

		ASSUME	EBX:NOTHING

L7$:
		;
		;FOUND A MATCH... GENERATE IT PLEASE
		;
		MOV	EBX,OLD_OFFSET
		SUB	EAX,MAX_MATCH-THRESHOLD+1+256

		DEC	EBX
		;
		;AX = -(AX-1) + 256 -3
		;AX = - (AX -1 -256+3)
		;

		NEG	EAX

		CALL	PUTSTUFF		;STORE THIS
		;
		;NOW, DO DEL_INST SEVERAL TIMES...
		;
		MOV	ECX,MAX_MATCH
		MOV	EAX,OLD_MATCHED_COUNT

		SUB	ECX,EAX

		MOV	OLD_MATCHED_COUNT,-1	;MARK NOTHING FOUND
L55$:
		PUSH	ECX
		CALL	DEL_INST

		INC	ESI
		POP	ECX

		CMP	SLR_INBUF_LIMIT,ESI
		JZ	L57$
L58$:
		DEC	ECX
		JNZ	L55$

		JMP	L1$

L57$:
		PUSH	ECX
		CALL	QFIX_INPUT

		POP	ECX
		JNZ	L58$

		JMP	QUIKPACK_DONE

COMPRESS	ENDP


QUIKPACK_DONE	PROC
		;
		;
		;
		CALL	SLR_FLUSHSTUFF
if	fg_winpack
		BITT	OUTPUT_SEGMENTED
		JZ	SLRPACK_DONE_5
		;
		;UPDATE SEGMENT LENGTH AND ITERATED FLAG
		;
		MOV	EAX,LAST_SEG_OS2_NUMBER

		CONV_EAX_SEGTBL_ECX

		MOV	EAX,NEW_REPT_ADDR

		MOV	[ECX]._SEGTBL_PSIZE,EAX

		BITT	KEEPING_COMPRESSED
		JZ	L1$

		OR	[ECX]._SEGTBL_FLAGS,MASK SR_ITERATE
L1$:
endif
		;
		;RELEASE MEMORY SEGMENTS
		;
SLRPACK_DONE_5	LABEL	PROC

		MOV	EAX,DONT_PACK
		XOR	EDX,EDX

		ADD	EAX,0FH
		MOV	ECX,256K

		AND	EAX,0FFFFFFF0H
		MOV	EDI,OFF EXEPACK_STRUCTURE

		ADD	NEW_REPT_ADDR,EAX
		MOV	EAX,SLR_STRUCT_BASE

		MOV	SLR_STRUCT_BASE,EDX

		PUSHM	EDX,ECX
		push	EAX
		call	_release_large_segment
		add	ESP,4
		POPM	ECX,EDX

		XOR	EDX,EDX
		MOV	EAX,SLR_DICTIONARY_BASE

		MOV	SLR_DICTIONARY_BASE,EDX
		MOV	ECX,128K

		PUSHM	EDX,ECX
		push	EAX
		call	_release_large_segment
		add	ESP,4
		POPM	ECX,EDX

		XOR	EAX,EAX
		MOV	ECX,32K/PAGE_SIZE*2+2

		REP	STOSD
if	fg_hufpack
		BITT	QUIKPACK_FLAG
		JNZ	SD_51
		MOV	AX,SLRBUF_PTR.SEGM
		CALL	RELEASE_64K_SEGMENT
SD_51:
endif
		RESUME_CANCEL			;ALLOW CANCEL IF REQUESTED

		POPM	EBX,ESI,EDI

		RET

QUIKPACK_DONE	ENDP


DEL_INST	PROC	NEAR
		;
		;DELETE LAST ITEM FROM HASH TABLE IF FULL
		;
		;
		;UPDATE BOTH TABLES, 2-BYTE AND 3-BYTE
		;
		;DS IS SLR_DATA, ES IS SLR_VARS
		;
		INC	DEL_INST_COUNT
if	support2
		MOV	EDI,NEXT_AVAIL_2
		ASSUME	EDI:PTR SLR2_STRUCT

		ADD	EDI,SIZE SLR2_STRUCT
		GETT	AL,DICT2_FULL

		CMP	EDI,OFF SLR2_TABLE+256*SIZE SLR2_STRUCT
		JAE	L1$
L11$:
		OR	AL,AL
		JZ	L15$

		MOV	EAX,[EDI].SLR2_PREV
		MOV	EBX,-1

		TEST	AL,1
		JZ	L2$			;HAS PREVIOUS

		MOV	HASH_TABLE2_OFFSET[EAX-1],EBX
		JMP	L3$

L1$:
		SUB	EDI,256*SIZE SLR2_STRUCT
		JMP	L11$

L15$:
		DEC	SLR_DICT2_COUNT
		JNZ	L3$

		SETT	DICT2_FULL

		JMP	L3$

		ASSUME	EAX:PTR SLR2_STRUCT
L2$:
		MOV	[EAX].SLR2_NEXT,EBX
L3$:
		ASSUME	EAX:NOTHING
		MOV	NEXT_AVAIL_2,EDI
		;
		;INSTALL THIS ITEM IN HASH TABLE
		;
		MOV	BL,[ESI]

		MOV	BH,[ESI+1]

		MOV	EDX,EBX
		XOR	BL,BH

		AND	EBX,HTW2_SIZE-1
		AND	EDX,0FFFFH
		;
		;INSTALL AT HEAD OF CHAIN
		;
		MOV	[EDI].SLR2_VALUE,EDX

		MOV	EAX,HASH_TABLE2_OFFSET[EBX*4]
		MOV	HASH_TABLE2_OFFSET[EBX*4],EDI

		SHL	EBX,2
		MOV	[EDI].SLR2_NEXT,EAX

		INC	EBX
		INC	EAX			;DOES NEXT EXIST?

		MOV	[EDI].SLR2_PREV,EBX
		JZ	L39$

		ASSUME	EAX:PTR SLR2_STRUCT
		MOV	[EAX-1].SLR2_PREV,EDI

		ASSUME	EAX:NOTHING
L39$:

else
		MOV	DX,[ESI]
endif

		MOV	EDI,NEXT_AVAIL
		ASSUME	EDI:PTR SLR_STRUCT

		ADD	EDI,SIZE SLR_STRUCT
		MOV	EAX,SLR_STRUCT_BASE

		CMP	EDI,DICT_SIZE*8
		JZ	L40$
L41$:
		GETT	CL,DICT_FULL
		MOV	NEXT_AVAIL,EDI

		OR	CL,CL
		JZ	L66$

		MOV	EAX,[EDI+EAX].SLR_PREV
		MOV	ECX,-1

		TEST	AL,1
		JZ	L5$		;DELETE HAS A PREVIOUS

		MOV	[EAX-1],ECX	;HASH TABLE OFFSET
		JMP	L7$

L40$:
		XOR	EDI,EDI
		JMP	L41$

L66$:
		DEC	SLR_DICT_COUNT
		JNZ	L7$

		SETT	DICT_FULL
		JMP	L7$

		ASSUME	EAX:PTR SLR_STRUCT
L5$:
		;
		;THERE IS A PREVIOUS
		;
		MOV	[EAX].SLR_NEXT,ECX
		ASSUME	EAX:NOTHING
L7$:
		;
		;INSTALL THIS ITEM IN HASH TABLE
		;
		HASH_DX
		MOV	ECX,SLR_HASHES_BASE
		;
		;INSTALL THIS AT HEAD OF CHAIN
		;
		SHL	EBX,2
		MOV	EAX,SLR_STRUCT_BASE

		ADD	EDI,EAX

		MOV	EAX,DPTR [EBX+ECX]
		MOV	DPTR [EBX+ECX],EDI

		LEA	EBX,[EBX+ECX+1]
		MOV	[EDI].SLR_NEXT,EAX

		MOV	[EDI].SLR_PREV,EBX
		CMP	EAX,-1		;DOES NEXT EXIST?

		JZ	L79$

		ASSUME	EAX:PTR SLR_STRUCT
		MOV	[EAX].SLR_PREV,EDI
L79$:
		RET

		ASSUME	EAX:NOTHING

DEL_INST	ENDP


QFIX_INPUT	PROC	NEAR
		;
		;SET UP FOR INPUT.  WE ARE READING FROM ALREADY EXEPACK'ED
		;BLOCKS
		;
		PUSHM	EDI,EDX,ECX,EAX

		MOV	EAX,SLR_BYTES_LEFT
		MOV	EDX,SLR_DICTIONARY_BASE

		TEST	EAX,EAX
		JZ	L9$

		SETT	COMP_FIRST_INPUT
		;
		;MOVE FROM SI-DICT_SIZE THRU INBUFSCAN LIMIT DOWN TO ZERO
		;(ASSUMING SI > DICT_SIZE), ADJUST SI
		;
		MOV	EDI,DICT_SIZE
		MOV	ECX,DICT_SIZE_MAX_MATCH

		TEST	ESI,ESI
		JZ	L0$

		SUB	ESI,DICT_SIZE
		MOV	ECX,SLR_SCAN_LIMIT

		SUB	ECX,ESI
		MOV	EDI,SLR_DICTIONARY_BASE

		OPTI_MOVSB

		MOV	EDI,DICT_SIZE_MAX_MATCH
		MOV	ECX,DICT_SIZE
L0$:
		;
		;NOW MOVE DICT_SIZE IF POSSIBLE TO DICTSIZE+MAX_MATCH
		;
		ADD	EDI,EDX
		CALL	SLR_MOVER

		MOV	SLR_SCAN_LIMIT,EDI
		MOV	SLR_INBUF_LIMIT,EDI

		MOV	EAX,SLR_BYTES_LEFT

		TEST	EAX,EAX
		JZ	L5$

		MOV	EAX,DICT_SIZE_MAX_MATCH
		MOV	EDX,SLR_DICTIONARY_BASE

		SUB	EDI,MAX_MATCH
		ADD	EAX,EDX

		CMP	EDI,EAX
		JC	L5$

		MOV	SLR_INBUF_LIMIT,EDI
L5$:
		MOV	ESI,SLR_DICTIONARY_BASE

		OR	AL,-1
		ADD	ESI,DICT_SIZE
L9$:
		POPM	EAX,ECX,EDX,EDI

		RET

QFIX_INPUT	ENDP


;		.DATA?
;
;HUF_MINI_BUFFER		DB	HMB_SIZE DUP(?)
;HUF_PUT_BUF		DB	HPB_SIZE DUP(?)


		END

