		TITLE	FIXUPP2 - Copyright (c) SLR Systems 1994

		INCLUDE MACROS
		INCLUDE	SYMBOLS
		INCLUDE	SEGMENTS
		INCLUDE	GROUPS
		INCLUDE SECTS
		INCLUDE	SEGMSYMS
		INCLUDE	SECTIONS
		INCLUDE	EXES
		INCLUDE	FIXTEMPS
    version(fg_segm)
    {
		INCLUDE RELOCSS
    }
    version(fg_pe)
    {
		INCLUDE	PE_STRUC
    }
		INCLUDE	RELEASE

		.DATA

		EXTERNDEF	TEMP_DATA_RECORD:BYTE,TEMP_FIXUPP_RECORD:BYTE,LOC_SIZE:BYTE,EXETYPE_FLAG:BYTE,FIX2_TTYPE:BYTE
		EXTERNDEF	FIX2_FTYPE:BYTE,FIX2_SEG_TYPE:BYTE,FIX2_SM_FLAGS_2:BYTE,FIX2_LD_TYPE:BYTE,FIX2_FH_TYPE:BYTE

		EXTERNDEF	FIX2_LD_LENGTH:WORD,FIX2_FH_LENGTH:WORD

		EXTERNDEF	EXETABLE:DWORD,HEADER_TABLE:DWORD,VECTOR_SIZE:DWORD,MOVABLE_MASK:DWORD,LOC_10:DWORD
		EXTERNDEF	CURN_OUTFILE_GINDEX:DWORD,FIX2_TT:DWORD,SYMC_START:DWORD,LOC_CALLTBL_PTR:DWORD,SEGMENT_COUNT:DWORD
		EXTERNDEF	LDATA_SEGMOD_GINDEX:DWORD,CURNMOD_GINDEX:DWORD,CURN_SECTION_GINDEX:DWORD,LATEST_PENT_GINDEX:DWORD
		EXTERNDEF	MODEND_OWNER_GINDEX:DWORD,FIX2_LDATA_SEGMENT_GINDEX:DWORD,FIX2_FIXUPP_BLK:DWORD,GROUP_PTRS:DWORD
		EXTERNDEF	FIX2_FIXUPP_BASE:DWORD,FIX2_FIXUPP_EOR:DWORD,FIX2_FF:DWORD,FIX2_OS2_TNUMBER:DWORD
		EXTERNDEF	FIX2_OS2_FNUMBER:DWORD,FIX2_OS2_TFLAGS:DWORD,FIX2_OS2_FFLAGS:DWORD,FIX2_SEG_OS2_NUMBER:DWORD
		EXTERNDEF	FIX2_LDATA_BASE:DWORD,FIX2_FC_LENGTH:DWORD,FIX2_FC_SEGMOD_GINDEX:DWORD,FIRST_RELOC_GINDEX:DWORD
		EXTERNDEF	FIX2_SM_START:DWORD,FIX2_IMP_FLAGS:DWORD,FIX2_IMP_OFFSET:DWORD,FIX2_FH_BLOCK_BASE:DWORD
		EXTERNDEF	FIX2_IMP_MODULE:DWORD,FIX2_TFRAME_SEG:DWORD,FIX2_OFFSET:DWORD,FIX2_LOC:DWORD,FIX2_TINDEX:DWORD
		EXTERNDEF	FIX2_FINDEX:DWORD,FIX2_TARG_TABLE:DWORD,FIX2_FC_BLOCK_BASE:DWORD,ENTRYPOINT_GINDEX:DWORD
		EXTERNDEF	FIX2_LDATA_EOR:DWORD,FIX2_SM_NEXT_SEGMOD_GINDEX:DWORD,FIX2_SEG_GINDEX:DWORD
		EXTERNDEF	FIX2_SEG_OS2_FLAGS:DWORD,FIX2_NEW_SEGMOD_GINDEX:DWORD,FLAG_0C:DWORD,FIX2_RELOC_OFFSET:DWORD
		EXTERNDEF	RELOC_HIGH_WATER:DWORD,RELOC_BITS:DWORD,VECTOR_TABLE_ADDRESS:DWORD,SLR_CODE_HEADER:DWORD
		EXTERNDEF	FIRST_FARCALL:DWORD,END_VECTOR_TABLE:DWORD,WM_START_ADDR:DWORD,MODEND_ADDRESS:DWORD
		EXTERNDEF	SEGMENT_TABLE_PTR:DWORD,FIXUPP_COUNT:DWORD,FIX2_LDATA_PTR:DWORD,FIX2_TOFFSET:DWORD,FIX2_FFRAME:DWORD
		EXTERNDEF	FIX2_TFRAME:DWORD,FIX2_SM_FIRST_DAT:DWORD,FIX2_SM_LAST_DAT:DWORD,FIX2_FH_NEXT_FIXUPP:DWORD
		EXTERNDEF	FIX2_LDATA_LOC:DWORD,FIX2_SEG_FRAME:DWORD,FIX2_LD_NEXT_LDATA:DWORD,FIX2_LD_OFFSET:DWORD
		EXTERNDEF	FIX2_STACK_DELTA:DWORD,PE_BASE:DWORD,FIRST_SECTION_GINDEX:DWORD,FIX2_LD_BLOCK_BASE:DWORD

		EXTERNDEF	START_DEFINED_SEM:QWORD,SECTION_GARRAY:STD_PTR_S,SEGMOD_GARRAY:STD_PTR_S,PENT_GARRAY:STD_PTR_S
		EXTERNDEF	SEGMENT_GARRAY:STD_PTR_S,FIX2_FIXUPP_STUFF:FIXUPP_HEADER_TYPE,PEXEHEADER:PEXE
		EXTERNDEF	FIX2_SEGMENT_STUFF:SEGMENT_STRUCT,SYMBOL_GARRAY:STD_PTR_S,GROUP_GARRAY:STD_PTR_S
		EXTERNDEF	FIX2_SEGMOD_STUFF:SEGMOD_STRUCT,FIX2_LDATA_STUFF:LDATA_HEADER_TYPE,RELOC_GARRAY:STD_PTR_S
		EXTERNDEF	PE_OBJECT_GARRAY:STD_PTR_S,EXEHEADER:EXE,NEXEHEADER:NEXE,SEGMENT_TABLE:SEGTBL_STRUCT

		EXTERNDEF	OUT_SEGMOD_FINISH:DWORD,OUT_NEW_SEGMOD:DWORD,OUT_END_OF_SECTION:DWORD,OUT_END_OF_SEGMENTS:DWORD
		EXTERNDEF	OUT_NEW_SECTION:DWORD,OUT_NEW_SEGMENT:DWORD,OUT_SEGMENT_FINISH:DWORD


		.CODE	PASS2_TEXT

		EXTERNDEF	RELEASE_BLOCK:PROC,ERR_ABORT:PROC,FORREF2:PROC,FIXUPP_ERROR:PROC,ERR_ASCIZ_RET:PROC,ERR_RET:PROC
		EXTERNDEF	CONVERT_SUBBX_TO_EAX:PROC,RELOC_INSTALL:PROC,EXE_OUT_LDATA:PROC,RELEASE_DSBX:PROC,GET_SM_MODULE:PROC
		EXTERNDEF	OBJ_PHASE:PROC,WARN_RET:PROC,TIME_ERROR:PROC,SAY_VERBOSE:PROC,VERIFY_FAIL:PROC,DO_PE_RELOC:PROC
		EXTERNDEF	WARN_ASCIZ_RET:PROC

		EXTERNDEF	DATA_OUTSIDE_SEGMOD_ERR:ABS,UNRECOGNIZED_FIXUPP_FRAME_ERR:ABS,CANT_REACH_ERR:ABS,SHORT_ERR:ABS
		EXTERNDEF	LOC_FRAME_ERR:ABS,LOBYTE_ERR:ABS,UNREC_FIXUPP_ERR:ABS,START_ERR:ABS,START_CANT_REACH_ERR:ABS
		EXTERNDEF	START_IMPORT_ERR:ABS,RELOC_CONFLICT_ERR:ABS,BASE_RELOC_ERR:ABS,REC_TOO_LONG_ERR:ABS,START_ERR:ABS
		EXTERNDEF	NO_START_ERR:ABS,NEAR16_ERR:ABS,NEAR_IMPORT_ERR:ABS,DOING_SEGMOD_ERR:ABS


public FIXUPP2()
{
    FINAL_FIXUPPS = -1;
    FIX2_TARG_TABLE = &FIX2_TARG_TABLE_NORMAL;
    version(fg_pe)
    {
	if (OUTPUT_PE)
	    FIX2_TARG_TABLE = OFF FIX2_TARG_TABLE_PE;
    }

    version(fg_norm_exe OR fg_segm)
    {
	DO_FARCALL_FIXUPPS();
    }

    version(any_overlays)
    {
		RESS	VECTORED_REFERENCE
    }

    version(fg_segm)
    {
	LOC_CALLTBL_PTR = &LOC_CALLTBL_PROT;
	LOC_10 = &LOC_10_PROT;
	if (!OUTPUT_SEGMENTED)
	{
	    LOC_CALLTBL_PTR = &LOC_CALLTBL_REAL;
	    LOC_10 = &LOC_10_REAL;
	}
    }
    else version(fg_pe)
    {
	LOC_CALLTBL_PTR = &LOC_CALLTBL_PE;
	LOC_10 = &LOC_10_PE;
	if (!OUTPUT_PE)
	{
	    LOC_CALLTBL_PTR = &LOC_CALLTBL_REAL;
	    LOC_10 = &LOC_10_REAL;
	}
    }
    else
    {
	LOC_CALLTBL_PTR = &LOC_CALLTBL_REAL;
	LOC_10 = &LOC_10_REAL;
    }

    // STARTING PASS THROUGH DATA, SEGMENT BY SEGMENT

    // HANDLE START ADDRESS IF ANY

    version(fg_rom)
    {
	FIX2_PHASE_ADDR.LW = 0;
	FIX2_PHASE_ADDR.HW = 0;
    }
    HANDLE_START_ADDRESS();
    CURNMOD_GINDEX = 0;
    version(any_overlays)
    {
	if (DOING_OVERLAYS)
	{
	    // NEED TO MOVE START ADDRESS FROM EXEHEADER TO SLR_CODE_HEADER

	    BX = EXEHEADER._EXE_REG_IP;
	    CX = EXEHEADER._EXE_REG_CS;
	    // GOOD ENOUGH...
	    if (BX | CX)
	    {
		LDS	SI,SLR_CODE_HEADER
		SYM_CONV_DS
		DX = [SI]._LD_SECOND_BLK;
		SI += SIZE LDATA_HEADER_TYPE+$$SLR_MAIN;
		SI_FIXER();
		[SI] = BX;
		++SI;
		++SI;
		SI_FIXER();
		[SI] = CX;
	    }
	}
    }

    version(fg_segm)
    {
	RC_STARTER();
    }

	// OK, START AT FIRST AREA, ONE SECTION AT A TIME PLEASE


	EAX = FIRST_SECTION_GINDEX;
	goto TEST_SECTION;

SECTION_LOOP:
	CURN_SECTION_GINDEX = EAX;

	// WE PROBABLY CARE...
	OUT_NEW_SECTION();
SECL_2:
	ESI = CURN_SECTION_GINDEX;
	EAX ^= EAX;

	FIX2_LDATA_SEGMENT_GINDEX = EAX;

	// OK, START THROUGH MY SEGMODS


		CONVERT	ESI,ESI,SECTION_GARRAY
		ASSUME	ESI:PTR SECTION_STRUCT

	ESI = [ESI]._SECT_FIRST_SEGMOD_GINDEX;
	goto TEST_SEGMOD;

    version(fg_rom)
    {
SL_1:
	goto NEXT_SEG;

SL_2:

	// THIS IS A PHASE TARGET SEGMENT..., GET SOURCE VALUES


		PUSHM	FIX2_LDATA_SEGMENT.OFFS,FIX2_LDATA_SEGMENT.SEGM
	// SOURCE SEGMENT
		LDS	SI,FIX2_SEG_PHASE
	FIX2_LDATA_SEGMENT.OFFS = SI;
	FIX2_LDATA_SEGMENT.SEGM = DS;
		SYM_CONV_DS
	AX = FIX2_SEG_BASE.LW;
	BX = FIX2_SEG_BASE.HW;
	DI = &FIX2_SEGMENT_STUFF;
	CX = (SIZE SEGMENT_STRUCT+1)/2;
		REP	MOVSW
	AX -= FIX2_SEG_BASE.LW;
		SBB	BX,FIX2_SEG_BASE.HW
	FIX2_PHASE_ADDR.LW = AX;
	FIX2_PHASE_ADDR.HW = BX;
	goto SL_3;
    }

SEGMOD_LOOP:

	// FIRST, SEE IF THIS IS A NEW SEGMENT


	EBX = ESI;
	// FOR COMMONS AND STACKS...
	FIX2_NEW_SEGMOD_GINDEX = ESI;

		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

	EAX = [ESI]._SM_BASE_SEG_GINDEX;
	ECX = FIX2_LDATA_SEGMENT_GINDEX;

	if (ECX == EAX)
		goto SAME_SEG;

NEW_SEG:
	EAX = FIX2_LDATA_SEGMENT_GINDEX;
	if (EAX)
	    OUT_SEGMENT_FINISH();

NO_OLD_SEG:

	// ANOTHER SEGMENT...

	ESI = [ESI]._SM_BASE_SEG_GINDEX;
	EDI = &FIX2_SEGMENT_STUFF;

	FIX2_LDATA_SEGMENT_GINDEX = ESI;
		CONVERT	ESI,ESI,SEGMENT_GARRAY
		ASSUME	ESI:PTR SEGMENT_STRUCT
	ECX = (SIZE SEGMENT_STRUCT+3)/4;

		REP	MOVSD
    version(fg_segm)
    {
	// ARE WE REORDERING SEGMENTS FOR WINDOWS?
		GETT	DL,RC_REORDER
	EAX = FIX2_SEG_OS2_NUMBER;

	if (DL & DL)
		JZ	SL_3

		CONV_EAX_SEGTBL_ECX

		GETT	DL,RC_PRELOADS
	EAX = [ECX]._SEGTBL_FLAGS;

	if (DL & DL)
		JNZ	NOS_1

	// WANT JUST NON-PRELOADS


	if (AL & MASK SR_PRELOAD)
		JZ	SL_3

		GETT	AL,RC_REORDER_SEGS

	if (AL)
		JZ	SL_3
SKIP_THIS:
	ECX ^= ECX;
	EDX = FIX2_LDATA_SEGMENT_GINDEX;
	ESI = EBX;
	FIX2_LDATA_SEGMENT_GINDEX = ECX;

ST_1:
	ECX = ESI;
	// SKIP TILL BASE SEGMENT IS DIFFERENT
		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

	EBX = [ESI]._SM_BASE_SEG_GINDEX;
	ESI = [ESI]._SM_NEXT_SEGMOD_GINDEX;

	if (EDX != EBX)
		goto TS_1;

	if (ESI & ESI)
		JNZ	ST_1

	goto TEST_SEGMOD;

TS_1:
	ESI = ECX;
	goto TEST_SEGMOD;

NOS_1:

	// WANT JUST PRELOADS


	if (AL & MASK SR_PRELOAD)
		JZ	SKIP_THIS

		GETT	AL,RC_REORDER_SEGS

	if (AL & AL)
		JZ	SKIP_THIS
    }
    version(fg_rom)
    {
	if (FIX2_SEG_ORDER_FLAG & MASK DEF_PHASEE)
		JNZ	SL_1
	if (FIX2_SEG_ORDER_FLAG & MASK DEF_PHASE_TARG)
		JNZ	SL_2
    }

SL_3:

	// TELL OUTPUTTERS NEW SEGMOD COMING


	OUT_NEW_SEGMENT();

		CONVERT	ESI,EBX,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

SAME_SEG:
	EAX = ESI;
	EDI = OFF FIX2_SEGMOD_STUFF;

	ECX = (SIZE SEGMOD_STRUCT+3)/4;
	LDATA_SEGMOD_GINDEX = EBX;

		REP	MOVSD

	GET_SM_MODULE();


	// TELL OUTPUTTERS NEW SEGMOD COMING



	CURNMOD_GINDEX = EAX;

	// debug
    version(0)
    {
	ECX = FIX2_LDATA_SEGMENT_GINDEX;
		CONVERT	ECX,ECX,SEGMENT_GARRAY
		ASSUME	ECX:PTR SEGMENT_STRUCT
	AL = DOING_SEGMOD_ERR;

	ECX += SEGMENT_STRUCT._SEG_TEXT;
	WARN_ASCIZ_RET();
    }
	OUT_NEW_SEGMOD();

	RELINK_DATA_BACKWARDS();

	EAX ^= EAX;
	ESI = FIX2_SM_FIRST_DAT;

	// NO FORREFS HERE...
	FIX2_SM_LAST_DAT = EAX;
	goto LDATA_TEST;

SM_FIRST_FORREF:
	FIX2_SM_FIRST_DAT = ESI;
	goto SFF_RET;

		ASSUME	ESI:PTR LDATA_HEADER_TYPE
SM_LINK_FORREF:

	EDI = FIX2_SM_LAST_DAT;
		ASSUME	EDI:PTR LDATA_HEADER_TYPE

	if (EDI & EDI)
		JZ	SM_FIRST_FORREF

	[EDI]._LD_NEXT_LDATA = ESI;
SFF_RET:
	FIX2_SM_LAST_DAT = ESI;
	EAX ^= EAX;

	EBX = [ESI]._LD_NEXT_LDATA;
	[ESI]._LD_NEXT_LDATA = EAX;

	ESI = EBX;
	goto LDATA_TEST;

		ASSUME	EDI:NOTHING
SM_DATA_LOOP:

	// IF FORREF, SIMPLY LINK IT IN FOR NOW, CANNOT RELEASE


	AL = [ESI]._LD_TYPE;

	if (AL & MASK BIT_FI)
		JNZ	SM_FIXUPP

	if (AL & MASK BIT_FR)
		JNZ	SM_LINK_FORREF

	// MUST BE A DATA RECORD, FLUSH ANY ALREADY IN THERE...


	SM_FLUSH_LDATA();

	// NOW LOAD DATA RECORD PROPERLY, LIKE IN FIXUPP


	EAX = [ESI]._LD_BLOCK_BASE;
	EDI = OFF FIX2_LDATA_STUFF;
		ASSUME	EDI:PTR LDATA_HEADER_TYPE

	// LDATA_LOG SET HERE
	FIX2_LDATA_BASE = EAX;
	EBX = DPTR [ESI]._LD_LENGTH;

	[EDI]._LD_BLOCK_BASE = EAX;
	ECX = [ESI]._LD_NEXT_LDATA;

	DPTR [EDI]._LD_LENGTH = EBX;
	EBX &= 0FFFFH;

	EAX = [ESI]._LD_OFFSET;
	[EDI]._LD_NEXT_LDATA = ECX;

	[EDI]._LD_OFFSET = EAX;
	ESI += SIZEOF LDATA_HEADER_TYPE;

	AL = FIX2_LD_TYPE;
	EBX += ESI;

		ASSUME	ESI:NOTHING,EDI:NOTHING

	FIX2_LDATA_PTR = ESI;
	FIX2_LDATA_EOR = EBX;

	// CHECK FOR OVERLAPPED RECORD


	if (AL & MASK BIT_CONT)
		JZ	LDATA_LOADED

	LOAD_LDATA_SPEC();

LDATA_LOADED:
	EAX = FIX2_LD_OFFSET;
	EBX = FIX2_SM_START;

	EAX += EBX;

	FIX2_LDATA_LOC = EAX;

	// HERE WE CHECK FOR RELOCATION CONFLICTS...


	RELOCATION_CHECK();

	ESI = FIX2_LD_NEXT_LDATA;
LDATA_TEST:
	if (ESI & ESI)
		JNZ	SM_DATA_LOOP

	// IF THERE, FLUSH IT
	SM_FLUSH_LDATA();

	// NOW PROCESS ANY FORREF RECORDS LINKED HERE


	EAX = FIX2_SM_LAST_DAT;

	// ANY THERE?
	if (EAX & EAX)
		JZ	SM_FORREFS_DONE

	DOFORREFS();
SM_FORREFS_DONE:

	// OK, THAT FINISHES THIS SEGMOD, SIGNAL OUTPUTTERS


	OUT_SEGMOD_FINISH();

NEXT_SEGMOD:
	ESI = FIX2_SM_NEXT_SEGMOD_GINDEX;
TEST_SEGMOD:

	// IF SEGMOD DOESN'T EXIST, WE ARE DONE


	if (ESI & ESI)
		JNZ	SEGMOD_LOOP
SM_DONE:

	// IF A SEGMENT IS ACTIVE, DO END-OF-SEGMENT


	EAX = FIX2_LDATA_SEGMENT_GINDEX;

	if (EAX & EAX)
		JZ	SMD_1

	OUT_SEGMENT_FINISH();
SMD_1:
    version(fg_rom)
    {
	if (FIX2_SEG_ORDER_FLAG & MASK DEF_PHASEE)
		JZ	SMD_1

	// RESET STUFF BACK TO ORIGINAL SEGMENT


		POPM	DS,SI
	FIX2_LDATA_SEGMENT.OFFS = SI;
	FIX2_LDATA_SEGMENT.SEGM = DS;
		SYM_CONV_DS
		FIXES
	DI = &FIX2_SEGMENT_STUFF;
	CX = (SIZE SEGMENT_STRUCT+1)/2;
		REP	MOVSW
	// 		LDS	SI,FIX2_SEG_FIRST_SEGMOD

	FIX2_PHASE_ADDR.LW = CX;
	FIX2_PHASE_ADDR.HW = CX;
	HIGH_WATER.LW = CX;
	HIGH_WATER.HW = CX;
SMD_1:
    }

	// END OF SECTION, SIGNAL IT


	CURNMOD_GINDEX = 0;

	OUT_END_OF_SECTION();
    version(fg_segm)
    {
		GETT	AL,RC_REORDER
		GETT	CL,RC_PRELOADS

	if (AL & AL)
		JZ	NEXT_SECTION

	if (CL & CL)
		JZ	NO_MORE_RC

		RESS	RC_PRELOADS
	goto SECL_2;

NO_MORE_RC:
		RESS	RC_REORDER

    }

NEXT_SECTION:

	// OK, TRY FOR NEXT SECTION THIS AREA


	EAX = CURN_SECTION_GINDEX;
		CONVERT	EAX,EAX,SECTION_GARRAY
		ASSUME	EAX:PTR SECTION_STRUCT

	EAX = [EAX]._SECT_NEXT_SECTION_GINDEX;

TEST_SECTION:
	if (EAX & EAX)
		JNZ	SECTION_LOOP
EOS:
	OUT_END_OF_SEGMENTS();
	EAX ^= EAX;
	CURNMOD_GINDEX = EAX;
	return;

		ASSUME	EAX:NOTHING

SM_FIXUPP:

	// OK, LOAD/LOCK FIXUPP RECORD FOR EASY ACCESS...


	// DS:SI IS FIXUPP RECORD
	LOAD_LOCK_FIXUPP();
	// DO TRANSFORMS
	DOFIXUPPS();

	ESI = FIX2_FH_NEXT_FIXUPP;
	goto LDATA_TEST;

}


DOFORREFS()
{

	// GO THROUGH LIST OF FORREF RECORDS


	// FIRST FORREF RECORD
	ESI = FIX2_SM_FIRST_DAT;
SM_FORREF_LOOP:
	// DS:SI IS FORREF RECORD
	LOAD_LOCK_FIXUPP();
	FORREF2();
	RELEASE_FIXUPP();
	ESI = FIX2_FH_NEXT_FIXUPP;

	if (ESI & ESI)
		JNZ	SM_FORREF_LOOP

	return;

}


		ASSUME	ESI:PTR FIXUPP_HEADER_TYPE

LOAD_LOCK_FIXUPP()
{

	// DS:SI POINTS TO RECORD

	// FIX2_FIXUPP_EOR IS END OF RECORD


	EAX = [ESI]._FH_BLOCK_BASE;
	EDI = OFF FIX2_FIXUPP_STUFF;
		ASSUME	EDI:PTR FIXUPP_HEADER_TYPE

	FIX2_FIXUPP_BASE = EAX;
	EBX = DPTR [ESI]._FH_LENGTH;

	[EDI]._FH_BLOCK_BASE = EAX;
	DPTR [EDI]._FH_LENGTH = EBX;

	ECX = [ESI]._FH_NEXT_FIXUPP;
	EBX &= 0FFFFH;

	[EDI]._FH_NEXT_FIXUPP = ECX;
	ESI += SIZEOF FIXUPP_HEADER_TYPE;

		ASSUME	ESI:NOTHING,EDI:NOTHING

	CL = FIX2_FH_TYPE;
	EBX += ESI;

	CL &= MASK BIT_CONT;
		JNZ	L1$

	FIX2_FIXUPP_EOR = EBX;

	return;

L1$:
	EBX -= ESI;

	// NEXT LOGICAL BLOCK #
	ECX = &[EAX + PAGE_SIZE];
	EDI = OFF TEMP_FIXUPP_RECORD;

	ECX -= ESI;
	// USAGE COUNTER
	EDX = [EAX];

	// SAVE THIS #
	EBX -= ECX;
	--EDX;

	ECX >>>= 2;
	[EAX] = EDX;

		REP	MOVSD

	ESI = [EAX+4];
	ECX = &[EBX+3];

	if (EDX & EDX)
		JNZ	L2$

	RELEASE_BLOCK();

L2$:
	EAX = ESI;
	EDX = &[EDI+EBX];

	EBX = [ESI];
	ESI += BLOCK_BASE;

	ECX >>>= 2;
	--EBX;

		REP	MOVSD

	[EAX] = EBX;
		JNZ	L3$

	RELEASE_BLOCK();

L3$:
	// NO BLOCK TO UNLOCK...
	FIX2_FIXUPP_BASE = ECX;
	FIX2_FIXUPP_EOR = EDX;

	ESI = OFF TEMP_FIXUPP_RECORD;
	return;

}


LOAD_LDATA_SPEC()
{

	// THIS GUY IS SPLIT OVER TWO BLOCKS, MOVE HIM TO LOCAL STORAGE


	EBX = DPTR FIX2_LD_LENGTH;
	EAX = FIX2_LD_BLOCK_BASE;

	EBX &= 0FFFFH;
	EDI = OFF TEMP_DATA_RECORD;

	if (EBX A$ MAX_LEDATA_LEN+32)
		goto L5$;

	ECX = &[EAX + PAGE_SIZE];
	FIX2_LDATA_PTR = EDI;

	ECX -= ESI;
	// USAGE COUNTER
	EDX = [EAX];

	// SAVE THIS #
	EBX -= ECX;

	ECX >>>= 2;
	--EDX;

		REP	MOVSD

	ESI = [EAX+4];
	ECX = &[EBX+3];

	[EAX] = EDX;
		JNZ	L1$

	RELEASE_BLOCK();

L1$:
	EAX = ESI;
	EDX = &[EDI+EBX];

	EBX = [ESI];
	ESI += BLOCK_BASE;

	ECX >>>= 2;
	--EBX;

		REP	MOVSD

	[EAX] = EBX;
		JNZ	L3$

	RELEASE_BLOCK();

L3$:

	FIX2_LDATA_EOR = EDX;
	FIX2_LDATA_BASE = ECX;

	return;

L5$:
	AL = REC_TOO_LONG_ERR;
	goto ERR_ABORT;

}


SM_FLUSH_LDATA()
{

	// IF LDATA EXISTS, SEND IT OFF TO OTHER PROCESSOR


	EAX = FIX2_LDATA_PTR;

	if (EAX & EAX)
		JZ	L99$

	// OMF, HEX, EXE, DEBUG, ETC
	EXE_OUT_LDATA();

	ECX ^= ECX;
	EAX = FIX2_LDATA_BASE;

	FIX2_LDATA_BASE = ECX;
	FIX2_LDATA_PTR = ECX;

	if (EAX & EAX)
		JZ	L99$

	--DPTR [EAX];
		JZ	RELEASE_BLOCK
L99$:
	return;

}


RELEASE_FIXUPP()
{

	// UNLOOSE THAT RECORD


	EAX = FIX2_FIXUPP_BASE;

	if (EAX & EAX)
		JZ	L9$

	--DPTR [EAX];
		JZ	RELEASE_BLOCK
L9$:
	return;

}


    version(fg_segm)
    {

DO_FIXIMPORT()
{

	// WE ARE ACCESSING AN IMPORTED ITEM...


	// THIS BECOMES A RELOCATION ITEM,

	// SELF-REL IS ILLEGAL, ETC


	EAX = FIX2_TOFFSET;
	EBX = FIX2_OFFSET;

	CL = FIX2_SEG_TYPE;
	EDI = FIX2_LDATA_PTR;

	ECX &= MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1;
	// TRY IGNORING THEM... FOR MICRORIM (LINK-COMPATIBLE...)
		JNZ	L1$

	if (FIX2_IMP_MODULE == ECX)
	// FLOAT CONSTANT
		goto L5$;

	IMP_CALLTBL[ESI*4]();
L1$:
	goto FIX_UNDEF_RET;

L5$:
	// LOC_9
	if (ESI != 34/2)
		goto L51$;
L50$:
	WPTR [EDI+EBX] += AX;
	EDI += EBX;

	EAX = FIX2_LDATA_LOC;
	// ADDITIVE, OS FIXUP
	ECX = 0705H;

	// TARGET LOGICAL ADDRESS
	EAX += EBX;
	// OS FIXUP NUMBER
	EDX = FIX2_IMP_OFFSET;

	EBX ^= EBX;

	// ES:DI IS PHYS_PTR

	// AX IS OFFSET IN SEGMENT

	// BX IS _RL_IMP_OFFSET

	// CL IS FIXUPP TYPE

	// CH IS FIXUPP FLAGS

	// DX IS _RL_IMP_MODULE


	// DO RELOCATION
	RELOC_INSTALL();

	goto FIX_UNDEF_RET;

L51$:
	// LOC_13
	if (ESI == 42/2)
		goto L50$;
	BAD_MYLOC();

	goto FIX_UNDEF_RET;

}

    }

FIX_UN_A:	JMP	FIX_UNDEF_RET

FCR:		JMP	FIX_CANT_REACH


DOFIXUPPS()
{
	DOF_PRELIM();

	// SO, GO AHEAD AND DO FIXUPP



DOFIXUPPS_MODEND_A::
		PUSH	ESI
	// UNDEFINED SYMBOL, IGNORE
		JC	FIX_UN_A

	ESI = FIX2_LOC;
	EDI = LOC_CALLTBL_PTR;

		GETT	AL,OUTPUT_PE
		GETT	CL,OUTPUT_SEGMENTED

	if (AL)
		JNZ	DOF_PE

	if (CL)
		JZ	DOF_REAL

	EAX = FIX2_OS2_TFLAGS;

	if (EAX & MASK SR_1)
		JNZ	DO_FIXIMPORT

	// TARGET SEGMENT MUST EQUAL
	EAX = FIX2_OS2_TNUMBER;
	// FRAME SEGMENT
	ECX = FIX2_OS2_FNUMBER;

	if (EAX != ECX)
	// FIX_CANT_REACH
		goto FCR;

	CL = FIX2_TTYPE;
	EAX = FIX2_TOFFSET;

	CL &= MASK SEG_ASEG;
		JZ	DOF_CONT

	EAX -= FIX2_OS2_FNUMBER;
	goto DOF_CONT;

    version(fg_pe)
    {

DOF_PE:
	EAX = FIX2_TOFFSET;
	goto DOF_CONT;

    }

DOF_REAL:
	EAX = FIX2_OS2_TNUMBER;
	EBX = FIX2_OS2_FNUMBER;

	EAX -= EBX;
		JC	FIX_CANT_REACH1

	if (EAX AE 64K)
	// MAYBE OUT-OF-RANGE
		goto FIX_ERR6;
FIX_ERR6_OK:
	ECX = LOC_10;
	EAX = FIX2_TOFFSET;

	if (ECX == OFF LOC_10_PROT)
		goto DR_9;
DR_8:
	EAX -= EBX;
DR_9:

DOF_CONT:
	CL = FIX2_LD_TYPE;
	ESI = &[ESI*4+EDI];

	// CAN'T CHECK LIDATA TYPES TILL LATER...
	CL &= MASK BIT_LI;
		JNZ	L29$

	EDI = FIX2_OFFSET;
	// IS THIS COLLIDING WITH A PREVIOUS FIXUPP?
	ECX = FIX2_LDATA_LOC;

	EDI += ECX;
	ECX = FIX2_STACK_DELTA;

	EDI += ECX;
	ECX = FIX2_SM_START;

	EDI -= ECX;
	ECX = RELOC_HIGH_WATER;

	if (ECX $$ EDI)
	// USED BY FARCALLTRANSLATE
	FIX2_RELOC_OFFSET = EDI;

		JA	L2$
L29$:

	// BX IS FIX2_OFFSET

	// CX:AX IS OFFSET WITHIN SEGMENT

	// DX IS FIX2_FRAME.HW


	// PHYSICAL ADDRESS
	EDI = FIX2_LDATA_PTR;
	EBX = FIX2_OFFSET;

	DPTR [ESI]();

FIX_UNDEF_RET::
		POP	ESI
	EDI = FIX2_FIXUPP_EOR;

	if (EDI A$ ESI)
		goto DOFIXUPPS;

		JNZ	F_OOPS

	// OK, NOW RELEASE FIXUPP RECORD AND UNLOCK BLOCK


	RELEASE_FIXUPP();
	return;

F_OOPS:
	OBJ_PHASE();


FIX_ERR6:

	// ACTUALLY, THIS IS OK IF A 32-BIT OFFSET TYPE...

	// LIKE 25 OR 27



	ECX = EAX;
	AL = BPTR FIX2_LOC;

	// *2
	if (AL == 18)
		goto CHECK_64K;

	// *2
	if (AL == 25)
		goto FIX_ERR6_OK;

	// *2
	if (AL == 27)
		goto FIX_ERR6_OK;

	// *2
	if (AL == 10)
		goto FIX_ERR6_OK;

	// *2
	if (AL == 29)
		goto FIX_ERR6_OK;

FIX_CANT_REACH::
	AL = CANT_REACH_ERR;
	if (DOING_START_ADDRESS)
		JZ	FCR_4
	AL = START_ERR;
	FIX2_FTYPE = MASK SEG_CLASS_IS_CODE + MASK SEG_RELOC;
	FIX2_TTYPE = MASK SEG_CLASS_IS_CODE + MASK SEG_RELOC;
FCR_4:
	FIX_ERROR();
	goto FIX_UNDEF_RET;

    version(fg_norm_exe)
    {

FIX_CANT_REACH1:

	// FRAME LARGER, TRY ADDING OFFSET IN AS LAST RESORT


    version(fg_dosx)
    {
	// IGNORE IF DOSX...
	if (EXETYPE_FLAG == DOSX_EXE_TYPE)
		goto FIX_ERR6_OK;
    }
	EAX = FIX2_TOFFSET;

	EAX -= EBX;
		JC	FIX_CANT_REACH

	goto FIX_ERR6_OK;

    }

L2$:
		PUSHM	SI,DX,CX,BX,AX

	// NEED AX = FIRST BIT TO CHECK, CX = # OF BITS


		XCHG	AX,DI
	SI >>>= 1;
	CL = LOC_SIZE[SI];
	CH ^= CH;
	SPECIAL_RELOC_CHECK();
		POPM	AX,BX,CX,DX,SI
	goto L29$;

    version(fg_norm_exe)
    {

CHECK_64K:
	if (ECX != 64K)
		goto FIX_CANT_REACH;
	goto FIX_ERR6_OK;

    }

L5$:
	goto FIX_UNDEF_RET;

}


DOFIXUPPS_MODEND	EQU	(DOFIXUPPS_MODEND_A)


DOF_PRELIM()
{



	EAX = [ESI];
	ESI += 4;

	ECX = EAX;
	EDX = EAX;

	ECX >>>= 16;
	EAX &= 0FFFFH;

	EDX >>>= 26;
	ECX &= 1024-1;

	FIX2_LOC = EDX;
	FIX2_OFFSET = ECX;

}

; Returns: C
;	NC
PARSE_FIXUPP2(EAX, ESI)
{

	// NOW SET UP STUFF FOR FRAME AND TARGET	- PRESERVE SI

	// POSSIBLE TARGETS ARE:
	// 	0	SEGMENT (1 BYTE) DELTA=0
	// 	1	GROUP	(1 BYTE) DELTA=8
	// 	2	SYMBOL	(1 BYTE) DELTA=48
	// 	3	ABSOLUTE(1 BYTE) DELTA=0
	//   +4	MEANS	2 BYTE INDEX INSTEAD OF 1
	//     08-0F	GROUPS 1 THRU 8
	//     10-3F	SYMBOLS 1 THRU 48
	//    HIGH 2 BITS
	// 	00	NO OFFSET
	// 	01	1 BYTE OFFSET
	// 	10	2 BYTE OFFSET
	// 	11	3 BYTE OFFSET


	EBX = EAX;
	ECX = [ESI];

	ESI += 4;
	EDX = 0;

	if (EAX & 1000H)
		JZ	L2$

	EDX = [ESI];
	ESI += 4;

L2$:
	AH &= 0FH;
	FIX2_TOFFSET = EDX;

	BPTR FIX2_TT = AH;
	FIX2_TINDEX = ECX;

	// PARSE STUFF FOR FRAME

	if (AL B$ 4)
		goto L25$;

	if (AL B$ 6)
		goto L3$;

	ECX = EAX;

	ECX &= 07FH;
	AL = 1;

	ECX = GROUP_PTRS[ECX*4-6*4];
	goto L3$;


L25$:
	ECX = [ESI];
	ESI += 4;

L3$:
	EDX = FIX2_TT;
		PUSH	ESI

	// IN CODE SEGMENT...
	EBX = FIX2_TARG_TABLE;
	BPTR FIX2_FF = AL;

	EAX = FIX2_TINDEX;
	FIX2_FINDEX = ECX;

	// NOW PROCESS STUFF


	DPTR [EBX+EDX*4]();

	FIX2_TTYPE = AL;
	// UNDEFINED SYMBOL
		JC	L99$

		GETT	AL,OUTPUT_PE
	EBX = FIX2_FF;

	AL |= AL;
		JNZ	L99$

	EAX = FIX2_FINDEX;

	FIX2_FRAME_TABLE[EBX*4]();

	FIX2_FTYPE = AL;
	// UNDEFINED SYMBOL
		JC	L99$

	FIX2_OS2_FNUMBER = ECX;
	// 		MOV	FIX2_OS2_FFLAGS,EDX

    version(any_overlays)
    {
	if (VECTORED_REFERENCE)
		JZ	4$

	// IF FRAME IS BELOW VECTOR TABLE, AND WITHIN 64K OF END OF TABLE, USE IT, ELSE USE VECTOR_TABLE_ADDRESS


		RESS	VECTORED_REFERENCE
	AX = END_VECTOR_TABLE.LW;
	BX = END_VECTOR_TABLE.HW;
	AX -= CX;
		SBB	BX,DX
		JZ	4$
	AX = VECTOR_TABLE_ADDRESS.LW;
	DX = VECTOR_TABLE_ADDRESS.HW;
	FIX2_FFRAME.LW = AX;
	FIX2_FFRAME.HW = DX;
    }
L4$:
	AL = FIX2_TTYPE;
		POP	ESI

	// IF TARG IS CONSTANT, FORCE FRAME TO MATCH
	if (AL & MASK SEG_CONST)
	// CHECK NORMALLY...
		JNZ	L9$

	return;

L99$:
		POP	ESI

	return;

L9$:
	EAX = FIX2_OS2_TNUMBER;
	ECX = FS_TYPE_TARG;

	FIX2_OS2_FNUMBER = EAX;
	AL = MASK SEG_ASEG;

	// =FRAME TARG...
	FIX2_FF = ECX;
	FIX2_FTYPE = AL;

	return;

}


LOC_0_PROT()
{

	// SELF-RELATIVE SHORT JUMP


	// CX:AX IS OFFSET OF TARGET FROM FRAME


	// BX IS FIX2_OFFSET

	// CX:AX IS OFFSET WITHIN SEGMENT

	// DX IS FIX2_FRAME.HW


	// FIRST, SEE IF CURRENT LOCATION IS IN FRAME


	ESI = FIX2_OS2_TNUMBER;
	EDX = FIX2_SEG_OS2_NUMBER;

	if (EDX != ESI)
		goto FIX_LOC_FRAME;
LOC_0_PE::
	EDX = FIX2_LDATA_LOC;
	// OUCH!
	EAX -= EBX;

	EAX -= EDX;
	goto LOC_0_CONT;

}


LOC_0_REAL()
{
	ESI = FIX2_LDATA_LOC;
	EDX = FIX2_FFRAME;
	ESI += EBX - EDX;

	if (ESI AE 64K)
		goto FIX_LOC_FRAME;

	// OK, SO, TOFFSET-CURLOC-1

	EAX -= ESI;
	LOC_0_CONT(EAX, EDI, EBX);
}


LOC_0_CONT(EAX, EDI, EBX)
{
	if (--EAX < 0)
	    goto LT_0;

	if (EAX NC 128)
		goto SHORT_ERROR;

	[EDI+EBX] += AL;

	return;


SHORT_ERROR:
	AL = SHORT_ERR;
	goto FIX_ERROR;

LT_0:
	if (EAX C$ -128)
		goto SHORT_ERROR;
LOC_0_OK::
	[EDI+EBX] += AL;

	return;

}


LOC2_8()
{

	// LO-BYTE


	// CX:AX IS OFFSET FROM FRAME

	DL = [EDI+EBX];
		GETT	CL,CHECK_LO_BYTE
	DL += AL;
	[EDI+EBX] = DL;
	if (CL)
		JZ	L1$

	if (AH)
		JZ	L1$

	if (EAX C$ -128)
		goto LOC2_8_ERR;
L1$:
	return;

LOC2_8_ERR:
	AL = LOBYTE_ERR;
FIX_ERROR::
	FIXUPP_ERROR();
	return;

FIX_LOC_FRAME::
	AL = LOC_FRAME_ERR;
	FIXUPP_ERROR();
	return;

}


LOC_1_PROT()
{

	// SELF-RELATIVE NEAR JUMP


	// CX:AX IS OFFSET OF TARGET FROM FRAME
	// BX IS FIX2_OFFSET
	// CX:AX IS OFFSET WITHIN SEGMENT
	// DX IS FIX2_FRAME.HW

	// FIRST, SEE IF CURRENT LOCATION IS IN FRAME

	EDX = FIX2_LDATA_LOC;
	EAX -= EBX;

	ESI = FIX2_OS2_TNUMBER;
	EAX -= EDX;

	ECX = FIX2_SEG_OS2_NUMBER;
	EAX -= 2;

	if (ESI != ECX)
		goto FIX_LOC_FRAME;

	// IF BOTH WITHIN FRAME, RANGE MUST BE OK...


	WPTR [EDI+EBX] += AX;
	return;
}


LOC_1_REAL()
{
	ESI = FIX2_LDATA_LOC;
	EDX = FIX2_FFRAME;
	ESI += EBX - EDX;
	EAX -= 2;

	if (ESI AE 64K)
		goto FIX_LOC_FRAME;

	// OK, SO, TOFFSET-CURLOC-1

	EAX -= ESI;

	// IF BOTH WITHIN FRAME, RANGE MUST BE OK...

	WPTR [EDI+EBX] += AX;
	return;
}


LOC_32SELF_PROT()
{
	// SELF-RELATIVE 32-BIT JUMP...

	// CX:AX IS OFFSET OF TARGET FROM FRAME
	// BX IS FIX2_OFFSET
	// CX:AX IS OFFSET WITHIN SEGMENT
	// DX IS FIX2_FRAME.HW

	// FIRST, SEE IF CURRENT LOCATION IS IN FRAME

	ESI = FIX2_OS2_TNUMBER;
	EDX = FIX2_SEG_OS2_NUMBER;

	if (EDX != ESI)
		goto FIX_LOC_FRAME;
LOC_32SELF_PE::
	EDX = FIX2_LDATA_LOC;
	ECX = [EDI+EBX];

	EAX -= EDX;
	ECX -= EBX;

	EAX += ECX;

	EAX -= 4;

	[EDI+EBX] = EAX;

	return;
}


LOC_32SELF_REAL()
{
	ESI = FIX2_LDATA_LOC;
	EDX = FIX2_FFRAME;

	ESI -= EDX;
	EAX -= EBX;

	// OK, SO, TOFFSET-CURLOC-1


	EAX -= ESI;
	ECX = [EDI+EBX];

	EAX -= 4;

	EAX += ECX;

	// IF BOTH WITHIN FRAME, RANGE MUST BE OK...


	[EDI+EBX] = EAX;

	return;
}


IMP_8()
{
	// LO-BYTE

	// DX:AX IS OFFSET FROM FRAME

	DL = [EDI+EBX];
	// ADDITIVE, LOBYTE
	ECX = 400H;

	// CLEAR ANY OFFSET
	DL += AL;

	[EDI+EBX] = DL;
	goto DO_IMPORT;
}


LOC_13_PROT()
{
	// 16 BIT OFFSET SPECIAL
	// IF NOT PROTMODE, AND TARGET IS LOADONCALL, USE POINTER
	// RELOC

	KEEP_RELOC_OFFSET?();
		JZ	LOC_9
LOC_131:
	// 16 BIT OFFSET
	ECX = 5;
	goto DO_INTERNAL;
}


KEEP_RELOC_OFFSET?()
{
	// IS THE OFFSET RELOCATABLE, OR JUST SEGMENT?

	DL = FIX2_SEG_TYPE;
	// CONSTANT, LOSE OFFSET
	ECX = FIX2_OS2_TNUMBER;
	DL &= MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1;
	// CODEVIEW, LOSE OFFSET
		JNZ	L7$

	if (ECX & ECX)
		JZ	L71$

	DL = FIX2_TTYPE;
	CL = EXETYPE_FLAG;

	DL &= MASK SEG_ASEG;
		JNZ	L7$

	// IF EXETYPE > 2, KEEP POINTER (DOS4 AND UNKNOWN DON'T OPTIMIZE)


	// NOT OS/2 OR WINDOWS, RETAIN RELOCATABLE OFFSET
	if (CL A$ WIN_SEGM_TYPE)
	// EVEN IF NOT MOVABLE
		goto L8$;

	ESI = MOVABLE_MASK;
	EDX = FIX2_OS2_TFLAGS;

	// MOVABLE|DISCARD|IOPL
	if (ESI & EDX)
		JZ	L71$

	// OK, ITS A 'MOVABLE' TYPE.


	// IF WINDOWS, REAL MODE, WE KEEP ALL


		GETT	CH,PROTMODE

	if (CH & CH)
		JNZ	L1$

	if (CL == WIN_SEGM_TYPE)
	// WINDOWS, YES, KEEP
		goto L8$;
L1$:

	// PROTECTED MODE AND/OR OS/2, KEEP ONLY IF IOPL-NONCONFORMING-CODE REFERENCED
	// FROM ANYTHING OTHER THAN IOPL-NONCONFORMING-CODE

	// 		TEST	DX,1 SHL SR_DPL		;IOPL?		;CAN ONLY GET HERE IF IOPL
	// 		JZ	8$			;NO, KEEP

	// THEN USE MOVABLE OFFSET ONLY IF NONCONFORMING AND CODE ALSO...

	// CONFORMING OR DATA
	EDX &= MASK SR_CONF+1;
	// YES, IGNORE OFFSET
		JNZ	L7$

	// OK, TARGET IS IOPL-NONCONFORMING-CODE
	// THROW AWAY OFFSET ONLY IF CURRENT SEGMENT IS SAME

	ECX = FIX2_SEG_OS2_FLAGS;
	EDX = 1 SHL SR_DPL;

	if (ECX & EDX)
	// NOT IOPL, KEEP OFFSET
		JZ	L8$

	ECX &= MASK SR_CONF+1;

	return;

L8$:
	// RETAIN OFFSET
	CL |= -1;

	return;

L7$:
	// Z, USE INTERNAL, NON-MOVING
	if (AL $$ AL)
L71$:
	return;

}


    version(fg_pe)
    {
LOC_9_PE:
	CL = FIX2_TTYPE;

	CL &= MASK SEG_ASEG;
		JZ	BAD_MYLOC
    }
LOC_13_REAL:
LOC_9:

	// 16-BIT OFFSET


	WPTR [EDI+EBX] += AX;
	return;


    version(fg_segm)
    {

IMP_9()
{

	// 16-BIT OFFSET


	WPTR [EDI+EBX] += AX;
	// 16-BIT OFFSET
	ECX = 005H;

		JZ	L2$

	// YES, ADDITIVE
	CH |= 4;
L2$:
	goto DO_IMPORT;

}

    }


LOC2_12()
{

	// HI-BYTE


	[EDI+EBX] += AH;
	return;

}


LOC_11_PROT()
{

	// 16:16 POINTER


	DL = FIX2_SEG_TYPE;
		GETT	CL,FARCALLTRANSLATION_FLAG

	DL &= MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1;
		JNZ	L11_NORM

	if (CL & CL)
		JZ	L5$

	DL = FIX2_SEG_TYPE;

	DL &= MASK SEG_CLASS_IS_CODE;
		JZ	L5$

	ESI = FIX2_OS2_TNUMBER;
	EDX = FIX2_SEG_OS2_NUMBER;

	if (EDX != ESI)
		goto L5$;

	CHECK_9A();

		JZ	FAR_CALL_COMMON


L5$:
	KEEP_RELOC_OFFSET?();

		JZ	L11_NORM
LOC_111:
	// 16:16
	ECX = 3;
	goto DO_INTERNAL;

}


L11_NORM:
	WPTR [EDI+EBX] += AX;
	EBX += 2;

	// PLUS WHATEVER ELSE IS NEEDED FOR RANGE CHECKING


	EAX ^= EAX;
	goto LOC_10;


LOC_11_REAL()
{

	// 16:16 POINTER


		GETT	CL,FARCALLTRANSLATION_FLAG
	DL = FIX2_SEG_TYPE;

	if (CL & CL)
		JZ	L11_NORM

	DL &= MASK SEG_CLASS_IS_CODE;
		JZ	L11_NORM

	// FRAME MUST MATCH FRAME OF LDATA_LOC


	ESI = FIX2_SEG_FRAME;
	EDX = FIX2_FFRAME;

	if (ESI != EDX)
		goto L11_NORM;

	if (FIX2_TFRAME != ESI)
		goto L11_NORM;

	CHECK_9A();
		JNZ	L11_NORM

	// MAKE CX:AX 20-BIT REAL


	EAX += FIX2_TFRAME;
	goto FAR_CALL_COMMON;

}


FAR_CALL_COMMON()
{



	ESI |= ESI;
		JNZ	FAR_JMP_COMMON

	// NOP, PUSH CS, CALL NEAR


	AX += WPTR [EDI+EBX];
	ECX = 0E80EH;

	WPTR [EDI+EBX] = CX;
	EBX += 2;

	ECX = FIX2_LDATA_LOC;
	EAX -= EBX;

	EAX -= ECX;

	EAX -= 2;

	WPTR [EDI+EBX] = AX;
	return;

FAR_JMP_COMMON:
	DX = WPTR [EDI+EBX];
	ECX = FIX2_LDATA_LOC;

	ECX += EBX;
	EAX += EDX;

	EAX -= ECX;
	CL = 90H;

	EAX -= 2;
	2[EDI+EBX] = CL;

	WPTR [EDI+EBX] = AX;
	return;

}


CHECK_9A()
{

	// **** MUST PRESERVE AX ****


	// RETURNS NZ IF NO MATCH

	// SI=0 IF CALL, SI=1 IF JMP


	CL = FIX2_SM_FLAGS_2;

	CL &= MASK SM2_DATA_IN_CODE;
		JNZ	L9$

	if (EBX & EBX)
		JZ	L5$
CHECK_9AA:
	DL = BPTR [EBX+EDI-1];

	if (DL != 9AH)
	// NOT A FAR CALL, TRY JUMP
		goto L3$;

	TEST_9A_RELOC();

	DL = 90H;
		JNZ	L1$

	ESI ^= ESI;
	BPTR [EDI+EBX-1] = DL;
L1$:
	return;


L3$:
	if (DL != 0EAH)
		goto L9$;
	TEST_9A_RELOC();

	DL = 0E9H;
		JNZ	L4$

	BPTR [EBX+EDI-1] = DL;
	ESI = 1;
L4$:
	return;

L5$:

	// THIS IS A BIT TRICKIER, WOULD BE NICE FOR FARCALL,

	// ABSOLUTELY NECESSARY FOR SINGLE-LEVEL OVERLAYS...


	// ES:DI POINTS TO RECORD, BX IS OFFSET FROM RECORD

	// NEED TO CALCULATE ADDRESS RELATIVE FROM FIX2_SEGMENT_BASE

	// AND GO CHECK THAT BYTE...


		PUSHM	EDI,EBX

		PUSH	EAX
	EDI = FIX2_LDATA_LOC;

	EBX = FIX2_STACK_DELTA;
	ECX = FIX2_SM_START;

	EDI += EBX;
	++ECX;

	EDI -= ECX;
		JC	L8$

	EBX = EDI;
	EDI &= PAGE_SIZE-1;

	EBX >>>= PAGE_BITS;
	++EDI;

	EBX = &EXETABLE[EBX*4];
	CONVERT_SUBBX_TO_EAX();

	EBX = EAX;
	CHECK_9AA();
L81$:
		POPM	EAX,EBX,EDI
L9$:
	return;

L8$:
	ESI |= -1;
	goto L81$;

}


TEST_9A_RELOC()
{

	// ECX & EDX ARE AVAILABLE


	EDX = FIX2_RELOC_OFFSET;
	ECX = RELOC_HIGH_WATER;

	EDX -= 1;
		JC	L9$

	if (ECX BE EDX)
		goto L9$;

	CL = DL;
		PUSH	EAX

	// BYTE #
	EDX >>>= 3;
	CL &= 7;

	EDX += RELOC_BITS;
	AL = 1;

	AL <<= CL;

	AL &= [EDX];
		POPM	EAX

	return;

L9$:
	if (BL $$ BL)

	return;

}


    version(fg_segm)
    {

IMP_11()
{

	// 16:16 POINTER


	ECX = [EDI+EBX];
	EAX &= 0FFFFH;

	EAX += ECX;
	// 16:16
	ECX = 003H;

	WPTR [EDI+EBX] = AX;
		JZ	L2$
	// YES, ADDITIVE
	CH |= 4;
L2$:
	goto DO_IMPORT;

}

    }


LOC_DWORD_OFFSET1_PROT()
{

	// 32 BIT OFFSET SPECIAL


    version(fg_segm)
    {
	KEEP_RELOC_OFFSET?();
		JZ	LOC_DWORD_OFFSET
LOC_LDO1:
	// 16 BIT OFFSET
	ECX = 00DH;
	goto DO_INTERNAL;

    }

}



LOC_DWORD_OFFSET1_REAL:

LOC_DWORD_OFFSET:

	// 32-BIT OFFSET


	[EDI+EBX] += EAX;

	return;

    version(fg_pe)
    {

LOC_DWORD_OFFSET_PE()
{

	// 32-BIT OFFSET


	ECX = [EDI+EBX];
	DL = FIX2_TTYPE;

	ECX += EAX;
	DL &= MASK SEG_ASEG;

	[EDI+EBX] = ECX;
		JNZ	L9$

	EAX = FIX2_LDATA_LOC;

	EAX += EBX;
	goto DO_PE_RELOC;
L9$:
	return;

}


LOC_DWORD_OFFSET_TLS()
{

	// 32-BIT OFFSET


	EDX = FIX2_SEG_GINDEX;
	ECX = [EDI+EBX];

	ECX += EAX;
	if (EDX & EDX)

	EAX = PE_BASE;
		JZ	L4$

		CONVERT	EDX,EDX,SEGMENT_GARRAY
		ASSUME	EDX:PTR SEGMENT_STRUCT

	EDX = [EDX]._SEG_PEOBJECT_GINDEX;
	ECX -= EAX;

		CONVERT	EDX,EDX,PE_OBJECT_GARRAY
		ASSUME	EDX:PTR PE_OBJECT_STRUCT

	EDX = [EDX]._PEOBJECT_RVA;

	ECX -= EDX;
L4$:
	[EDI+EBX] = ECX;

	return;

}

    }

    version(fg_segm)
    {

IMP_DWORD_OFFSET()
{

	// 32-BIT OFFSET


	ECX = [EDI+EBX];

	EAX += ECX;
	ECX = 00DH;

	[EDI+EBX] = EAX;
		JZ	L2$

	// YES, ADDITIVE
	CH |= 4;
L2$:
	goto DO_IMPORT;

}

    }

    version(fg_segm)
    {

IMP_FWORD_PTR()
{

	// 16:32 POINTER


	DX = WPTR [EDI+EBX+4];
	ECX = [EDI+EBX];

	EAX += ECX;
	// 16:32
	ECX = 00BH;

	[EDI+EBX] = EAX;
		JNZ	L1$

	EDX &= 0FFFFH;
		JZ	L2$
L1$:
	CH |= 4;
L2$:
	goto DO_IMPORT;

}

    }


LOC_FWORD_PTR_PROT()
{

	// 16:32 POINTER


    version(fg_segm)
    {
	KEEP_RELOC_OFFSET?();
		JZ	LFP_NORM
LOC_LFP1:
	// 16:32
	ECX = 00BH;
	goto DO_INTERNAL;

LFP_NORM:
    }

}


LOC_FWORD_PTR_REAL:

	ECX = [EDI+EBX];
	EBX += 4;

	ECX += EAX;
	EAX ^= EAX;

	[EDI+EBX-4] = ECX;
	goto LOC_10;

    version(fg_pe)
    {

LOC_10_PE()
{



	AL = UNREC_FIXUPP_ERR;
	FIXUPP_ERROR();
	return;

}

    }


public LOC_10_PROT()
{

	// BASE


    version(fg_segm)
    {

	// segmented mode...


	CX = WPTR [EDI+EBX];

	ECX &= 0FFFFH;
		JNZ	DI_101
DI_1011:
	KEEP_RELOC_OFFSET?();

	DL = FIX2_SEG_TYPE;
		JNZ	DI_103

	DH = FIX2_TTYPE;
	EAX = FIX2_OS2_TNUMBER;

	DL &= MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1;
		JNZ	LOC_10_DEBUG

	DH &= MASK SEG_ASEG;
		JNZ	LOC_10_DEBUG_A

	// CONSTANT?
	if (EAX & EAX)
		JZ	LOC_10_DEBUG
DI_104:
	EAX ^= EAX;
	// BASE, DON'T LOOK EVEN IF MOVABLE
	ECX = 0802H;
	goto DO_INTERNAL;

DI_103:
	ECX = 002H;
	goto DO_INTERNAL;

DI_101:

	// HMM, FOR FORTRAN WE NEED TO ACCEPT THIS...


	FIX2_OS2_TNUMBER += ECX;
	EDX ^= EDX;

	WPTR [EDI+EBX] = DX;
	goto DI_1011;

LOC_10_DEBUG_A:
	EAX >>>= 4;
LOC_10_DEBUG:
	WPTR [EDI+EBX] = AX;

	return;

    }
    else
    {
	EAX = FIX2_OS2_TNUMBER;
	WPTR [EDI+EBX] = AX;
	return;

    }

}


LOC_10_REAL()
{



	CX = WPTR [EDI+EBX];
	EAX = FIX2_FFRAME;

	EAX >>>= 4;
	DL = FIX2_TTYPE;

	EAX += ECX;
	DL &= MASK SEG_RELOC;

	WPTR [EDI+EBX] = AX;

	// IF RELOCATABLE, CALL HANDLER...


		JZ	LOC_10_RET

	DL = FIX2_SEG_TYPE;
		GETT	CL,OUTPUT_COM_SYS

	DL &= MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1;
	// SKIP IF DEBUG RECORD
		JNZ	LOC_10_RET

	if (CL & CL)
		JNZ	BASE_ERROR

	// TARGET PARAGRAPH
	EDX = EAX;
	EDI += EBX;

	EDX &= 0FFFFH;
	// TRUE ONLY FOR /EXEPACK?
		GETT	AL,CHAINING_RELOCS

	// REAL-MODE (8) BASE (2)
	ECX = 802H;
	AL |= AL;

	EAX = EBX;
		JNZ	L1$
	// REAL-MODE(8) ADDITIVE(4)
	CH = 12;
L1$:
	ESI = FIX2_LDATA_LOC;
	// TARGET SEGMENT OFFSET
	EBX ^= EBX;

	EAX += ESI;

	// ES:DI IS PHYS_PTR

	// AX IS .LW OF OVERALL ADDRESS

	// BX IS TARGET SEGMENT OFFSET

	// CL IS FIXUPP TYPE

	// CH IS FIXUPP FLAGS

	// DX IS TARGET SEGMENT PARAGRAPH


	goto RELOC_INSTALL;

BASE_ERROR:
	AL = BASE_RELOC_ERR;
	FIXUPP_ERROR();
LOC_10_RET:
	return;

}


    version(fg_segm)
    {

IMP_10()
{



	DX = WPTR [EDI+EBX];
	ECX = 002H;

	EDX &= 0FFFFH;
		JZ	L2$

	CH |= 4;
L2$:
	goto DO_IMPORT;

}
    }

    version(fg_segm)
    {
BAD_MYLOC_IMP()
{

	AL = NEAR_IMPORT_ERR;
	FIXUPP_ERROR();
	return;

}
    }

BAD_MYLOC()
{

	AL = UNREC_FIXUPP_ERR;
	FIXUPP_ERROR();
	return;

}


TARG_SEGMOD_NORMAL()
{

	// EAX IS SEGMOD GINDEX


		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

	ECX = [EAX]._SM_START;
	EDX = FIX2_TOFFSET;

	EAX = [EAX]._SM_BASE_SEG_GINDEX;
	EDX += ECX;

	// IN CASE OF TLS
	FIX2_SEG_GINDEX = EAX;
	FIX2_TOFFSET = EDX;

		CONVERT	EAX,EAX,SEGMENT_GARRAY
		ASSUME	EAX:PTR SEGMENT_STRUCT

	ECX = [EAX]._SEG_OS2_NUMBER;
	EDX = [EAX]._SEG_OS2_FLAGS;

	FIX2_OS2_TNUMBER = ECX;
	FIX2_OS2_TFLAGS = EDX;

	AL = [EAX]._SEG_TYPE;
	EDX |= EDX;

	return;

}


TARG_SEGMOD_CV()
{

	// EAX IS SEGMOD GINDEX


		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		PUSH	EDI
	EDI = [EAX]._SM_BASE_SEG_GINDEX;
		CONVERT	EDI,EDI,SEGMENT_GARRAY
		ASSUME	EDI:PTR SEGMENT_STRUCT

		PUSH	EBX
	// OFFSET FROM FRAME
	ECX = [EAX]._SM_START;

	EBX = [EDI]._SEG_CV_NUMBER;
	EDX = [EDI]._SEG_OFFSET;

	FIX2_TFRAME_SEG = EBX;
	// NEED JUST OFFSET FROM SEGMENT_GINDEX
	ECX -= EDX;

    version(fg_cvpack)
    {
	DL = FIX2_SEG_TYPE;
		GETT	BL,CVPACK_FLAG

	DL &= MASK SEG_CV_SYMBOLS1;
	BH = [EAX]._SM_FLAGS;

	DL &= BL;
		JZ	L1$

	BH &= MASK SEG_CLASS_IS_CODE;
		JZ	L1$

	// CODESEG, $$SYMBOLS, CVPACK.  IF IT AIN'T MY CODESEG, ADD 8000H TO NUMBER


		PUSH	ECX
	// EAX IS SEGMOD PHYSICAL, RETURN EAX IS PARENT MODULE GINDEX
	GET_SM_MODULE();

		POP	ECX
	EBX = CURNMOD_GINDEX;

	if (EBX == EAX)
		goto L1$;

	FIX2_TFRAME_SEG |= 8000H;
L1$:
    }
	EDX = FIX2_TOFFSET;
	AL = [EDI]._SEG_TYPE;

	ECX += EDX;
	// CLEAR CARRY
	EBX ^= EBX;

	FIX2_OS2_TFLAGS = EBX;
	FIX2_TOFFSET = ECX;

		POPM	EBX,EDI

	return;

}


    version(fg_pe)
    {

TARG_SEGMOD_CV32()
{

	// EAX IS SEGMOD GINDEX


		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		PUSH	EDI
	EDI = [EAX]._SM_BASE_SEG_GINDEX;
		CONVERT	EDI,EDI,SEGMENT_GARRAY
		ASSUME	EDI:PTR SEGMENT_STRUCT

		PUSH	EBX
	// OFFSET FROM FRAME
	ECX = [EAX]._SM_START;

	EDX = [EDI]._SEG_PEOBJECT_NUMBER;
	// FRAME IS SEGMENT_GINDEX
	FIX2_TFRAME_SEG = EDX;
    version(fg_cvpack)
    {
	DL = FIX2_SEG_TYPE;
		GETT	BL,CVPACK_FLAG

	DL &= MASK SEG_CV_SYMBOLS1;
	BH = [EAX]._SM_FLAGS;

	DL &= BL;
		JZ	L1$

	BH &= MASK SEG_CLASS_IS_CODE;
		JZ	L1$

	// CODESEG, $$SYMBOLS, CVPACK.  IF IT AIN'T MY CODESEG, ADD 8000H TO NUMBER


		PUSH	ECX
	GET_SM_MODULE();

	EBX = CURNMOD_GINDEX;
		POP	ECX

	if (EBX == EAX)
		goto L1$;

	FIX2_TFRAME_SEG |= 8000H;
L1$:
    }
	EDX = [EDI]._SEG_PEOBJECT_GINDEX;
	EAX = PE_BASE;

	if (EDX & EDX)
		JZ	L9$

		CONVERT	EDX,EDX,PE_OBJECT_GARRAY
		ASSUME	EDX:PTR PE_OBJECT_STRUCT

	ECX -= EAX;
	// NEED JUST OFFSET FROM SEGMENT_GINDEX
	EAX = [EDX]._PEOBJECT_RVA;

	EDX = FIX2_TOFFSET;
	ECX -= EAX;

	ECX += EDX;
	AL = [EDI]._SEG_TYPE;

	FIX2_TOFFSET = ECX;
	// CLEAR CARRY
	AH |= AH;
L9$:

		POPM	EBX,EDI

	FIX2_OS2_TFLAGS = 0;

	return;

}

    }

TARG_GROUP_NORMAL()
{

	// EAX IS GROUP GINDEX


		CONVERT	EAX,EAX,GROUP_GARRAY
		ASSUME	EAX:PTR GROUP_STRUCT

	EDX = [EAX]._G_FIRST_SEG_GINDEX;
	ECX = [EAX]._G_OFFSET;

	FIX2_SEG_GINDEX = EDX;
	EDX = FIX2_TOFFSET;

	EDX += ECX;
	ECX = [EAX]._G_OS2_NUMBER;

	FIX2_TOFFSET = EDX;
	EDX = [EAX]._G_OS2_FLAGS;

	FIX2_OS2_TNUMBER = ECX;
	FIX2_OS2_TFLAGS = EDX;

	// FOR CHECKING RELOC VS ASEG
	AL = [EAX]._G_TYPE;
	// CLEAR CARRY
	ECX |= ECX;

	return;

}


TARG_GROUP_CV()
{

	// EAX IS GROUP GINDEX



	// CODEVIEW DOESN'T SUPPORT GROUP STUFF...
		CONVERT	EAX,EAX,GROUP_GARRAY
		ASSUME	EAX:PTR GROUP_STRUCT

	ECX = [EAX]._G_FIRST_SEG_GINDEX;
	AL = [EAX]._G_TYPE;

	if (ECX & ECX)
		JZ	L1$

		CONVERT	ECX,ECX,SEGMENT_GARRAY
		ASSUME	ECX:PTR SEGMENT_STRUCT
	ECX = [ECX]._SEG_CV_NUMBER;
L1$:
	EDX ^= EDX;

	FIX2_TFRAME_SEG = ECX;
	FIX2_OS2_TFLAGS = EDX;

	return;

}


    version(fg_pe)
    {

TARG_GROUP_CV32()
{

	// EAX IS GROUP GINDEX


		CONVERT	EAX,EAX,GROUP_GARRAY
		ASSUME	EAX:PTR GROUP_STRUCT

	ECX = [EAX]._G_FIRST_SEG_GINDEX;
	// FOR CHECKING RELOC VS ASEG
	AL = [EAX]._G_TYPE;

	if (ECX & ECX)
		JZ	L1$

		CONVERT	ECX,ECX,SEGMENT_GARRAY
		ASSUME	ECX:PTR SEGMENT_STRUCT

	ECX = [ECX]._SEG_PEOBJECT_NUMBER;
L1$:
	// CLEAR CARRY
	EDX ^= EDX;

	FIX2_OS2_TFLAGS = EDX;
	FIX2_TFRAME_SEG = ECX;

	return;

}

    }

TARG_ASEG_NORMAL()
{
TARG_ASEG_CV::

	// EAX IS PARAGRAPH - SELECTOR FOR SEGM MODE


    version(fg_segm)
    {
		GETT	CL,OUTPUT_SEGMENTED
	EDX ^= EDX;

	if (CL & CL)
		JNZ	L5$
    }
	EAX <<= 4;
	ECX = FIX2_TOFFSET;

	ECX += EAX;
	FIX2_OS2_TNUMBER = EAX;

	FIX2_TOFFSET = ECX;
	FIX2_OS2_TFLAGS = EDX;

	AL = MASK SEG_ASEG;
	// CLEAR CARRY
	ECX |= ECX;

	FIX2_SEG_GINDEX = EDX;

	return;

    version(fg_segm)
    {
L5$:
	FIX2_OS2_TNUMBER = EAX;
	FIX2_OS2_TFLAGS = EDX;

	AL = MASK SEG_ASEG;
	ECX |= ECX;
	return;
    }

}


TARG_EXTERNAL_CV()
{

	// EAX IS SYMBOL GINDEX


		CONVERT	EAX,EAX,SYMBOL_GARRAY
		ASSUME	EAX:PTR SYMBOL_STRUCT

	EDX ^= EDX;
	CL = [EAX]._S_NSYM_TYPE;

	EBX = [EAX]._S_SEG_GINDEX;
	FIX2_OS2_TFLAGS = EDX;

	if (EBX & EBX)
		JZ	L1$

		CONVERT	EBX,EBX,SEGMENT_GARRAY
		ASSUME	EBX:PTR SEGMENT_STRUCT

	EDX = [EBX]._SEG_CV_NUMBER;
	// TOTAL OFFSET
	EDI = [EAX]._S_OFFSET;
L1$:
	FIX2_TFRAME_SEG = EDX;

	// NORMALLY RELOC
	if (CL == NSYM_RELOC)
		goto L2$;
	if (CL == NSYM_CONST)
		goto L3$;
	if (CL != NSYM_ASEG)
		goto L8$;
L2$:
    version(fg_cvpack)
    {
	EAX = [EAX]._S_DEFINING_MOD;
	EDX = CURNMOD_GINDEX;

	if (EDX == EAX)
		goto L25$;

		GETT	AL,CVPACK_FLAG
	DL = FIX2_SEG_TYPE;

	AL |= AL;
		JZ	L25$

	DL &= MASK SEG_CV_SYMBOLS1;
		JZ	L25$

	FIX2_TFRAME_SEG |= 8000H;
L25$:

    }

	// USE NORMAL ADDRESS


	// NEED OFFSET FROM GINDEX
	EDI -= [EBX]._SEG_OFFSET;
L3$:
	ECX &= NSYM_ANDER;
	EAX = FIX2_TOFFSET;

	ECX >>>= 1;
	EAX += EDI;

	FIX2_TOFFSET = EAX;

	AL = FIX2_EXT_TYPE_XLAT[ECX];

	return;

L8$:
	[EAX]._S_REF_FLAGS |= MASK S_REFERENCED;

		STC

	return;

}


    version(fg_pe)
    {

TARG_EXTERNAL_CV32()
{

	// EAX IS SYMBOL GINDEX


		CONVERT	EAX,EAX,SYMBOL_GARRAY
		ASSUME	EAX:PTR SYMBOL_STRUCT

	EDX ^= EDX;
	CL = [EAX]._S_NSYM_TYPE;

	EBX = [EAX]._S_SEG_GINDEX;
	FIX2_OS2_TFLAGS = EDX;

	if (EBX & EBX)
		JZ	L1$

		CONVERT	EBX,EBX,SEGMENT_GARRAY
		ASSUME	EBX:PTR SEGMENT_STRUCT

	EDX = [EBX]._SEG_PEOBJECT_NUMBER;
	EBX = [EBX]._SEG_PEOBJECT_GINDEX;
L1$:
	EDI = [EAX]._S_OFFSET;
	FIX2_TFRAME_SEG = EDX;

	// NORMALLY RELOC
	if (CL == NSYM_RELOC)
		goto L2$;

	if (CL == NSYM_CONST)
		goto L3$;

	if (CL != NSYM_ASEG)
		goto L8$;
L2$:
    version(fg_cvpack)
    {
	EAX = [EAX]._S_DEFINING_MOD;
	EDX = CURNMOD_GINDEX;

	if (EDX == EAX)
		goto L25$;

		GETT	AL,CVPACK_FLAG
	DL = FIX2_SEG_TYPE;

	AL |= AL;
		JZ	L25$

	DL &= MASK SEG_CV_SYMBOLS1;
		JZ	L25$

	FIX2_TFRAME_SEG |= 8000H;
L25$:

    }

	// USE NORMAL ADDRESS


		CONVERT	EBX,EBX,PE_OBJECT_GARRAY
		ASSUME	EBX:PTR PE_OBJECT_STRUCT

	EDX = [EBX]._PEOBJECT_RVA;
	EBX = PE_BASE;

	EDI -= EDX;

	EDI -= EBX;

L3$:
	ECX &= NSYM_ANDER;
	EAX = FIX2_TOFFSET;

	ECX >>>= 1;
	EAX += EDI;

	FIX2_TOFFSET = EAX;

	AL = FIX2_EXT_TYPE_XLAT[ECX];

	return;

L8$:
	[EAX]._S_REF_FLAGS |= MASK S_REFERENCED;

		STC

	return;

}

    }


TARG_EXTERNAL_NORMAL()
{

	// EAX IS SYMBOL GINDEX


		CONVERT	EAX,EAX,SYMBOL_GARRAY

	ECX = DPTR [EAX]._S_NSYM_TYPE;
		GETT	DL,OUTPUT_SEGMENTED

    version(fg_segm OR fg_pe)
    {
	if (CL == NSYM_IMPORT)
	// IMPORTED
		goto L5$;
    }

	if (CL == NSYM_RELOC)
		goto L2$;

    version(fg_segm)
    {
	CH &= MASK S_FLOAT_SYM;
		JNZ	L6$
L61$:
    }
	if (CL == NSYM_CONST)
		goto L39$;

	if (CL == NSYM_ASEG)
		goto L39$;

	[EAX]._S_REF_FLAGS |= MASK S_REFERENCED;

	FIX2_OS2_TFLAGS = 0;

		STC

	return;

L2$:
L39$:
	EDX = [EAX]._S_SEG_GINDEX;
	// TOTAL OFFSET FROM SEGMENT
	EBX = [EAX]._S_OFFSET;

	FIX2_SEG_GINDEX = EDX;
	EDX = FIX2_TOFFSET;

	ECX &= NSYM_ANDER;
	EDX += EBX;

	ECX >>>= 1;
	EBX = [EAX]._S_OS2_NUMBER;

	FIX2_TOFFSET = EDX;
	EDI = [EAX]._S_OS2_FLAGS;

    version(fg_pe OR fg_segm)
    {
		GETT	AL,OUTPUT_PE
		GETT	DL,OUTPUT_SEGMENTED

	AL |= DL;
		JNZ	L41$
    }

	// THIS ZEROS DX FIRST...
	EBX <<= 4;
L41$:
	FIX2_OS2_TFLAGS = EDI;
	FIX2_OS2_TNUMBER = EBX;

	EBX |= EBX;
	AL = FIX2_EXT_TYPE_XLAT[ECX];
	return;

    version(fg_segm OR fg_pe)
    {

L5$:
    version(fg_pe)
    {
		GETT	DH,OUTPUT_PE
	CL = NSYM_RELOC;

	if (DH & DH)
		JNZ	L2$
    }

	// TARGET IS AN IMPORTED SYMBOL...


	EDX ^= EDX;
	CH &= MASK S_IMP_ORDINAL;

	// NAME OFFSET
	ECX = [EAX]._S_IMP_NOFFSET;
		JZ	L53$

	++EDX;
	ECX = [EAX]._S_IMP_ORDINAL;
L53$:
	// MODULE #
	EBX = [EAX]._S_IMP_MODULE;
	FIX2_IMP_OFFSET = ECX;

	FIX2_IMP_MODULE = EBX;
	// MARK IT IMPORTED (AVAILABLE FLAG...)
	EBX = MASK SR_1;

	FIX2_IMP_FLAGS = EDX;
	FIX2_OS2_TFLAGS = EBX;

	AL = MASK SEG_RELOC;
	// CLEAR CARRY
	ECX |= ECX;

	return;

    }

    version(fg_segm)
    {

L6$:

    version(fg_norm_exe)
    {
	// OUTPUT_SEGMENTED
	if (DL & DL)
		JZ	L61$
    }
	AL = BPTR [EAX]._S_FLOAT_TYPE;
    version(fg_winpack)
    {
		GETT	DL,WINPACK_SELECTED
    }
	EAX &= 7;
	// JUST USE ZEROS
		JZ	L7$
    version(fg_winpack)
    {
	if (AL != 6)
		goto L65$;
	if (DL & DL)
		JNZ	L67$
L65$:
    }
	ECX ^= ECX;
	// BASE.LW OR FIX2_IMP_OFFSET
	FIX2_IMP_OFFSET = EAX;

	// BASE.HW OR FIX2_IMP_MODULE
	FIX2_IMP_MODULE = ECX;
	// AVAILABLE FLAG...
	EAX = MASK SR_1;

	// OS2_NUMBER (IMPORT_FLAGS)
	FIX2_IMP_FLAGS = ECX;
	// MARK IT IMPORTED FOR SPECIAL TREATMENT
	FIX2_OS2_TFLAGS = EAX;

	AL = MASK SEG_CONST;

	return;

    version(fg_winpack)
    {
L67$:
	ECX = 0A23DH;
	// BASE.LW OR FIX2_IMP_OFFSET
	FIX2_IMP_OFFSET = EAX;

	FIX2_TOFFSET = ECX;
	EAX ^= EAX;

	goto L8$;

    }
L7$:
	// BASE.LW OR FIX2_IMP_OFFSET
	FIX2_IMP_OFFSET = EAX;
L8$:
	// IGNORE THESE AS CONSTANT ZERO
	FIX2_OS2_TNUMBER = EAX;
	FIX2_OS2_TFLAGS = EAX;
	AL = MASK SEG_CONST;
	return;

    }

}


FRAME_LOC()
{



	EAX = FIX2_LDATA_SEGMENT_GINDEX;

}


FRAME_SEGMENT()
{

	// EAX IS GINDEX OF A SEGMENT


		CONVERT	EAX,EAX,SEGMENT_GARRAY
		ASSUME	EAX:PTR SEGMENT_STRUCT

	ECX = [EAX]._SEG_OS2_NUMBER;
	// 		MOV	EDX,[EAX]._SEG_OS2_FLAGS


	AL = [EAX]._SEG_TYPE;
	// CLEAR CARRY
	EBX |= EBX;

	return;

}


FRAME_GROUP()
{

	// EAX IS GINDEX OF GROUP


		CONVERT	EAX,EAX,GROUP_GARRAY
		ASSUME	EAX:PTR GROUP_STRUCT

	ECX = [EAX]._G_OS2_NUMBER;
	// 		MOV	EDX,[EAX]._G_OS2_FLAGS


	AL = [EAX]._G_TYPE;
	// CLEAR CARRY
	EBX |= EBX;

	return;

}


FRAME_ABSOLUTE()
{



	ECX = EAX;
    version(fg_segm)
    {
		GETT	AL,OUTPUT_SEGMENTED

	AL |= AL;
		JNZ	L5$
    }
	ECX <<= 4;
L5$:

	AL = MASK SEG_ASEG;
	// CLEAR CARRY
	EDX |= EDX;

	return;

}


FRAME_EXTERNAL()
{

	// THIS SHOULD BE SUPER-RARE?


		CONVERT	EAX,EAX,SYMBOL_GARRAY
		ASSUME	EAX:PTR SYMBOL_STRUCT

	EDX = DPTR [EAX]._S_NSYM_TYPE;
    version(fg_segm)
    {
	if (DL == NSYM_IMPORT)
	// IMPORTED, USE ASEG ZERO
		goto L5$;

	DH &= MASK S_FLOAT_SYM;
		JNZ	L5$
L61$:
    }
	if (DL == NSYM_RELOC)
		goto L2$;

	if (DL == NSYM_CONST)
		goto L39$;

	if (DL == NSYM_ASEG)
		goto L39$;

	[EAX]._S_REF_FLAGS |= MASK S_REFERENCED;

		STC

	return;

L5$:
	ECX ^= ECX;
	AL = MASK SEG_CONST+MASK SEG_ASEG;

	return;

L2$:
L39$:
	EDX &= NSYM_ANDER;
	ECX = [EAX]._S_OS2_NUMBER;

	EDX >>>= 1;
    version(fg_segm)
    {
		GETT	AL,OUTPUT_SEGMENTED

	AL |= AL;
		JNZ	L41$
    }
	ECX <<= 4;
L41$:

	AL = FIX2_EXT_TYPE_XLAT[EDX];
	ECX |= ECX;

	return;

}


FRAME_TARG()
{



	AL = FIX2_TTYPE;
	ECX = FIX2_OS2_TNUMBER;

	// 		MOV	EDX,FIX2_OS2_TFLAGS

	// CLEAR CARRY
	EAX |= EAX;

	return;

}

    version(fg_segm)
    {

DO_IMPORT()
{

	// TARGET STUFF IS AN IMPORT SYMBOL, CH IS FLAGS, CL IS FIXTYPE


	// IF ADDITIVE, INSERT A NEW REFERENCE, ELSE TRY LINK LIST


	// MUST IT BE ADDITIVE?


	EAX = FIX2_IMP_FLAGS;
	DL = 2;

	// ZERO IS IMPORT-BY-NAME
	if (AL & AL)
		JZ	L1$

	// MUST BE IMPORT BY NUMBER
	--EDX;
L1$:
	EDI += EBX;
	CH |= DL;

	EAX = FIX2_LDATA_LOC;
	EDX = FIX2_IMP_MODULE;

	// TARGET LOGICAL ADDRESS
	EAX += EBX;
	EBX = FIX2_IMP_OFFSET;

	// ES:DI IS PHYS_PTR

	// AX IS OFFSET IN SEGMENT

	// BX IS _RL_IMP_OFFSET

	// CL IS FIXUPP TYPE

	// CH IS FIXUPP FLAGS

	// DX IS _RL_IMP_MODULE


	// DO RELOCATION
	goto RELOC_INSTALL;

}

    }

    version(fg_segm)
    {

DO_INTERNAL()
{

	// TARGET STUFF IS AN INTERNAL, CH IS FLAGS, CL IS FIXTYPE


	EDI += EBX;
	EDX ^= EDX;

		XCHG	DX,WPTR [EDI]

	EAX += EDX;
	EDX = FIX2_LDATA_LOC;

	EBX += EDX;
	EDX = EAX;

	EAX = EBX;
	EBX = EDX;

	EDX = FIX2_OS2_TNUMBER;

	// ES:DI IS PHYS_PTR

	// AX IS OFFSET IN SEGMENT

	// BX IS TARGET SEGMENT OFFSET

	// CL IS FIXUPP TYPE

	// CH IS FIXUPP FLAGS

	// DX IS TARGET SEGMENT #


	// DO RELOCATION
	goto RELOC_INSTALL;

}

    }

RELOCATION_CHECK()
{

	// EAX IS ADDRESS


		PUSH	EBX
	DL = FIX2_LD_TYPE;

	DL &= MASK BIT_LI;
		JNZ	L9$

	ECX = DPTR FIX2_LD_LENGTH;
		POP	EBX

	ECX &= 0FFFFH;

public REL_CHK_LIDATA	LABEL	PROC

	// EAX IS STARTING ADDRESS, ECX IS NUMBER OF BYTES



	// QUICK CHECK WOULD BE IF BX:AX IS ABOVE RELOC_HIGH_WATER


		PUSH	EBX

	EDX = FIX2_STACK_DELTA;
	EBX = FIX2_SM_START;

	EAX += EDX;
	EDX = RELOC_HIGH_WATER;

	EAX -= EBX;
	EBX = FIRST_RELOC_GINDEX;

	if (EDX BE EAX)
		goto L9$;

	// SEE IF THIS OVERLAPS ANY RELOCATION RECORDS


	if (EBX & EBX)
	// HOME FREE, NO RELOCS THIS SEGMENT
		JZ	L9$

	// MORE DIFFICULT, NEED TO CHECK BITMAP...

	// AX IS FIRST BIT TO CHECK, FIX2_LD_LENGTH IS PROBABLY #

	// OF BITS TO CHECK


		POP	EBX

public SPECIAL_RELOC_CHECK	LABEL	PROC

	// AX IS FIRST BIT TO CHECK, CX IS NUMBER OF BITS


		PUSHM	EBX,EDI

		PUSH	EAX
	EBX = EAX;

	EAX >>>= 3;
	EDI = RELOC_BITS;

		PUSH	ECX
	EDI += EAX;

	// DI IS BIT #

	// CX IS # OF BITS


	// GET TO A BYTE BOUNDARY


	EBX &= 7;
	// ALREADY A BYTE BOUNDARY
		JZ	L55$

	EAX = EBX;
	EBX = ECX;

	ECX = EAX;
	AL = [EDI];

	AL >>>= CL;

	CL -= 8;
	++EDI;

	// # OF BITS TO CHECK IN THIS BYTE
		NEG	CL
L51$:
	--EBX;
		JS	L8$

	AL >>>= 1;
		JC	L7$

	--ECX;
		JNZ	L51$

	ECX = EBX;
L55$:
	EDX = ECX;
	EAX ^= EAX;

	// CX IS # OF BYTES TO CHECK
	ECX >>>= 3;
		JZ	L551$

		REPE	SCASB
L551$:
	AL = [EDI];
		JNZ	L7$

	AL |= AL;
		JZ	L8$

	// # OF BITS TO CHECK
	EDX &= 7;
		JZ	L8$
L56$:
	AL >>>= 1;
		JC	L7$

	--EDX;
		JNZ	L56$
L8$:
		POPM	ECX,EAX

		POP	EDI
L9$:
		POP	EBX

	return;

L7$:

	// PRESERVE DS:SI


	// CONFLICT WITH PREVIOUS RELOCATIONS...


	ECX = FIX2_LDATA_SEGMENT_GINDEX;
	AL = RELOC_CONFLICT_ERR;
		CONVERT	ECX,ECX,SEGMENT_GARRAY
		ASSUME	ECX:PTR SEGMENT_STRUCT

	ECX += SEGMENT_STRUCT._SEG_TEXT;
	ERR_ASCIZ_RET();
	goto L8$;

}


void DO_FARCALL_FIXUPPS()
{

	// THIS IS LIST OF POSSIBLE FARCALLTRANSLATIONS


	EAX ^= EAX;

	FIX2_LDATA_BASE = EAX;
	LDATA_SEGMOD_GINDEX = EAX;

	FIX2_LDATA_SEGMENT_GINDEX = EAX;
	FIXUPP_COUNT = EAX;

	if (FIRST_FARCALL == EAX)
		goto L91$;
    version(debug)
    {
	EAX = OFF FARCALL_MSG;
	SAY_VERBOSE();
    }

	ESI = FIRST_FARCALL;

L1$:
	if (ESI & ESI)
		JZ	L9$
L2$:
	EDI = OFF FIX2_FIXUPP_STUFF;
		ASSUME	ESI:PTR FARCALL_HEADER_TYPE
		ASSUME	EDI:PTR FARCALL_HEADER_TYPE
	ECX = [ESI]._FC_NEXT_FARCALL;

	EAX = [ESI]._FC_SEGMOD_GINDEX;
	[EDI]._FC_NEXT_FARCALL = ECX;

	[EDI]._FC_SEGMOD_GINDEX = EAX;
	EAX = [ESI]._FC_LENGTH;

	ECX = [ESI]._FC_BLOCK_BASE;
	ESI += SIZEOF FARCALL_HEADER_TYPE;

	[EDI]._FC_LENGTH = EAX;
	[EDI]._FC_BLOCK_BASE = ECX;

		ASSUME	ESI:NOTHING,EDI:NOTHING

	EAX += ESI;
	FIX2_LDATA_BASE = ECX;

	FIX2_FIXUPP_EOR = EAX;

	// SET UP SEGMENT, ETC


	EAX = FIX2_FC_SEGMOD_GINDEX;
	ECX = LDATA_SEGMOD_GINDEX;

	if (ECX != EAX)
		goto L4$;
L51$:
	DO_FF_1();
L56$:
	ESI = FIX2_FH_NEXT_FIXUPP;
	EAX = FIX2_LDATA_BASE;

	if (ESI & ESI)
		JZ	L8$

		ASSUME	ESI:PTR FARCALL_HEADER_TYPE
	ECX = [ESI]._FC_BLOCK_BASE;

	if (EAX == ECX)
		goto L2$;

	if (EAX & EAX)
		JZ	L1$

	RELEASE_BLOCK();
	goto L1$;

L8$:
	RELEASE_BLOCK();

L9$:
    version(debug)
    {

	EAX = OFF FARCALLFINI_MSG;
	SAY_VERBOSE();
    }
L91$:
	EAX = FIXUPP_COUNT;
	ECX = FIRST_SECTION_GINDEX;

	if (EAX & EAX)
		JZ	L99$

		CONVERT	ECX,ECX,SECTION_GARRAY
		ASSUME	ECX:PTR SECTION_STRUCT

	[ECX]._SECT_RELOCS -= EAX;

L99$:
	return;

L4$:

	// SEGMOD CHANGED


		PUSH	ESI
	LDATA_SEGMOD_GINDEX = EAX;

		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

	ESI = EAX;
		ASSUME	ESI:PTR SEGMOD_STRUCT
	GET_SM_MODULE();

		GETT	CL,ENTRIES_POSSIBLE
	CURNMOD_GINDEX = EAX;

	CL |= CL;
		JNZ	L45$
L44$:
	AL = [ESI]._SM_PLTYPE;

	if (AL & MASK LEVEL_0_SECTION)
		JZ	L55$
L45$:
	EAX = [ESI]._SM_BASE_SEG_GINDEX;
	ECX = FIX2_LDATA_SEGMENT_GINDEX;

	// SKIP IF FROM AN UNREFERENCED COMDAT...
	if (EAX & EAX)
		JZ	L55$

	if (ECX == EAX)
		goto L52$;
L5$:
	FIX2_LDATA_SEGMENT_GINDEX = EAX;
		CONVERT	ESI,EAX,SEGMENT_GARRAY
		ASSUME	ESI:PTR SEGMENT_STRUCT

	EDI = OFF FIX2_SEGMENT_STUFF;
	ECX = (SIZE SEGMENT_STRUCT+3)/4;

		REP	MOVSD

		ASSUME	ESI:NOTHING

L52$:
    version(fg_segm)
    {
		GETT	CL,ENTRIES_POSSIBLE
		POP	ESI

		GETT	DL,PROTMODE
	EAX = FIX2_SEG_OS2_FLAGS;

	CL |= CL;
		JZ	L51$

	// HMM, THIS IS FOR PENTS


	DL |= DL;
		JZ	L51$

	// IGNORE IF ITS A COMDAT THAT BECAME IOPL-NONCONFORMING-CODE


	if (EAX & MASK SR_CONF+1)
		JNZ	L51$
	if (EAX & 1 SHL SR_DPL)
		JZ	L51$

    }

L55$:
	EAX ^= EAX;
		POP	ECX

	LDATA_SEGMOD_GINDEX = EAX;
	goto L56$;

}


DO_FF_1()
{



	EAX = [ESI];
	ESI += 4;

	EAX &= 0xFFFF;
	PARSE_FIXUPP2(EAX, ESI);

		GETT	AL,ENTRIES_POSSIBLE
		JC	L8$
    version(fg_segm)
    {
	AL |= AL;
		JZ	L3$

	EAX = [ESI];
	ESI += 4;

	LATEST_PENT_GINDEX = EAX;
L3$:

    }

	// SO, GO AHEAD AND DO FIXUPP


    version(fg_segm)
    {
		GETT	AL,OUTPUT_SEGMENTED

	AL |= AL;
		JZ	L5$

	EAX = FIX2_OS2_TNUMBER;
	ECX = FIX2_SEG_OS2_NUMBER;

	if (ECX != EAX)
		goto L7$;
	goto L6$;
    }

L5$:

	// FRAME MUST MATCH FRAME OF LDATA_LOC


	EAX = FIX2_SEG_FRAME;
	EBX = FIX2_FFRAME;

	if (EAX != EBX)
		goto L7$;

	if (EAX != FIX2_TFRAME)
		goto L7$;
L6$:
	++FIXUPP_COUNT;
    version(fg_segm)
    {
	EAX = LATEST_PENT_GINDEX;

	if (EAX & EAX)
		JZ	L7$

		CONVERT	EAX,EAX,PENT_GARRAY
		ASSUME	EAX:PTR PENT_STRUCT

	--[EAX]._PENT_REF_COUNT;

    }
L7$:
	if (FIX2_FIXUPP_EOR A$ ESI)
		goto DO_FF_1;

	return;

L8$:
    version(fg_segm)
    {
	AL |= AL;
		JZ	L7$

	ESI += 4;
	goto L7$;

    }

}


RELINK_DATA_BACKWARDS()
{

	// RELINK THIS LIST IN OPPOSITE DIRECTION...


	ESI = FIX2_SM_FIRST_DAT;
		ASSUME	ESI:PTR LDATA_HEADER_TYPE

	EBX ^= EBX;

	if (ESI & ESI)
		JZ	L9$
L1$:
	EAX = [ESI]._LD_NEXT_LDATA;
	[ESI]._LD_NEXT_LDATA = EBX;

	EBX = ESI;
	ESI = EAX;

	if (EAX & EAX)
		JNZ	L1$
L9$:
	FIX2_SM_FIRST_DAT = EBX;
	return;

		ASSUME	ESI:NOTHING

}


    version(any_overlays)
    {

SI_FIXER()
{



	if (SI AE PAGE_SIZE)
		goto 1$;
	return;

1$:
	SI -= PAGE_SIZE-BLOCK_BASE;
	DS = DX;
		SYM_CONV_DS
	return;

}

    }


HANDLE_START_ADDRESS()
{

	// HANDLE START ADDRESS FIXUPP IF THERE, WARN IF MISSING...


	ESI = MODEND_ADDRESS;
	ESI |= ENTRYPOINT_GINDEX;
    version(debug)
    {
		JZ	L0$
	EAX = OFF START_MSG;
	SAY_VERBOSE();
L0$:
	if (ESI & ESI)
    }
		JZ	L5$

	DOING_START_ADDRESS = -1;

	EAX = MODEND_OWNER_GINDEX;
	ECX ^= ECX;

	CURNMOD_GINDEX = EAX;
	// OR RELEASED
	FIX2_FIXUPP_BASE = ECX;

    version(fg_norm_exe)
    {
	FIX2_LDATA_PTR = OFF EXEHEADER._EXE_REG_IP;
    }

	EAX = ENTRYPOINT_GINDEX;

	EAX |= EAX;
		JZ	L1$

	FIX2_TINDEX = EAX;
	ECX ^= ECX;

	FIX2_OFFSET = ECX;
	FIX2_TOFFSET = ECX;

	// SYMBOL
	FIX2_TT = 2;
	// FRAME TARG
	FIX2_FF = 5;
	// 16:16
	FIX2_LOC = 13H;

	TARG_EXTERNAL_NORMAL();

	FIX2_TTYPE = AL;
	FRAME_TARG();

	FIX2_FTYPE = AL;
	FIX2_OS2_FNUMBER = ECX;

	ESI = OFF TEMP_DATA_RECORD;

	// FAKE END OF RECORD
	FIX2_FIXUPP_EOR = ESI;
	goto L14$;

L1$:
	ESI = MODEND_ADDRESS;

	EAX = [ESI];
	ESI += 4;

	EAX += ESI;

	FIX2_FIXUPP_EOR = EAX;
	DOF_PRELIM();


L14$:
	AL = FIX2_TTYPE;

	AL |= FIX2_FTYPE;

	if (AL & MASK SEG_ASEG)
		JZ	L15$
    version(fg_rom)
    {
	if (OUTPUT_ABS)
		JNZ	L15$
    }
	AL = START_ERR;
	ERR_RET();
L15$:
	// NO RELOCATION...
	FIX2_TTYPE = MASK SEG_ASEG;
	FIX2_FTYPE = MASK SEG_ASEG;

	if (SYMBOL_UNDEFINED)
		JZ	L2$
	goto L8$;

L5$:

	// DON'T COMPLAIN IF .DLL


    version(fg_segm OR fg_pe)
    {
	if (FLAG_0C & MASK APPTYPE)
		JNZ	L52$
    }
	AL = NO_START_ERR;
	WARN_RET();
L52$:
	goto L9$;

L2$:
    version(fg_pe)
    {
	if (OUTPUT_PE)
		JZ	L29$
	if (FIX2_OS2_TFLAGS & MASK SR_1)
		JNZ	START_IMPORT
	EAX = FIX2_TOFFSET;
	EAX -= PE_BASE;
	PEXEHEADER._PEXE_ENTRY_RVA = EAX;
	goto L8$;

L29$:
    }

    version(fg_segm)
    {
L3$:
	if (OUTPUT_SEGMENTED)
		JZ	L39$
	// TARGET SEGMENT MUST EQUAL
	EAX = FIX2_OS2_TNUMBER;
	// FRAME SEGMENT
	if (FIX2_OS2_FNUMBER != EAX)
		goto L31$;
	WPTR NEXEHEADER._NEXE_CSIP+2 = AX;

	if (FIX2_OS2_TFLAGS & MASK SR_1)
		JNZ	START_IMPORT
	EAX = FIX2_TOFFSET;
	WPTR NEXEHEADER._NEXE_CSIP = AX;
	goto L8$;

L31$:
	AL = START_CANT_REACH_ERR;
L33$:
	ERR_RET();
	goto L8$;

START_IMPORT:
	AL = START_IMPORT_ERR;
	goto L33$;

L39$:
    }

    version(fg_norm_exe)
    {

L4$:
	if (FARCALLTRANSLATION_FLAG)
		JZ	L41$
		RESS	FARCALLTRANSLATION_FLAG
	DOFIXUPPS_MODEND();
	FARCALLTRANSLATION_FLAG = -1;
	goto L49$;

L41$:
	DOFIXUPPS_MODEND();
L49$:
    }

L8$:
	EAX ^= EAX;
	FIX2_LDATA_PTR = EAX;
	EAX = DPTR EXEHEADER._EXE_REG_IP;
	WM_START_ADDR = EAX;

L9$:
		RESS	DOING_START_ADDRESS
	return;

}


version(fg_segm)
{

RC_STARTER()
{



		GETT	AL,OUTPUT_SEGMENTED
	EDX = SEGMENT_COUNT;

	if (AL & AL)
		JZ	L9$

	if (EDX & EDX)
		JZ	L9$

		MOVZX	EAX,WPTR NEXEHEADER._NEXE_CSIP+2

	ESI = SEGMENT_TABLE_PTR;
	EDI = MASK SR_PRELOAD;

	// OFFSET TO FLAGS
	ESI += SIZEOF SEGTBL_STRUCT+SEGTBL_STRUCT._SEGTBL_FLAGS;

		CONV_EAX_SEGTBL_ECX

	// MARK START SEGMENT AS PRELOAD
	[ECX]._SEGTBL_FLAGS |= EDI;

	if (RC_REORDER)
		JZ	L9$
	RC_PRELOADS = -1;
	if (RC_REORDER_SEGS)
		JZ	L5$
L0$:
	EBX = MASK SR_DISCARD+MASK SR_MOVABLE;
L1$:
	EAX = [ESI];
	ESI += SIZEOF SEGTBL_STRUCT;

	ECX = EAX;
	EAX ^= EBX;

	if (EAX & EBX)
		JZ	L2$

	ECX |= EDI;
	[ESI - SIZEOF SEGTBL_STRUCT] = ECX;
L2$:
	--EDX;
		JNZ	L1$
L9$:
	return;

L5$:
    version(fg_winpack)
    {
	if (WINPACK_SELECTED)
		JNZ	L0$
    }

	// MARK NOTHING PRELOADED


	EDI = NOT MASK SR_PRELOAD;
L6$:
	[ESI] &= EDI;
	ESI += SIZEOF SEGTBL_STRUCT;

	--EDX;
		JNZ	L6$

	return;

}

}


public SELECT_CV4_OUTPUT()
{

	LOC_10 = &LOC_10_PROT;
	LOC_CALLTBL_PTR = &LOC_CALLTBL_PROT;
	return;
}


		.CONST

		ALIGN	4

public FIX2_TARG_TABLE_CV LABEL	DWORD

		DD	TARG_SEGMOD_CV
		DD	TARG_GROUP_CV
		DD	TARG_EXTERNAL_CV
		DD	TARG_ASEG_CV


public FIX2_TARG_TABLE_NORMAL	LABEL	DWORD

		DD	TARG_SEGMOD_NORMAL
		DD	TARG_GROUP_NORMAL
		DD	TARG_EXTERNAL_NORMAL
		DD	TARG_ASEG_NORMAL


version(fg_pe)
{

FIX2_TARG_TABLE_PE	LABEL	DWORD

		DD	TARG_SEGMOD_NORMAL
		DD	TARG_GROUP_NORMAL
		DD	TARG_EXTERNAL_NORMAL
		DD	TARG_ASEG_NORMAL


public FIX2_TARG_TABLE_CV32 LABEL	DWORD

		DD	TARG_SEGMOD_CV32
		DD	TARG_GROUP_CV32
		DD	TARG_EXTERNAL_CV32
		DD	TARG_ASEG_CV

}


FIX2_FRAME_TABLE	LABEL	DWORD

		DD	FRAME_SEGMENT
		DD	FRAME_GROUP
		DD	FRAME_EXTERNAL
		DD	FRAME_ABSOLUTE
		DD	FRAME_LOC
		DD	FRAME_TARG

	// LOC_CALLTBL	LABEL	WORD



    version(fg_prot)
    {

		ALIGN	4

LOC_CALLTBL_PROT	LABEL	DWORD

	// 16-BIT SELF-RELATIVE


		DD	LOC_0_PROT
		DD	LOC_1_PROT
		REPT	6
		DD	BAD_MYLOC
		ENDM
	// 32-BIT SELF-RELATIVE

		DD	BAD_MYLOC
		DD	LOC_32SELF_PROT
		REPT	6
		DD	BAD_MYLOC
		ENDM
	// 16-BIT SEGMENT-RELATIVE

		DD	LOC2_8
		DD	LOC_9
		DD	LOC_10_PROT
		DD	LOC_11_PROT
		DD	LOC2_12
		DD	LOC_13_PROT
		REPT	2
		DD	BAD_MYLOC
		ENDM
	// 32-BIT SEGMENT-RELATIVE

		DD	BAD_MYLOC
		DD	LOC_DWORD_OFFSET
	// TLS
		DD	LOC_DWORD_OFFSET
		DD	LOC_FWORD_PTR_PROT
		DD	BAD_MYLOC
		DD	LOC_DWORD_OFFSET1_PROT
		DD	BAD_MYLOC
		DD	BAD_MYLOC

    }

    version(fg_pe)
    {

		ALIGN	4

LOC_CALLTBL_PE	LABEL	DWORD

	// 16-BIT SELF-RELATIVE


	// 0
		DD	LOC_0_PE
	// 16-BIT SELF-RELATIVE ILLEGAL
		DD	BAD_MYLOC
		REPT	6
		DD	BAD_MYLOC
		ENDM
	// 32-BIT SELF-RELATIVE

	// 8
		DD	BAD_MYLOC
		DD	LOC_32SELF_PE
		REPT	6
		DD	BAD_MYLOC
		ENDM
	// 16-BIT SEGMENT-RELATIVE

	// LO BYTE 	;16
		DD	LOC2_8
	// 16-BIT OFFSET, ???
		DD	LOC_9_PE
	// SEGMENT
		DD	BAD_MYLOC
	// 16:16
		DD	BAD_MYLOC
	// HI BYTE
		DD	LOC2_12
	// 16 BIT OFFSET
		DD	LOC_9_PE
		REPT	2
		DD	BAD_MYLOC
		ENDM
	// 32-BIT SEGMENT-RELATIVE

	// 24
		DD	BAD_MYLOC
		DD	LOC_DWORD_OFFSET_PE
		DD	LOC_DWORD_OFFSET_TLS
	// FWORD 16:32...
		DD	BAD_MYLOC
		DD	BAD_MYLOC
		DD	LOC_DWORD_OFFSET_PE
		DD	BAD_MYLOC
		DD	BAD_MYLOC

    }

    version(fg_norm_exe)
    {

		ALIGN	4

LOC_CALLTBL_REAL	LABEL	DWORD

	// 16-BIT SELF-RELATIVE


		DD	LOC_0_REAL
		DD	LOC_1_REAL
		REPT	6
		DD	BAD_MYLOC
		ENDM
	// 32-BIT SELF-RELATIVE

		DD	BAD_MYLOC
		DD	LOC_32SELF_REAL
		REPT	6
		DD	BAD_MYLOC
		ENDM
	// 16-BIT SEGMENT-RELATIVE

		DD	LOC2_8
		DD	LOC_9
		DD	LOC_10_REAL
		DD	LOC_11_REAL
		DD	LOC2_12
		DD	LOC_13_REAL
		REPT	2
		DD	BAD_MYLOC
		ENDM
	// 32-BIT SEGMENT-RELATIVE

		DD	BAD_MYLOC
		DD	LOC_DWORD_OFFSET
	// TLS
		DD	LOC_DWORD_OFFSET
		DD	LOC_FWORD_PTR_REAL
		DD	BAD_MYLOC
		DD	LOC_DWORD_OFFSET1_REAL
		DD	BAD_MYLOC
		DD	BAD_MYLOC

    }

    version(fg_segm)
    {

		ALIGN	4

IMP_CALLTBL	LABEL	DWORD

	// 16-BIT SELF-RELATIVE		ALL ILLEGAL ON IMPORTS


		REPT	8
		DD	BAD_MYLOC_IMP
		ENDM

	// 32-BIT SELF-RELATIVE		ALL ILLEGAL ON IMPORTS - TODAY


		REPT	8
		DD	BAD_MYLOC_IMP
		ENDM

	// 16-BIT SEGMENT-RELATIVE


		DD	IMP_8
		DD	IMP_9
		DD	IMP_10
		DD	IMP_11
		DD	BAD_MYLOC
	// WIERD...
		DD	IMP_9
		REPT	2
		DD	BAD_MYLOC
		ENDM

	// 32-BIT SEGMENT-RELATIVE


		DD	BAD_MYLOC
		DD	IMP_DWORD_OFFSET
	// tls is not an import...
		DD	IMP_DWORD_OFFSET
		DD	IMP_FWORD_PTR
		DD	BAD_MYLOC
		DD	IMP_DWORD_OFFSET
		DD	BAD_MYLOC
		DD	BAD_MYLOC

    }

FIX2_EXT_TYPE_XLAT	LABEL	BYTE

	// SYM_UNDEFINED
		DB	0
	// SYM_ASEG
		DB	MASK SEG_ASEG
	// SYM_RELOCATABLE
		DB	MASK SEG_RELOC
	// SYM_NEAR_COMMUNAL
		DB	0
	// SYM_FAR_COMMUNAL
		DB	0
	// SYM_HUGE_COMMUNAL
		DB	0
	// SYM_CONST
		DB	MASK SEG_ASEG + MASK SEG_CONST
	// SYM_LIBRARY
		DB	0
	// SYM_IMPORT
		DB	0
	// SYM_PROMISED
		DB	0
	// SYM_UNDEFINED
		DB	0
	// WEAK_eXTRN
		DB	0
	// POS_WEAK
		DB	0
	// LIBRARY_LIST
		DB	0
	// BVIRDEF
		DB	0
	// ALIASED
		DB	0
	// COMDAT
		DB	0
	// WEAK-DEFINED
		DB	0
		DB	10 DUP(?)
	// __imp__
		DB	0
	// UNDECORATED
		DB	0

.ERRNZ	($-FIX2_EXT_TYPE_XLAT)-NSYM_SIZE/2

version(debug)
{

START_MSG		DB	SIZEOF START_MSG-1,'Doing Start Address',0DH,0AH
FARCALL_MSG		DB	SIZEOF FARCALL_MSG-1,'Doing FARCALLTRANSLATION',0DH,0AH
FARCALLFINI_MSG		DB	SIZEOF FARCALLFINI_MSG-1,'Finished FARCALLTRANSLATION',0DH,0AH

}

