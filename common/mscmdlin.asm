		TITLE	CMDLINE - Copyright (c) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	IO_STRUC
		INCLUDE	MODULES
		INCLUDE	EXES

		PUBLIC	PROCESS_POSIT_CMDLINE,SET_TINY,SET_BINARY,GETNST_SLASH,GET_NUMBER16,SET_STACK_1,GET_NUMBER

		;basic command line functions

		EXTERNDEF	TFLAGS:BYTE


		.DATA

		EXTERNDEF	OUTBUF:BYTE,SYMBOL_TEXT:BYTE,RELOAD_BYTE:BYTE,MODEL_FAR_BYTE:BYTE,DEBUG_BYTE:BYTE,CACHE_BYTE:BYTE
		EXTERNDEF	COMPRESS_BYTE:BYTE,CV_INFO_TYPE:BYTE,CODEVIEW_BYTE:BYTE,LAST_DELIM:BYTE,TD_INFO_TYPE:BYTE
		EXTERNDEF	DEBUG_TYPES_SELECTED:BYTE,EXETYPE_FLAG:BYTE,EXETYPE_CMDLINE_FLAG:BYTE

		EXTERNDEF	FILESTUFF_PTR:DWORD,OVERLAY_INTERRUPT_NUMBER:DWORD,RELOAD_DEPTH:DWORD,INPTR1:DWORD,CACHE_ORDER:DWORD
		EXTERNDEF	PLINK_LEVEL:DWORD,DONT_PACK:DWORD,PACKCODE:DWORD,PACKDATA:DWORD,PADCODE:DWORD,PADDATA:DWORD
		EXTERNDEF	SYMBOL_LENGTH:DWORD,FLAG_0C:DWORD,_OUTFILE_GINDEX:DWORD,MAPFILE_GINDEX:DWORD,TOKSTR:DWORD
		EXTERNDEF	CURN_SECTION_GINDEX:DWORD,PACK_DEFAULT_SIZE:DWORD,TLINK_OUTTYPE:DWORD,IMPLIB_PAGESIZE:DWORD
		EXTERNDEF	IMPLIB_FILE_GINDEX:DWORD,IMPLIB_COFF_FILE_GINDEX:DWORD,IMPDEF_FILE_GINDEX:DWORD
		EXTERNDEF	CACHE_REG_TABLE:DWORD,CACHE_UMB_TABLE:DWORD
		EXTERNDEF	CACHE_EMS_TABLE:DWORD,CACHE_XMS_TABLE:DWORD,CURN_OUTFILE:DWORD,SYS_BASE:DWORD,DEFFILE:DWORD
		EXTERNDEF	STACK_SIZE:DWORD,PE_BASE:DWORD,HEAP_SIZE:DWORD,ALIGNMENT:DWORD,ENTRYPOINT_TXT:DWORD

		EXTERNDEF	EXEHEADER:EXE,NEXEHEADER:NEXE,PEXEHEADER:PEXE,NULNAM:NFN_STRUCT,FILNAM:NFN_STRUCT,SRCNAM:NFN_STRUCT
		EXTERNDEF	SYMBOL_TPTR:TPTR_STRUCT

		externdef	PM_TYPES:DWORD

		externdef	PM_STG:byte
		externdef	VIO_STG:byte
		externdef	NOVIO_STG:byte

		externdef	NT_STG:byte
		externdef	OS2_STG:byte
		externdef	WINDOWS_STG:byte
		externdef	DOS_STG:byte
		externdef	DOS4_STG:byte
		externdef	DOSX_STG:byte
		externdef	UNKNOWN_STG:byte

		externdef	FULL_TEXT:byte
		externdef	ADDRESS_TEXT:byte
		externdef	GROUP_TEXT:byte
		externdef	NOGROUP_TEXT:byte

		externdef	NOEXE_TXT:byte
		externdef	I386_TXT:byte


		.CODE	FILEPARSE_TEXT

		externdef	printx:proc
		externdef	_getcmd:proc
		externdef	_set_prompt_mode:proc
		externdef	_res_prompt_mode:proc
		EXTERNDEF	_err_abort:proc,MOVE_FILNAM:PROC,SET_DEFAULTS:PROC,RES_LOGO_OUTPUT:PROC
		EXTERNDEF	RES_ECHO_IND:PROC,NOIGNORECASE_PROC:PROC,HANDLE_RCS:PROC,MOVE_SOURCE_TO_FILNAM:PROC
		EXTERNDEF	ERR_DSSI_SLASH_ABORT:PROC,SET_ECHO_IND:PROC,IGNORECASE_PROC:PROC,_abort:proc,_check_nul:proc
		EXTERNDEF	NOCHECKSUM_PROC:PROC,RET_FALSE:PROC,LOUTALL_CON:PROC,_do_objs:proc
		EXTERNDEF	YYLEX_FILENAME:PROC,PROCESS_FREE_CMDLINE:PROC,SCAN_HELPER:PROC,GETNST:PROC,GET_KEYWORD:PROC
		EXTERNDEF	ERR_SYMBOL_TEXT_ABORT:PROC,VERBOSE_PROC:PROC,ERR_INBUF_ABORT:PROC,HELP_PROC_1:PROC
		EXTERNDEF	SET_REORDER_ALLOWED:PROC,SILENT_PROC:PROC,RES_REORDER_ALLOWED:PROC,_filename_install:proc
		EXTERNDEF	INSTALL_OUTFILE:PROC,_store_filnam:PROC,HANDLE_LIBS:PROC,_do_srcnam:proc,_do_search_library:proc
		EXTERNDEF	DO_NEW_SECTION:PROC,VERIFY_SECTION:PROC,ENDAREA_PROC:PROC,REOPEN_AREA:PROC,LOWERCASE_PROC:PROC
		EXTERNDEF	UPPERCASE_PROC:PROC,CHECKSUM_PROC:PROC,OVLCODEFIRST_PROC:PROC,OVLCODELAST_PROC:PROC
		EXTERNDEF	ERR_SYMBOL_TEXT_RET:PROC,NONULLSDOSSEG_PROC:PROC,NOGROUPSTACK_PROC:PROC,GROUPSTACK_PROC:PROC
		EXTERNDEF	ERRORDELETE_PROC:PROC,NOERRORDELETE_PROC:PROC,ERR_INBUF_RET:PROC,WARN_SYMBOL_TEXT_RET:PROC
		EXTERNDEF	YYLEX_SYMBOL:PROC,FORCE_INSTALL_MODULE:PROC,DOSSEG_PROC:PROC,RC_PROTMODE:PROC,HANDLE_DEFS:PROC
		EXTERNDEF	RES_PACKFUNCTIONS:PROC,SET_PACKFUNCTIONS:PROC,SEE_NEXT:PROC,MOVE_DEFAULT_FLAGS:PROC
		EXTERNDEF	GET_NEXT:PROC,FORCE_SIGNON:PROC,HANDLE_STUB:PROC,GET_NUM_DOT_NUM:PROC
		EXTERNDEF	GET_SYMBOL:PROC,SET_SUBSYSTEM:PROC,SET_SUBSYS_VERSION:PROC

		EXTERNDEF	RCSTUFF:CMDLINE_STRUCT,IMPLIB_STUFF:CMDLINE_STRUCT,IMPDEF_STUFF:CMDLINE_STRUCT
		EXTERNDEF	STUBSTUFF:CMDLINE_STRUCT,RESSTUFF:CMDLINE_STRUCT,OBJSTUFF:CMDLINE_STRUCT,LIBSTUFF:CMDLINE_STRUCT
		EXTERNDEF	EXESTUFF:CMDLINE_STRUCT,MAPSTUFF:CMDLINE_STRUCT,DEFSTUFF:CMDLINE_STRUCT,OVLSTUFF:CMDLINE_STRUCT
		EXTERNDEF	PATHSTUFF:CMDLINE_STRUCT

		EXTERNDEF	CMDLIN_ERR:ABS,MISSING_COLON_ERR:ABS,ILL_NUMBER_ERR:ABS,DUP_CACHE_ERR:ABS,CACHE_VALUE_ERR:ABS
		EXTERNDEF	SECTION_REQ_ERR:ABS,PAREN_NESTING_ERR:ABS,MULTIPLE_RC_ERR:ABS,TLINK_XTRA_ERR:ABS
		EXTERNDEF	CANT_WINPACK_ERR:ABS,DUP_STUB_ERR:ABS


PROCESS_POSIT_CMDLINE	PROC
		;
		;PROCESS A POSITIONAL MS-STYLE CMDLINE
		;
		;NOW, START PARSING THE COMMAND INPUT...
		;
		CALL	PARSE_OBJS
if	fg_plink
		JC	L99$			;COMMAND WAS /FREEFORMAT
endif
		CALL	PARSE_OUTFILE
		CALL	PARSE_MAPFILE
		CALL	PARSE_LIBS
if	fg_segm OR fg_pe
		CALL	PARSE_DEFFILE
		CALL	PARSE_RCS
endif
		RET

if	fg_plink
L99$:
		JMP	PROCESS_FREE_CMDLINE
endif

PROCESS_POSIT_CMDLINE	ENDP


PARSE_OBJS	PROC	NEAR
		;
		;HERE COME OBJS TO LINK
		;
		MOV	FILESTUFF_PTR,OFF OBJSTUFF
		CALL	VERIFY_SECTION
L1$:
		CALL	GETNST_SLASH		;HANDLE ANY SLASH COMMANDS...
		JC	L99$			;COMMAND WAS /FREEFORMAT...
		CMP	AL,','
		JZ	L65$			;OK, GO READ .EXE FILE
		CMP	AL,0DH
		JZ	L4$
		MOV	LAST_DELIM,0
		CMP	AL,'+'
		JZ	L3$			;ALLOWS IGNORING A CR
if	fg_ov
		CMP	AL,'('
		JZ	L5$
		CMP	AL,')'
		JZ	L6$
endif
		CMP	AL,';'
		JZ	L7$
		CMP	AL,1AH
		JZ	L7$
L2$:
		DEC	INPTR1
		RESS	PLUS_FOUND
		MOV	EAX,OFF OBJSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM
		push	EAX
		call	_do_objs
		add	ESP,4
		JMP	L1$

L99$:
		RESS	PLUS_FOUND
		STC
		RET

L65$:
		;
		;GOT A COMMA
		;IF NEXT NON-BLANK IS A CR, DON'T COUNT IT...
		;
		CMP	LAST_DELIM,0DH		;IF LAST DELIMITER WAS A 0DH, SKIP THIS
		JMP	L45$

L4$:
		;
		;FOUND CR
		;
		CMP	LAST_DELIM,','
L45$:
		MOV	LAST_DELIM,0
		JNZ	L46$
if	fg_td
		BITT	TLINK_DEFAULT_MODE
		JNZ	L46$
endif
		JMP	L1$

L46$:
		MOV	LAST_DELIM,AL
		CMP	SRCNAM.NFN_PRIMLEN,0	;IGNORE IF NO .OBJS YET
		JZ	L1$
		BITT	PLUS_FOUND
		PUSHFD
		RESS	PLUS_FOUND
		POPFD
		JZ	L71$
if	fg_td
		CMP	AL,0DH			;PLUS OVERIDES A CR ALWAYS
		JZ	L1$
		BITT	TLINK_DEFAULT_MODE	;IN TLINK MODE, THAT'S ALL IT OVERIDES
		JNZ	L71$
endif
		JMP	L1$

L3$:
		;
		;FOUND +
		;
		SETT	PLUS_FOUND
		JMP	L1$

if	fg_ov

L5$:
		;
		;FOUND (
		;
		BITT	PARSE_IN_OVERLAY	;IF ALREADY IN OVERLAY, ( IS FIRST CHAR OF FILENAME
		JNZ	L2$
		SETT	PARSE_IN_OVERLAY
		CALL	REOPEN_AREA
		CALL	DO_NEW_SECTION		;SETUP NEW SECTION
		OR	FNTBL+')',MASK FNTBL_ILLEGAL
L59$:
		RESS	PLUS_FOUND
		JMP	L1$

L6$:

		;
		; ) IS END OF AN OVERLAY SECTION, UNLESS WE AREN'T IN ONE...
		;
		BITT	PARSE_IN_OVERLAY
		JZ	L61$
		RESS	PARSE_IN_OVERLAY
		AND	FNTBL+')',NOT MASK FNTBL_ILLEGAL
		CALL	ENDAREA_PROC
		JMP	L59$

endif

L7$:
		DEC	INPTR1
L71$:
		RESS	PLUS_FOUND
if	fg_ov
		BITT	PARSE_IN_OVERLAY
		JNZ	L61$
endif
		RET

if	fg_ov
L61$:
		MOV	AL,PAREN_NESTING_ERR
		CALL	ERR_INBUF_ABORT

endif

PARSE_OBJS	ENDP


GETNST_SLASH	PROC
		;
		;
		;
L1$:
		CALL	GETNST
		CMP	AL,'/'
		JZ	L5$
		CMP	AL,'-'
		JZ	L5$
		CLC
		RET

if	fg_td
L3$:
		CALL	PARSE_TLINK_SWITCH
		SETT	SLASH_FOUND
		JMP	L1$
endif

L5$:
		;
		;PROCESS COMMANDS FROM COMMAND LINE...
		;THIS IS JUMP TABLE HANDLER.
		;
		;COMMTBL LOOKS LIKE:
		;COMMTBL	DB	3	;MAX LENGTH OF COMMAND
		;		DB	3	;SIGNIFICANT CHARACTERS
		;		DW	COPROC	;ROUTINE IF THIS COMMAND
		;		DB	'CO:'	;ASCII FOR COMMAND
		;
		;		ETC
		;		ETC
		;DS & ES ARE DGROUP
		;
		RESS	PLUS_FOUND
		MOV	LAST_DELIM,0
		CALL	GET_KEYWORD	;PARSE IT OUT TO UPPER CASE
		XOR	EAX,EAX
		MOV	AL,SYMBOL_TEXT	;FIRST CHAR OF TOKEN
if	fg_td
		BITT	TLINK_SYNTAX
		JNZ	L3$
endif
		SUB	AL,'A'		;DO TABLE LOOKUP ON START
		CMP	AL,'Z'-'A'
		JA	TRY_?

if 1
		mov	EAX, OFF SYMBOL_TEXT
		push	EAX
		call	_getcmd
		add	ESP,4
		test	EAX,EAX
		jz	MS_BAD_CMD
		call	EAX
		SETT	SLASH_FOUND
		JMP	L1$
else
		MOV	ESI,MS_CMD_PTRS[EAX*4]	;START LOOKING HERE
MS_CHECK_NEXT:
		MOV	DL,[ESI]	;MAX LENGTH
		INC	ESI
		AND	EDX,03FH
		JZ	MS_BAD_CMD	;END OF TABLE
		MOV	BL,[ESI]
		INC	ESI		;SIG_CHARS
		MOV	ECX,EDX
		MOV	EAX,ESI
		ADD	ESI,4
		MOV	EDI,OFF SYMBOL_TEXT
		REPE	CMPSB
		JZ	MS_MATCHED
		ADD	ESI,ECX		;ADJUST SI FOR NEXT TOKEN
		CMP	BPTR [EDI-1],CH	;DID WE REACH END OF TOKEN?
		JNZ	MS_CHECK_NEXT	;NO, TRY NEXT
		INC	ECX
		SUB	DL,CL
		CMP	DL,BL		;IS IT AT LEAST MINMATCH LONG?
		JC	MS_CHECK_NEXT
MS_EXEC_THIS:
		push	EAX
		call	printx
		mov	EAX,offset NOIGNORECASE_PROC
		push	EAX
		call	printx
		pop	EAX
		pop	EAX
		CALL	DPTR [EAX]
		SETT	SLASH_FOUND
		JMP	L1$

MS_MATCHED:
		CMP	[EDI],CL
		JNZ	MS_CHECK_NEXT
		JMP	MS_EXEC_THIS
endif

TRY_?:
		CMP	AL,'?'-'A'
		JNZ	MS_BAD_CMD
		JMP	MS_HELP

MS_BAD_CMD:
		;
		;SKIP TO END OF COMMAND...
		;
		MOV	AL,CMDLIN_ERR
		CALL	WARN_SYMBOL_TEXT_RET
		JMP	L1$

GETNST_SLASH	ENDP


PARSE_OUTFILE	PROC	NEAR
		;
		;GET NAME OF OUTPUT FILE (USE FIRST OBJ AS DEFAULT)
		;
		MOV	FILESTUFF_PTR,OFF EXESTUFF
L1$:
		CALL	GETNST_SLASH
		CMP	AL,'+'
		JZ	L1$			;YEA, SKIP THOSE
		CMP	AL,','
		JZ	L6$			;GOT A COMMA
		CMP	AL,0DH
		JZ	L7$
L2$:
		DEC	INPTR1
L3$:
		MOV	EAX,OFF EXESTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM

		push	ECX
		mov	ECX,ESP
		push	ECX
		push	EAX
		call	_filename_install
		add	ESP,8
		pop	ECX
		;CALL	FILENAME_INSTALL	;EAX IS GINDEX, ECX IS FILE_LIST PHYS
		ASSUME	ECX:PTR FILE_LIST_STRUCT

		OR	[ECX].FILE_LIST_FLAGS,MASK FLF_RANDOM
		CALL	INSTALL_OUTFILE
		ASSUME	ECX:NOTHING

		MOV	_OUTFILE_GINDEX,EAX

		MOV	EAX,OFF FILNAM
		push	EAX
		call	_check_nul
		add	ESP,4
		MOV	EAX,OFF FILNAM
		TEST	[EAX].NFN_STRUCT.NFN_FLAGS,MASK NFN_NUL
		JNZ	L5$
		push	EAX
		call	_do_srcnam
		add	ESP,4
L5$:
		;
		;(SE) Test for .DLL output (to avoid .def file)
		;
		MOV	EAX,OFF FILNAM
		ASSUME	EAX:PTR NFN_STRUCT

		CMP	[EAX].NFN_EXTLEN,4
		JNE	L51$

		MOV	ECX,[EAX].NFN_TOTAL_LENGTH

		LEA	ECX,[EAX+ECX].NFN_TEXT

		MOV	ECX,[ECX-4]

		OR	ECX,20202000h

		CMP	ECX,'lld.'
		JNE	L51$

		ASSUME	EAX:NOTHING
		OR	FLAG_0C,MASK APPTYPE		;OUTPUT A LIBRARY
L51$:
		CALL	GETNST_SLASH
		CMP	AL,'+'
		JZ	L5$			;SKIP ANY TRAILING +'S
		CMP	AL,0DH
		JZ	L9$
		CMP	AL,','
		JNZ	L8$
		;
		;MAKE SURE DEFAULT USED FOR MAP FILE
		;
		SETT	MAPFILE_SELECTED
		JMP	L9$

L8$:
		DEC	INPTR1
L9$:
		MOV	LAST_DELIM,AL
		RET

L6$:
		;
		;GOT A COMMA, SKIP IT IF WE JUST HAD A CR
		;
		CMP	LAST_DELIM,0DH
		JZ	L3$
		JMP	L2$

L7$:
		;
		;GOT A CR, SKIP IT IF WE JUST HAD A COMMA
		;
		CMP	LAST_DELIM,','
		JZ	L3$
		JMP	L2$

PARSE_OUTFILE	ENDP


PARSE_MAPFILE	PROC	NEAR
		;
		;GET NAME OF MAP FILE (USE OUTFILE AS DEFAULT IF SELECTED)
		;
		MOV	FILESTUFF_PTR,OFF MAPSTUFF
L1$:
		CALL	GETNST_SLASH
		CMP	AL,'+'
		JZ	L1$		;SKIP ANY LEADING +'S
		CMP	AL,','
		JZ	L6$
		CMP	AL,0DH
		JZ	L7$
L2$:
		DEC	INPTR1
L3$:
		MOV	EAX,OFF MAPSTUFF
		CALL	YYLEX_FILENAME
		SETT	SKIP_OUTFILE_LINK
		MOV	EAX,OFF FILNAM
		push	ECX
		mov	ECX,ESP
		push	ECX
		push	EAX
		call	_filename_install
		add	ESP,8
		pop	ECX
		;CALL	FILENAME_INSTALL	;EAX IS GINDEX, ECX IS FILE_LIST PHYS

		CALL	INSTALL_OUTFILE		;THIS IS AN OUTPUT FILE

		MOV	MAPFILE_GINDEX,EAX
		XOR	ECX,ECX
		MOV	EAX,OFF FILNAM
		RESS	SKIP_OUTFILE_LINK,CL
		RESS	MAPFILE_SELECTED,CL
		CMP	[EAX].NFN_STRUCT.NFN_PRIMLEN,ECX
		JZ	L5$
		push	EAX
		call	_check_nul
		add	ESP,4
		MOV	EAX,OFF FILNAM
		TEST	[EAX].NFN_STRUCT.NFN_FLAGS,MASK NFN_NUL
		JNZ	L5$
		SETT	MAPFILE_SELECTED
		SETT	SEGMENTS_MAP
L5$:
		CALL	GETNST_SLASH
		CMP	AL,'+'
		JZ	L5$			;SKIP ANY TRAILING +'S
		CMP	AL,0DH
		JZ	L9$
		CMP	AL,','
		JZ	L9$
L8$:
		DEC	INPTR1
L9$:
		MOV	LAST_DELIM,AL
		RET

L6$:
		;
		;GOT A COMMA, SKIP IT IF WE JUST HAD A CR
		;
		CMP	LAST_DELIM,0DH
		JZ	L3$
		JMP	L2$

L7$:
		;
		;GOT A CR, SKIP IT IF WE JUST HAD A COMMA
		;
		CMP	LAST_DELIM,','
		JZ	L3$
		JMP	L2$

PARSE_MAPFILE	ENDP


PARSE_DEFFILE	PROC	NEAR
		;
		;GET NAME OF MAP FILE (USE OUTFILE AS DEFAULT IF SELECTED)
		;
		MOV	FILESTUFF_PTR,OFF DEFSTUFF
L1$:
		CALL	GETNST_SLASH
		CMP	AL,'+'
		JZ	L1$			;SKIP ANY LEADING +'S
if	fg_def
		CMP	AL,','
		JZ	L6$
		CMP	AL,0DH
		JZ	L7$
L2$:
		DEC	INPTR1
L3$:
		MOV	EAX,OFF DEFSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM

		push	EAX
		call	_store_filnam
		add	ESP,4

		XOR	ECX,ECX
		MOV	DEFFILE,EAX
		MOV	EAX,OFF FILNAM
		RESS	DEFFILE_SELECTED,CL
		CMP	[EAX].NFN_STRUCT.NFN_PRIMLEN,ECX
		JZ	L5$
		push	EAX
		call	_check_nul
		add	ESP,4
		MOV	EAX,OFF FILNAM
		TEST	[EAX].NFN_STRUCT.NFN_FLAGS,MASK NFN_NUL
		JNZ	L5$
		SETT	DEFFILE_SELECTED
L5$:
		CALL	GETNST_SLASH
		CMP	AL,'+'
		JZ	L5$			;SKIP ANY TRAILING +'S
		CMP	AL,','
		JZ	L9$
		CMP	AL,0DH
		JZ	L9$
		DEC	INPTR1
L9$:
endif
		MOV	LAST_DELIM,AL
		RET

if	fg_def

L6$:
		;
		;GOT A COMMA, SKIP IT IF WE JUST HAD A CR
		;
		CMP	LAST_DELIM,0DH
		JZ	L3$
		JMP	L2$

L7$:
		;
		;GOT A CR, SKIP IT IF WE JUST HAD A COMMA
		;
		CMP	LAST_DELIM,','
		JZ	L3$
		JMP	L2$

endif

PARSE_DEFFILE	ENDP


PARSE_LIBS	PROC	NEAR
		;
		;GET NAMES OF LIBRARIES TO SEARCH
		;
		MOV	FILESTUFF_PTR,OFF LIBSTUFF
L1$:
		CALL	GETNST_SLASH
		CMP	AL,','
		JZ	L6$			;SKIP COMMA
		CMP	AL,0DH
		JZ	L4$			;TERMINATE IF PLUS NOT FOUND
		MOV	LAST_DELIM,0
		CMP	AL,'+'
		JZ	L3$			;FLAG + FOUND
		DEC	INPTR1
		CMP	AL,';'
		JZ	L9$
		CMP	AL,1AH
		JZ	L9$
		RESS	PLUS_FOUND
		MOV	EAX,OFF LIBSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_LIBS
		JMP	L1$

L3$:
		SETT	PLUS_FOUND
		JMP	L1$

L6$:
		;
		;COMMA FOUND
		;
		CMP	LAST_DELIM,0DH
		JMP	L41$

L4$:
		;
		;CR FOUND
		;
		CMP	LAST_DELIM,','
L41$:
		MOV	LAST_DELIM,0
		JNZ	L45$
if	fg_td
		BITT	TLINK_DEFAULT_MODE
		JNZ	L45$
endif
		JMP	L1$

L45$:
		MOV	LAST_DELIM,AL
		BITT	PLUS_FOUND
		PUSHFD
		RESS	PLUS_FOUND
		POPFD
		JZ	L71$
if	fg_td
		CMP	AL,0DH			;PLUS OVERIDES A CR ALWAYS
		JZ	L1$
		BITT	TLINK_DEFAULT_MODE	;IN TLINK MODE, THAT'S ALL IT OVERIDES
		JNZ	L71$
endif
		JMP	L1$

L71$:
		RET

L9$:
		RESS	PLUS_FOUND
		RET

PARSE_LIBS	ENDP


PARSE_RCS	PROC	NEAR
		;
		;GET NAMES OF .RES FILES TO BIND
		;
		MOV	FILESTUFF_PTR,OFF RESSTUFF
L1$:
		CALL	GETNST_SLASH
		CMP	AL,','
		JZ	L6$			;SKIP COMMA
		CMP	AL,0DH
		JZ	L4$			;TERMINATE IF PLUS NOT FOUND
		MOV	LAST_DELIM,0
		CMP	AL,'+'
		JZ	L3$			;FLAG + FOUND
		DEC	INPTR1
		CMP	AL,';'
		JZ	L9$
		CMP	AL,1AH
		JZ	L9$
		RESS	PLUS_FOUND
		SETT	RC_SUPPLIED
		MOV	EAX,OFF RESSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_RCS
		JMP	L1$

L3$:
		SETT	PLUS_FOUND
		JMP	L1$

L6$:
		;
		;COMMA FOUND
		;
		CMP	LAST_DELIM,0DH
		JMP	L41$

L4$:
		;
		;CR FOUND
		;
		CMP	LAST_DELIM,','
L41$:
		MOV	LAST_DELIM,0
		JNZ	L45$
if	fg_td
		BITT	TLINK_DEFAULT_MODE
		JNZ	L45$
endif
		JMP	L1$

L45$:
		MOV	LAST_DELIM,AL
		BITT	PLUS_FOUND
		PUSHFD
		RESS	PLUS_FOUND
		POPFD
		JZ	L71$
if	fg_td
		CMP	AL,0DH			;PLUS OVERIDES A CR ALWAYS
		JZ	L1$
		BITT	TLINK_DEFAULT_MODE	;IN TLINK MODE, THAT'S ALL IT OVERIDES
		JNZ	L71$
endif
		JMP	L1$

L71$:
		RET

L9$:
		RESS	PLUS_FOUND
		RET

PARSE_RCS	ENDP


MAKE_MAPOUT	PROC
		;
		PUSHM	EDI,ESI
		SETT	MAPFILE_SELECTED
		SETT	SYMBOLS_OUT
L1$:
		CALL	FIX_GET_COLON
		JNZ	L3$
		CALL	GET_KEYWORD
		MOV	EAX,SYMBOL_LENGTH	;AT LEAST THIS MANY MUST MATCH
		MOV	ESI,OFF FULL_TEXT
		MOV	ECX,EAX
		MOV	EDI,OFF SYMBOL_TEXT
		TEST	ECX,ECX
		MOV	EDX,EDI
		JZ	L4$
		REPE	CMPSB
		JNZ	L5$
		SETT	DETAILEDMAP_FLAG
		SETT	ALPHA_ORDER_ALSO
		JMP	L1$

L3$:
		POPM	ESI,EDI
		RET

L4$:
		POPM	ESI,EDI
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		RET

L5$:
		MOV	ECX,EAX			;AT LEAST THIS MANY MUST MATCH
		MOV	EDI,EDX
		MOV	ESI,OFF ADDRESS_TEXT
		REPE	CMPSB
		JNZ	L51$
		RESS	ALPHA_ORDER_ALSO
		JMP	L1$

L51$:
		MOV	ECX,EAX			;AT LEAST THIS MANY MUST MATCH
		MOV	EDI,EDX
		MOV	ESI,OFF GROUP_TEXT
		REPE	CMPSB
		JNZ	L52$
		SETT	PRINT_GROUP
		JMP	L1$

L52$:
		MOV	ECX,EAX			;AT LEAST THIS MANY MUST MATCH
		MOV	EDI,EDX
		MOV	ESI,OFF NOGROUP_TEXT
		REPE	CMPSB
		JNZ	L53$
		RESS	PRINT_GROUP
		JMP	L1$

L53$:
L59$:
		CALL	GET_NUMBER1
		TEST	EAX,EAX
		JNZ	L6$
		RESS	ALPHA_ORDER_ALSO
L6$:
		JMP	L1$

MAKE_MAPOUT	ENDP


GET_NUMBER	PROC
		;
		;MS FORMAT NUMBER
		;
		CALL	GET_KEYWORD

GET_NUMBER1	LABEL	PROC

		PUSHM	ESI,EBX
		MOV	ESI,OFF SYMBOL_TEXT
		XOR	EAX,EAX
		XOR	EBX,EBX
		XOR	ECX,ECX
		MOV	BL,[ESI]
		MOV	ECX,10
		SUB	BL,30H
		INC	ESI
		CMP	BL,CL
		JA	GN_ERROR
		OR	BL,BL
		JNZ	GET_DECIMAL
		MOV	BL,[ESI]
		INC	ESI
		MOV	CL,8
		CMP	BL,'X'
		JZ	GET_HEX
		CMP	BL,'x'
		JNZ	GET_OCTAL
GET_HEX:
		MOV	CL,16
G_LOOP:
		MOV	BL,[ESI]
		INC	ESI
GET_OCTAL:
		SUB	BL,30H
		CMP	BL,0AH
		JC	GET_DECIMAL
		SUB	BL,7
		CMP	BL,0AH
		JC	NUMBER_DONE
		CMP	BL,10H		;MUST BE 0A-0F
		JC	GET_DECIMAL
		CMP	BL,'a'-30H-7
		JC	NUMBER_DONE
		CMP	BL,'f'-30H-7
		JA	NUMBER_DONE
		SUB	BL,20H
GET_DECIMAL:
		CMP	BL,CL
		JNC	NUMBER_DONE

		MUL	ECX
		JC	L9$
		ADD	EAX,EBX
		JNC	G_LOOP
L9$:
GN_ERROR::
		MOV	AL,ILL_NUMBER_ERR
		CALL	ERR_SYMBOL_TEXT_ABORT

NUMBER_DONE:
		SUB	ESI,OFF SYMBOL_TEXT+1		;RESTORE CHARACTERS NOT PROCESSED
		POP	EBX
		SUB	ESI,SYMBOL_LENGTH
		ADD	INPTR1,ESI
		POP	ESI
		RET

GET_NUMBER	ENDP


GET_COLON_NUMBER16	PROC

		CALL	GET_COLON_NUMBER
		TEST	EAX,0FFFF0000H
		JNZ	GN_ERROR
		RET

GET_COLON_NUMBER16	ENDP


GET_NUMBER16	PROC

		CALL	GET_NUMBER
		TEST	EAX,0FFFF0000H
		JNZ	GN_ERROR
		RET

GET_NUMBER16	ENDP


GET_COLON_NUMBER	PROC
		;
		;
		;
		CALL	CHECK_COLON
		JMP	GET_NUMBER

GET_COLON_NUMBER	ENDP


MS_HELP		PROC
		;
		;PRINT HELP MESSAGE
		;PROCESS THROUGH OTHER TABLE...
		;
		;MOV	EAX,OFF MS_CMD_PTRS
		JMP	HELP_PROC_1

MS_HELP		ENDP


SET_DEBUGALL	PROC
		;
		;
		;
		MOV	AL,-1
DBG_SET::
		OR	DEBUG_TYPES_SELECTED,AL
		RET

SET_DEBUGALL	ENDP


SET_DEBUGBROWSERDEFS	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_BROWSERDEFS
		JMP	DBG_SET

SET_DEBUGBROWSERDEFS	ENDP


SET_DEBUGBROWSERREFS	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_BROWSERREFS
		JMP	DBG_SET

SET_DEBUGBROWSERREFS	ENDP


SET_DEBUGCOVERAGES	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_COVERAGES
		JMP	DBG_SET

SET_DEBUGCOVERAGES	ENDP


SET_DEBUGLOCALS	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_LOCALS
		JMP	DBG_SET

SET_DEBUGLOCALS	ENDP


SET_DEBUGLINNUMS	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_LINNUMS
		JMP	DBG_SET

SET_DEBUGLINNUMS	ENDP


SET_DEBUGPUBLICS	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_PUBLICS
		JMP	DBG_SET

SET_DEBUGPUBLICS	ENDP


SET_DEBUGTYPES	PROC
		;
		;
		;
		MOV	AL,MASK FL_DEBUG_TYPES
		JMP	DBG_SET

SET_DEBUGTYPES	ENDP


RES_DEBUGALL	PROC
		;
		;
		;
		MOV	AL,0
DBG_CLEAR::
		AND	DEBUG_TYPES_SELECTED,AL
		SETT	FANCY_DEBUG
		RET

RES_DEBUGALL	ENDP


RES_DEBUGBROWSERDEFS	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_BROWSERDEFS
		JMP	DBG_CLEAR

RES_DEBUGBROWSERDEFS	ENDP


RES_DEBUGBROWSERREFS	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_BROWSERREFS
		JMP	DBG_CLEAR

RES_DEBUGBROWSERREFS	ENDP


RES_DEBUGCOVERAGES	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_COVERAGES
		JMP	DBG_CLEAR

RES_DEBUGCOVERAGES	ENDP


RES_DEBUGLOCALS	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_LOCALS
		JMP	DBG_CLEAR

RES_DEBUGLOCALS	ENDP


RES_DEBUGLINNUMS	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_LINNUMS
		JMP	DBG_CLEAR

RES_DEBUGLINNUMS	ENDP


RES_DEBUGPUBLICS	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_PUBLICS
		JMP	DBG_CLEAR

RES_DEBUGPUBLICS	ENDP


RES_DEBUGTYPES	PROC
		;
		;
		;
		MOV	AL,NOT MASK FL_DEBUG_TYPES
		JMP	DBG_CLEAR

RES_DEBUGTYPES	ENDP


HANDLE_DEBUGFILES	PROC
		;
		;
		;
if	any_overlays
		CALL	FIX_GET_COLON
		JNZ	L9$
else
		CALL	CHECK_COLON
endif
		SETT	FANCY_DEBUG
L1$:
		MOV	EAX,OFF OBJSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM
		push	ECX
		mov	ECX,ESP
		push	ECX
		push	EAX
		call	_filename_install
		add	ESP,8
		pop	ECX
		;CALL	FILENAME_INSTALL	;THAT FILE...
		OR	[ECX].FILE_LIST_STRUCT.FILE_LIST_PLINK_FLAGS,MASK FL_DEBUG_COVERAGES+MASK FL_DEBUG_LINNUMS+MASK FL_DEBUG_LOCALS+ \
						MASK FL_DEBUG_PUBLICS+MASK FL_DEBUG_TYPES+MASK FL_DEBUG_BROWSERDEFS+ \
						MASK FL_DEBUG_BROWSERREFS
		CALL	FIX_GET_COLON
		JZ	L1$
		RET

if	any_overlays
L9$:
		SETT	DEBUG_FLAG
		MOV	DEBUG_BYTE,'Y'
		RET
endif

HANDLE_DEBUGFILES	ENDP


HANDLE_DEBUGMODULES	PROC
		;
		;
		;
if	any_overlays
		CALL	FIX_GET_COLON
		JNZ	L9$
else
		CALL	CHECK_COLON
endif
		SETT	FANCY_DEBUG
L1$:
		CALL	YYLEX_SYMBOL		;

		MOV	EAX,OFF SYMBOL_TPTR
		CALL	FORCE_INSTALL_MODULE	;THAT FILE...
		;
		;
		;
		OR	[ECX].MODULE_STRUCT._M_FLAGS,MASK M_DEBUG_GLOBAL
		CALL	FIX_GET_COLON
		JZ	L1$
		RET

if	any_overlays
L9$:
		SETT	DEBUG_FLAG
		MOV	DEBUG_BYTE,'Y'
		RET
endif

HANDLE_DEBUGMODULES	ENDP


SET_ENTRYPOINT	PROC
		;
		;
		;
		CALL	CHECK_COLON

		CALL	GET_SYMBOL	;PARSE A SYMBOL (NO TRANSLATE)

		MOV	EAX,SYMBOL_LENGTH
		PUSH	EDI

		MOV	ESI,OFF SYMBOL_TEXT
		MOV	ECX,EAX

		ADD	EAX,4
		PUSH	ESI

		P1ONLY_POOL_ALLOC

		MOV	ENTRYPOINT_TXT,EAX
		MOV	[EAX],ECX

		LEA	EDI,[EAX+4]

		REP	MOVSB

		POPM	ESI,EDI

		RET

SET_ENTRYPOINT	ENDP


CHECK_COLON	PROC

		CALL	FIX_GET_COLON
		JNZ	COLON_EXP
		RET

COLON_EXP	LABEL	PROC

		MOV	AL,MISSING_COLON_ERR
		JMP	ERR_SYMBOL_TEXT_ABORT

CHECK_COLON	ENDP


ONERROR_PROC	PROC
		;
		;ONERROR:NOEXE
		;
		CALL	CHECK_COLON	;MUST HAVE A COLON
		CALL	GET_KEYWORD	;DOES UPPERCASE
		PUSHM	EDI,ESI

		MOV	EAX,SYMBOL_LENGTH
		MOV	EDI,OFF NOEXE_TXT
		TEST	EAX,EAX
		JZ	L9$
		MOV	ECX,EAX
		MOV	ESI,OFF SYMBOL_TEXT
		REPE	CMPSB		;CX BYTES MUST MATCH
		JNZ	L9$
		CALL	ERRORDELETE_PROC
		POPM	ESI,EDI
		RET

L9$:
		POPM	ESI,EDI
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		RET

ONERROR_PROC	ENDP


if	fg_segm

PMTYPE_PROC	PROC
		;
		;PMTYPE:[PM | VIO | NOVIO]
		;
		CALL	CHECK_COLON	;MUST HAVE A COLON
		CALL	GET_KEYWORD
		PUSHM	EDI,ESI,EBX

		MOV	EBX,OFF PM_TYPES
		MOV	EDX,3		;3 TYPES TO CHECK
L1$:
		MOV	ESI,[EBX]
		MOV	ECX,SYMBOL_LENGTH;AT LEAST THIS MANY MUST MATCH
		MOV	EDI,OFF SYMBOL_TEXT
		TEST	ECX,ECX
		JZ	L4$
		REPE	CMPSB
		MOV	EAX,[EBX+4]
		JZ	L5$
		ADD	EBX,8
		DEC	EDX
		JNZ	L1$
L4$:
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		POPM	EBX,ESI,EDI
		RET

L5$:
		POPM	EBX,ESI,EDI
		OR	FLAG_0C,EAX
		RET

PMTYPE_PROC	ENDP

endif


EXETYPE_PROC	PROC
		;
		;EXETYPE:[OS2 | WINDOWS | DOS4 | UNKNOWN | DOS | NT | DOSX]
		;
		CALL	CHECK_COLON	;MUST HAVE A COLON
		CALL	GET_KEYWORD
		PUSHM	EDI,ESI,EBX
		MOV	EBX,OFF EXE_TYPES
		MOV	EDX,N_EXE_TYPES	;6 TYPES TO CHECK
L1$:
		MOV	ESI,[EBX]
		MOV	ECX,SYMBOL_LENGTH;AT LEAST THIS MANY MUST MATCH
		MOV	EDI,OFF SYMBOL_TEXT
		TEST	ECX,ECX
		JZ	L4$
		REPE	CMPSB
		MOV	EAX,[EBX+4]
		JZ	L5$
		ADD	EBX,8
		DEC	EDX
		JNZ	L1$
L4$:
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		POPM	EBX,ESI,EDI
		RET

L5$:
		POPM	EBX,ESI,EDI
		MOV	EXETYPE_CMDLINE_FLAG,AL
		RET

EXETYPE_PROC	ENDP


SUBSYSTEM_PROC	PROC
		;
		;SUBSYSTEM:[OS2 | WINDOWS | DOS4 | UNKNOWN | DOS | NT | DOSX]
		;
		CALL	CHECK_COLON	;MUST HAVE A COLON
		CALL	GET_KEYWORD

		PUSHM	EDI,ESI,EBX
		MOV	EBX,OFF SUBSYS_TYPES
		MOV	EDX,N_SUBSYS_TYPES	;6 TYPES TO CHECK
L1$:
		MOV	ESI,[EBX]
		MOV	ECX,SYMBOL_LENGTH	;AT LEAST THIS MANY MUST MATCH
		MOV	EDI,OFF SYMBOL_TEXT
		TEST	ECX,ECX
		JZ	L4$

		REPE	CMPSB

		MOV	EAX,[EBX+4]
		JZ	L5$

		ADD	EBX,8
		DEC	EDX
		JNZ	L1$
L4$:
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		POPM	EBX,ESI,EDI
		RET

L5$:
		CALL	SET_SUBSYSTEM

		JNZ	L4$

		CALL	FIX_GET_COLON

		JNZ	L9$

		CALL	GET_NUM_DOT_NUM

		MOV	ECX,EDX
		CALL	SET_SUBSYS_VERSION

		JNZ	L4$
L9$:
		POPM	EBX,ESI,EDI

		RET

SUBSYSTEM_PROC	ENDP


FIX_GET_COLON	PROC
		;
		;
		;
		CALL	GETNST
		CMP	AL,':'
		JZ	L9$
		DEC	INPTR1
L9$:
		RET

FIX_GET_COLON	ENDP


SET_EMSMAXSIZE	PROC
		;
		CALL	GET_COLON_NUMBER16
;		MOV	EMS_MAX_1K_BLOCKS,AX
		RET

SET_EMSMAXSIZE	ENDP


SET_XMSMAXSIZE	PROC
		;
		CALL	GET_COLON_NUMBER16
;		MOV	XMS_MAX_1K_BLOCKS,AX
		RET

SET_XMSMAXSIZE	ENDP


SET_EXEPACK	PROC
		;
		;
		;
		SETT	EXEPACK_SELECTED
SET_EXEPACK_1	LABEL	PROC

		CALL	FIX_GET_COLON
		JZ	L1$
		RET

L1$:
		CALL	GET_NUMBER
		INC	EAX			;FORCE TO # OF WORDS...
		AND	AL,0FEH
		CMP	DONT_PACK,EAX
		JA	L2$
		MOV	DONT_PACK,EAX
L2$:
		RET

SET_EXEPACK	ENDP


SET_WINPACK	PROC
		;
		;
		;
if	fg_virt AND (NOT debug)
		MOV	AL,CANT_WINPACK_ERR
		push	EAX
		call	_err_abort
else
		SETT	WINPACK_SELECTED
endif

SET_WINPACK	ENDP


RES_DEFAULTLIBRARYSEARCH	PROC
		;
		;
		;
		CALL	FIX_GET_COLON
		JZ	L1$
		RESS	DEFAULTLIBRARYSEARCH_FLAG
		RET

L1$:
		;
		;NEED TO DISABLE A SINGLE LIBRARY NAME...
		;OK,
		;
		SETT	DOING_NODEF
		MOV	EAX,OFF LIBSTUFF
		CALL	YYLEX_FILENAME		;NOW, WAS A PATH SUPPLIED?
		MOV	EAX,OFF FILNAM
		push	EAX
		call	_do_search_library
		add	ESP,4
		RESS	DOING_NODEF
		RET

RES_DEFAULTLIBRARYSEARCH	ENDP


if	fg_segm OR fg_pe

RC_PROC		PROC
		;
		;HANDLE SUPPLYING AN RC FILE FOR INCLUSION...
		;
		BITT	RC_SUPPLIED
		JNZ	L0$
		SETT	RC_SUPPLIED
		SETT	RC_REORDER
		OR	FLAG_0C,MASK APPWINFLAGS
L0$:
		CALL	FIX_GET_COLON
		JZ	L1$
		CMP	AL,'-'
		JZ	L2$
		RET

L9$:
		MOV	AL,MULTIPLE_RC_ERR
		push	EAX
		call	_err_abort

L1$:
		MOV	EAX,OFF RCSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_RCS
		JMP	L0$

L2$:
		INC	INPTR1
		CALL	GET_KEYWORD
		MOV	ECX,SYMBOL_LENGTH
		MOV	EAX,DPTR SYMBOL_TEXT
		DEC	ECX
		JNZ	L25$
		CMP	AL,'a'
		JC	L11$
		CMP	AL,'z'
		JA	L11$
		SUB	AL,20H
L11$:
		CMP	AL,'E'
		MOV	EBX,MASK APP386			;DRIVER USES EMS
		JZ	L19$
		CMP	AL,'L'
		MOV	EBX,MASK APP86			;APP USES EMS
		JZ	L19$
		CMP	AL,'M'
		MOV	EBX,MASK APP286			;MULTIPLE INSTANCE (MORE EMS JUNK)
		JZ	L19$
		CMP	AL,'P'
		MOV	EBX,MASK APP??			;PRIVATE LIBRARY
		JZ	L19$
		CMP	AL,'T'				;PROTMODE ONLY
		JZ	L16$
		CMP	AL,'K'
		JNZ	L95$
		RESS	RC_REORDER
		JMP	L0$

L16$:
		CALL	RC_PROTMODE
		JMP	L0$

L19$:
		OR	FLAG_0C,EBX
		JMP	L0$

L95$:
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		RET

L25$:
		DEC	ECX
		JNZ	L95$
		CMP	AX,'04'
		MOV	EBX,400H
		JZ	L27$
		CMP	AX,'03'
		MOV	BH,3
		JZ	L27$
		CMP	AX,'13'
		JNZ	L95$
		MOV	BL,0AH
L27$:
		BITT	WINVER_SELECTED
		JNZ	L28$
		MOV	NEXEHEADER._NEXE_WINVER_INT,BH
		SETT	WINVER_SELECTED
		MOV	NEXEHEADER._NEXE_WINVER_FRAC,BL
L28$:
		JMP	L0$

RC_PROC		ENDP


STUB_PROC	PROC
		;
		;HANDLE SUPPLYING A STUB FILE FOR INCLUSION...
		;
		CALL	CHECK_COLON

		MOV	EAX,OFF STUBSTUFF
		CALL	YYLEX_FILENAME

		BITT	STUB_SUPPLIED
		JNZ	L9$
		BITT	STUB_NONE
		JNZ	L9$

		MOV	EAX,OFF FILNAM.NFN_TEXT

		ADD	EAX,FILNAM.NFN_PATHLEN

		MOV	EAX,[EAX]

		CMP	EAX,'ENON'
		JZ	L5$

		CMP	EAX,'enon'
		JZ	L5$

		SETT	STUB_SUPPLIED

		MOV	EAX,OFF FILNAM
		JMP	HANDLE_STUB

L5$:
		SETT	STUB_NONE
		RET

L9$:
		MOV	AL,DUP_STUB_ERR
		JMP	ERR_INBUF_RET

STUB_PROC	ENDP


if	V5

		PUBLIC	PARSE_IMPDEF_FILENAME,PARSE_IMPLIB_FILENAME,PARSE_IMPLIB_COFF_FILENAME

SET_IMPDEF	PROC
		;
		;POSSIBLY :FILENAME, .DIN OUTPUT DESCRIBING THIS .DLL
		;
		SETT	IMPDEF_FLAG			;HE WANTS US TO BUILD .DIN
		CALL	FIX_GET_COLON
		JZ	L1$
		RET

L1$:
		CALL	PARSE_IMPDEF_FILENAME
		RET

SET_IMPDEF	ENDP


PARSE_IMPDEF_FILENAME	PROC
		;
		;
		;
		MOV	EAX,OFF IMPDEF_STUFF	;LIKE DEF, BUT USE PRIMARY NAME AS DEFAULT
		CALL	YYLEX_FILENAME
		SETT	SKIP_OUTFILE_LINK
		MOV	EAX,OFF FILNAM
		push	ECX
		mov	ECX,ESP
		push	ECX
		push	EAX
		call	_filename_install
		add	ESP,8
		pop	ECX
		;CALL	FILENAME_INSTALL	;AX IS GINDEX, DS:BX IS FILE_LIST PHYS

		CALL	INSTALL_OUTFILE		;THIS IS AN OUTPUT FILE
		MOV	IMPDEF_FILE_GINDEX,EAX
		RESS	SKIP_OUTFILE_LINK
		RET

PARSE_IMPDEF_FILENAME	ENDP


SET_IMPLIB	PROC
		;
		;POSSIBLY :FILENAME, .LIB OUTPUT DESCRIBING THIS .DLL
		;
		SETT	IMPLIB_FLAG			;HE WANTS US TO BUILD .LIB
		CALL	FIX_GET_COLON
		JZ	L1$
		RET

L1$:
		CALL	PARSE_IMPLIB_FILENAME
		RET

SET_IMPLIB	ENDP


PARSE_IMPLIB_FILENAME	PROC
		;
		;
		;
		MOV	EAX,OFF IMPLIB_STUFF	;LIKE LIB, BUT USE PRIMARY NAME AS DEFAULT
		CALL	YYLEX_FILENAME
		SETT	SKIP_OUTFILE_LINK
		MOV	EAX,OFF FILNAM
		push	ECX
		mov	ECX,ESP
		push	ECX
		push	EAX
		call	_filename_install
		add	ESP,8
		pop	ECX
		;CALL	FILENAME_INSTALL	;AX IS GINDEX, DS:BX IS FILE_LIST PHYS
		CALL	INSTALL_OUTFILE		;THIS IS AN OUTPUT FILE
		MOV	IMPLIB_FILE_GINDEX,EAX
		RESS	SKIP_OUTFILE_LINK
		RET

PARSE_IMPLIB_FILENAME	ENDP

SET_IMPLIB_COFF	PROC
		;
		;POSSIBLY :FILENAME, .LIB OUTPUT DESCRIBING THIS .DLL
		;
		SETT	IMPLIB_COFF_FLAG		;HE WANTS US TO BUILD .LIB
		CALL	FIX_GET_COLON
		JZ	L1$
		RET

L1$:
		CALL	PARSE_IMPLIB_COFF_FILENAME
		RET

SET_IMPLIB_COFF	ENDP

PARSE_IMPLIB_COFF_FILENAME PROC

		MOV	EAX,OFF IMPLIB_STUFF	;LIKE LIB, BUT USE PRIMARY NAME AS DEFAULT
		CALL	YYLEX_FILENAME
		SETT	SKIP_OUTFILE_LINK
		MOV	EAX,OFF FILNAM
		push	ECX
		mov	ECX,ESP
		push	ECX
		push	EAX
		call	_filename_install
		add	ESP,8
		pop	ECX
		;CALL	FILENAME_INSTALL	;AX IS GINDEX, DS:BX IS FILE_LIST PHYS
		CALL	INSTALL_OUTFILE		;THIS IS AN OUTPUT FILE
		MOV	IMPLIB_COFF_FILE_GINDEX,EAX
		RESS	SKIP_OUTFILE_LINK
		RET

PARSE_IMPLIB_COFF_FILENAME	ENDP



SET_PAGESIZE	PROC
		;
		;:nnn, SETS PAGESIZE FOR OPTIMP .LIB FILE
		;
		CALL	GET_COLON_NUMBER16

		MOV	IMPLIB_PAGESIZE,EAX

		RET

SET_PAGESIZE	ENDP

endif

endif

SET_CPARMAXALLOC	PROC

		CALL	GET_COLON_NUMBER16
		MOV	EXEHEADER._EXE_MAX_ABOVE,AX
		RET

SET_CPARMAXALLOC	ENDP

if	any_overlays
SET_OVERLAYINTERRUPT	PROC

		CALL	GET_COLON_NUMBER16
		MOV	OVERLAY_INTERRUPT_NUMBER,EAX
		RET

SET_OVERLAYINTERRUPT	ENDP
endif


SET_CODEVIEW	PROC
if	fg_cv
		SETT	CODEVIEW_FLAG
if	any_overlays
		MOV	CODEVIEW_BYTE,'Y'
endif
		CALL	FIX_GET_COLON
		JNZ	L9$
		CALL	GET_NUMBER16
		MOV	CV_INFO_TYPE,AL
L9$:
endif
if	fg_td
		CALL	RES_TD
endif
		RET

SET_CODEVIEW	ENDP


SET_CVVERSION	PROC
		;
		;
		;
		CALL	FIX_GET_COLON
		JNZ	L9$
		CALL	GET_NUMBER16
		MOV	CV_INFO_TYPE,AL
L9$:
		RET

SET_CVVERSION	ENDP


SET_CVWARNINGS	PROC
		;
		;
		;
		SETT	CV_WARNINGS

		RET

SET_CVWARNINGS	ENDP


RES_CODEVIEW	PROC
		;
		RESS	CODEVIEW_FLAG
if	any_overlays
		MOV	CODEVIEW_BYTE,'N'
endif
		RET

RES_CODEVIEW	ENDP


SET_BINARY	PROC
		;
		SETT	OUTPUT_COM_SYS
		SETT	OUTPUT_SYS
		XOR	EAX,EAX
		PUSH	EAX
		CALL	FIX_GET_COLON
		POP	EAX
		JNZ	SB_DONE
		CALL	GET_NUMBER

SB_DONE		LABEL	PROC

		MOV	SYS_BASE,EAX
		RET


SET_TINY	LABEL	PROC

		SETT	OUTPUT_COM_SYS
		SETT	OUTPUT_COM
		MOV	EAX,100H
		JMP	SB_DONE

SET_BINARY	ENDP


if	any_overlays
SET_RELOAD	PROC
		;
		SETT	DOING_RELOAD
		MOV	RELOAD_BYTE,'Y'
		CALL	GET_COLON_NUMBER16
		MOV	RELOAD_DEPTH,EAX
		RET

SET_RELOAD	ENDP
endif


SET_PACKCODE	PROC

		RESS	NOPACKCODE_FLAG
		SETT	PACKCODE_FLAG
		MOV	EAX,OFF PACKCODE
		JMP	PACK_PROC

SET_PACKCODE	ENDP


SET_PACKDATA	PROC

		RESS	NOPACKDATA_FLAG
		SETT	PACKDATA_FLAG
		MOV	EAX,OFF PACKDATA

PACK_PROC	LABEL	PROC

		PUSH	EAX
		CALL	FIX_GET_COLON
		JZ	L1$
		MOV	EAX,PACK_DEFAULT_SIZE
		JMP	L3$

L1$:
		CALL	GET_NUMBER		;EAX
		CMP	EAX,64K
		JA	GN_ERROR
		TEST	EAX,EAX
		JNZ	L3$
		MOV	EAX,64K
L3$:
		POP	ECX
		MOV	DPTR [ECX],EAX
		RET

SET_PACKDATA	ENDP


PACKSIZE_PROC	PROC
		;
		;
		;
		CALL	GET_COLON_NUMBER16
		TEST	EAX,EAX
		JNZ	L1$
		MOV	EAX,64K
L1$:
		MOV	PACK_DEFAULT_SIZE,EAX
		RET

PACKSIZE_PROC	ENDP


SET_NULLSDOSSEG	PROC
		;
		SETT	NULLSDOSSEG_FLAG
		CALL	DOSSEG_PROC
		RET

SET_NULLSDOSSEG	ENDP


if	fg_segm OR fg_pe

SET_PADDATA	PROC
		;
		CALL	GET_COLON_NUMBER16
		MOV	PADDATA,EAX
		RET

SET_PADDATA	ENDP


SET_PADCODE	PROC
		;
		CALL	GET_COLON_NUMBER16
		MOV	PADCODE,EAX
		RET

SET_PADCODE	ENDP

endif


SET_STACK	PROC
		;
		CALL	GET_COLON_NUMBER
		CALL	SET_STACK_1
		;
if	fg_pe
		CALL	FIX_GET_COLON
		JNZ	L9$
		CALL	GET_NUMBER
		MOV	PEXEHEADER._PEXE_STACK_COMMIT,EAX
endif

L9$:
		RET

SET_STACK	ENDP


SET_STACK_1	PROC

		ADD	EAX,3				;DWORD ALIGN IT...
		AND	AL,0FCH
		SETT	STACK_SIZE_FLAG
		MOV	STACK_SIZE,EAX
		RET

SET_STACK_1	ENDP


if	fg_segm OR fg_pe

SET_HEAP	PROC
		;
		CALL	GET_COLON_NUMBER
		CALL	SET_HEAP_1
		;
if	fg_pe
		CALL	FIX_GET_COLON
		JNZ	L9$
		CALL	GET_NUMBER
		MOV	PEXEHEADER._PEXE_HEAP_COMMIT,EAX
endif

L9$:
		RET

SET_HEAP	ENDP


SET_HEAP_1	PROC

		ADD	EAX,3				;DWORD ALIGN IT...
		AND	AL,0FCH
		SETT	HEAP_SIZE_FLAG
		MOV	HEAP_SIZE,EAX
		RET

SET_HEAP_1	ENDP

endif

if	fg_pe

SET_PE_BASE	PROC
		;
		;
		;
		CALL	GET_COLON_NUMBER
		MOV	PE_BASE,EAX
		SETT	PE_BASE_SPECIFIED
		RET

SET_PE_BASE	ENDP


SET_PE_FIXED	PROC
		;
		;
		;
		SETT	PE_BASE_FIXED
		RET

SET_PE_FIXED	ENDP


SET_MACHINE	PROC
		;
		;ONLY SUPPORTS i386, i486, PENTIUM
		;
		CALL	CHECK_COLON
		CALL	GET_KEYWORD
		PUSHM	EDI,ESI
		MOV	ECX,SYMBOL_LENGTH	;AT LEAST THIS MANY MUST MATCH
		MOV	ESI,OFF I386_TXT
		TEST	ECX,ECX
		MOV	EDI,OFF SYMBOL_TEXT
		JZ	L4$
		REPE	CMPSB
		JNZ	L4$
		POPM	ESI,EDI
if	fg_pe
		MOV	PEXEHEADER._PEXE_CPU_REQUIRED,PEXE_80386
endif
		RET

L4$:
		POPM	ESI,EDI
		MOV	AL,CMDLIN_ERR
		CALL	ERR_INBUF_RET
		RET

SET_MACHINE	ENDP


SET_VERSION	PROC
		;
		;
		;
		CALL	CHECK_COLON
		CALL	GET_NUM_DOT_NUM
if	fg_pe
		MOV	PEXEHEADER._PEXE_USER_MAJOR,AX
		MOV	PEXEHEADER._PEXE_USER_MINOR,DX
endif
		RET

SET_VERSION	ENDP

endif


if	fg_segm or fg_norm_exe OR fg_pe

SET_ALIGNMENT	PROC
		;
		CALL	GET_COLON_NUMBER
		MOV	ALIGNMENT,EAX		;MUST BE A POWER OF 2...
		SETT	ALIGNMENT_SPECIFIED
		RET

SET_ALIGNMENT	ENDP

endif


SET_SEGMENTS	PROC
		;
		CALL	GET_COLON_NUMBER	;IGNORED...
		RET

SET_SEGMENTS	ENDP


if	fg_dospack

SET_PACKDOTS	PROC
		;
		SETT	DOTS_FLAG
		RET

SET_PACKDOTS	ENDP


RES_PACKDOTS	PROC
		;
		RESS	DOTS_FLAG
		RET

RES_PACKDOTS	ENDP


		public	SET_QUIKPACK
SET_QUIKPACK	PROC
		;
		SETT	QUIKPACK_FLAG

SET_SLRPACK	LABEL	PROC

		SETT	SLRPACK_SELECTED
if	any_overlays
		MOV	COMPRESS_BYTE,'Y'
endif
		JMP	SET_EXEPACK_1

SET_QUIKPACK	ENDP

endif



		.CONST

		ALIGN	4

EXE_TYPES	LABEL	DWORD

if	fg_pe
		DD	NT_STG,PE_EXE_TYPE
endif
		DD	WINDOWS_STG,WIN_SEGM_TYPE
		DD	OS2_STG,OS2_SEGM_TYPE
		DD	DOS_STG,DOS_EXE_TYPE
		DD	DOS4_STG,DOS4_SEGM_TYPE
		DD	DOSX_STG,DOSX_EXE_TYPE
		DD	UNKNOWN_STG,UNKNOWN_SEGM_TYPE

N_EXE_TYPES	EQU	($-EXE_TYPES)/8

SUBSYS_TYPES	LABEL	DWORD

		DD	PSUB_UNKNOWN_STG,PSUB_UNKNOWN
		DD	PSUB_NATIVE_STG,PSUB_NATIVE
		DD	PSUB_WIN_GUI_STG,PSUB_WIN_GUI
		DD	PSUB_WIN_CHAR_STG,PSUB_WIN_CHAR
		DD	PSUB_OS2_STG,PSUB_OS2
		DD	PSUB_POSIX_STG,PSUB_POSIX

N_SUBSYS_TYPES	EQU	($-SUBSYS_TYPES)/8


PSUB_UNKNOWN_STG	DB	'UNKNOWN',0
PSUB_NATIVE_STG		DB	'NATIVE',0
PSUB_WIN_GUI_STG	DB	'WINDOWS',0
PSUB_WIN_CHAR_STG	DB	'CONSOLE',0
PSUB_OS2_STG		DB	'OS2',0
PSUB_POSIX_STG		DB	'POSIX',0


		END

