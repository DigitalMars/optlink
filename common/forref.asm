		TITLE	FORREF - Copyright (c) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	SEGMENTS
		INCLUDE	IO_STRUC

		PUBLIC	FORREF,FORREF32,FORREF_CONT


		.DATA

		EXTERNDEF	CLASS_TYPE:BYTE,DEBUG_TYPES_SELECTED:BYTE

		EXTERNDEF	END_OF_RECORD:DWORD,FORREF_TYPE:DWORD,LDATA_SEGMOD_GINDEX:DWORD,LAST_DATA_PTR:DWORD

		EXTERNDEF	SEGMOD_LARRAY:LARRAY_STRUCT,SEGMOD_GARRAY:STD_PTR_S


		.CODE	PASS1_TEXT

		externdef	_forref_alloc:proc
		EXTERNDEF	FORREF_ALLOC:PROC,OBJ_PHASE:PROC,LEDATA_CONT:PROC,NBKPAT_VIRDEF_CONT:PROC


FORREF32:
		MOV	AL,MASK BIT_32+MASK BIT_FR
		JMP	FORREF_COMMON


FORREF		PROC
		;
		;DS:SI IS DATA RECORD
		;
		MOV	AL,MASK BIT_FR
FORREF_COMMON::
		MOV	ECX,END_OF_RECORD;CURSEG AVAILABLE...
		MOV	BPTR FORREF_TYPE,AL
		;
		;IF ASEG, IGNORE
		;IF CODEVIEW NOT SELECTED, BUT CODEVIEW SEGMENT, IGNORE
		;
		NEXT_INDEXI		;GET SEGMENT INDEX

		DEC	ECX

		SUB	ECX,ESI		;# OF BYTES IN RECORD
		JBE	OBJ_E		;PHASE

FORREF_NVIRDEF:
		CONVERT_LINDEX_EAX_EAX	SEGMOD_LARRAY,EDI

		MOV	LDATA_SEGMOD_GINDEX,EAX	;SEGMOD TO LINK THIS GUY TO...

		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		MOV	AL,[EAX]._SM_FLAGS	;FOR MEMORY ALLOCATION

		TEST	AL,MASK SEG_ASEG
		JNZ	SKIPIT			;SKIP ASEGS
		;
		;IS IT A DEBUG CLASS?
		;
		TEST	AL,MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1
		JNZ	SKIPIT_MAYBE		;MAYBE SKIP CV_INFO
SKIPIT_RET:
		MOV	CLASS_TYPE,AL
		MOV	AL,[ESI]

		INC	ESI
		MOV	BPTR FORREF_TYPE+1,AL
FORREF_CONT::
		MOV	EDI,ECX
		LEA	EAX,[ECX+SIZE FORREF_HEADER_TYPE]
SPEC_RET:
		sub	ESP,12
		mov	EDX,ESP
		push	EDX		; &EAX
		add	EDX,4
		push	EDX		; &ECX
		add	EDX,4
		push	EDX		; &EDX
		push	EAX
		call	_forref_alloc
		add	ESP,16
		test	EAX,EAX
		pop	EAX
		pop	ECX
		pop	EDX
		jnz	SPECIAL
;		CALL	FORREF_ALLOC	;EAX=BLOCK_BASE, ECX=PHYS
;		JC	SPECIAL

		MOV	EDX,EDI		;# IN FIRST BLOCK
SPEC_2:
		ASSUME	ECX:PTR FORREF_HEADER_TYPE
		MOV	[ECX]._FR_BLOCK_BASE,EAX

		XOR	EAX,EAX
		MOV	LAST_DATA_PTR,ECX

		MOV	[ECX]._FR_NEXT_FORREF,EAX

		MOV	EAX,FORREF_TYPE	;FORREF 16 OR 32

		SHL	EAX,16

		OR	EAX,EDI

		MOV	DPTR [ECX]._FR_LENGTH,EAX
		MOV	EAX,EBX			;SECOND BLOCK

		MOV	EBX,EDI			;# OF BYTES
		LEA	EDI,[ECX+ SIZEOF FORREF_HEADER_TYPE]	;DESTINATION

		MOV	ECX,EDX			;# IN FIRST BLOCK
		MOV	EDX,EAX			;SECOND BLOCK

		JMP	LEDATA_CONT	;JUST LIKE LEDATA

OBJ_E:
		JZ	SKIPIT_1

		CALL	OBJ_PHASE

		JMP	SKIPIT_1

SKIPIT_MAYBE:
		GETT	DL,CODEVIEW_FLAG
		MOV	AH,DEBUG_TYPES_SELECTED

		OR	DL,DL
		JZ	SKIPIT_1

		TEST	AL,MASK SEG_CV_TYPES1
		JNZ	SK_MB_TYPES
		;
		;MUST BE LOCAL SYMBOLS INFO
		;
		AND	AH,MASK FL_DEBUG_LOCALS
		JNZ	SKIPIT_RET

		JMP	SKIPIT

SK_MB_TYPES:
		TEST	AL,MASK SEG_CV_SYMBOLS1
		JNZ	SK_MB_NAMES

		AND	AH,MASK FL_DEBUG_TYPES
		JNZ	SKIPIT_RET

		JMP	SKIPIT_1

SK_MB_NAMES:
		AND	AH,MASK FL_DEBUG_TYPES + MASK FL_DEBUG_LOCALS
		JNZ	SKIPIT_RET
SKIPIT:
SKIPIT_1:
		XOR	EAX,EAX			;CLEAR ALL THIS SO FIXUPP

		MOV	LAST_DATA_PTR,EAX
		RET

SPECIAL:
		SUB	EDX,SIZE FORREF_HEADER_TYPE	;I WANT HEADER MINIMUM
		JC	SPEC1
		;
		;HARD ONE, SET UP STUFF FOR DOING IT CORRECTLY...
		;
		PUSHM	EAX,ECX,EDX
		OR	FORREF_TYPE,MASK BIT_CONT

		MOV	EAX,EDI
		MOV	LAST_DATA_PTR,ECX

		SUB	EAX,EDX

		sub	ESP,12
		mov	EDX,ESP
		push	EDX		; &EAX
		add	EDX,4
		push	EDX		; &ECX
		add	EDX,4
		push	EDX		; &EDX
		push	EAX
		call	_forref_alloc
		add	ESP,16
		pop	EAX
		pop	ECX
		pop	EDX
;		CALL	FORREF_ALLOC	;GET MORE...

		POP	EDX
		MOV	EBX,ECX

		POPM	ECX,EAX
		JMP	SPEC_2

SPEC1:
		DEC	DPTR [EAX]	;DON'T COUNT THAT GUY
		LEA	EAX,[EDI+SIZE FORREF_HEADER_TYPE]

		JMP	SPEC_RET

FORREF		ENDP


		END

