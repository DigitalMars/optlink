		TITLE	SEGMAP	- Copyright (c) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	SECTIONS
		INCLUDE	GROUPS
		INCLUDE	SEGMENTS
		INCLUDE	SYMBOLS
		INCLUDE	MODULES
		INCLUDE	CLASSES
		INCLUDE	CDDATA
if	fg_pe
		INCLUDE	PE_STRUC
endif
if	fg_dosx
		INCLUDE	EXES
endif

		PUBLIC	DO_SEGMENTS_GROUPS_MAP,ALLOW_SEGMENTS_MAP


		.DATA

		EXTERNDEF	XOUTBUF:BYTE,EXETYPE_FLAG:BYTE

		EXTERNDEF	FIRST_GROUP_GINDEX:DWORD,PE_BASE:DWORD,FIRST_SECTION_GINDEX:DWORD

		EXTERNDEF	SECTION_GARRAY:STD_PTR_S,SEGMENT_GARRAY:STD_PTR_S,CLASS_GARRAY:STD_PTR_S,SEGMOD_GARRAY:STD_PTR_S
		EXTERNDEF	MODULE_GARRAY:STD_PTR_S,SYMBOL_GARRAY:STD_PTR_S,GROUP_GARRAY:STD_PTR_S
		EXTERNDEF	SEGS_ORDERED_SEM:QWORD,PE_OBJECT_GARRAY:STD_PTR_S


		.CODE	MIDDLE_TEXT

		EXTERNDEF	_capture_eax:proc
		EXTERNDEF	_release_eax:proc
		EXTERNDEF	_release_eax_bump:proc
		EXTERNDEF	HEADER_OUT:PROC,MOVE_ASCIZ_ESI_EDI:PROC,SPACE_OUT:PROC,LINE_OUT:PROC,HEXWOUT:PROC,OUT5:PROC
		EXTERNDEF	GET_SM_MODULE:PROC,MOVEIT:PROC,UNUSE_SYMBOLS:PROC,_move_file_list_gindex_path_prim_ext:proc
		EXTERNDEF	CAPTURE_EAX:PROC,RELEASE_EAX_BUMP:PROC,HEXDWOUT:PROC


ALLOW_SEGMENTS_MAP	PROC
		;
		;
		;
if	fgh_mapthread
		BITT	_HOST_THREADED
		JZ	DO_SEGMENTS_GROUPS_MAP

		RELEASE_BUMP	SEGS_ORDERED_SEM

		RET
endif

ALLOW_SEGMENTS_MAP	ENDP


DO_SEGMENTS_GROUPS_MAP	PROC
		;
		;
		;
		BITT	SEGMENTS_MAP
		JNZ	L1$
		RET

SEG_GRP_VARS		STRUC

SEG_HEADER_HELPER_BP		DD	?	;**
OUT_GRP_HELPER_BP		DD	?	;**
OUT_SEG_HELPER_BP		DD	?	;**
SEG_CLASS_SPACE_BP		DD	?	;**
SEG_GROUP_SPACE_BP		DD	?	;**
WM_CURN_SECTION_GINDEX_BP	DD	?	;
WM_BASE_SEGMENT_GINDEX_BP	DD	?	;
WM_START_SM_GINDEX_BP		DD	?	;
WM_NEXT_SEGMOD_GINDEX_BP	DD	?	;
WM_DET_FRAME_BP			DD	?	;
WM_DET_OFFSET_BP		DD	?	;
WM_SM_COMDAT_GINDEX_BP		DD	?	;
WM_NEXT_SECTION_GINDEX_BP	DD	?

SEG_GRP_VARS		ENDS


FIX	MACRO	X

X	EQU	([EBP-SIZE SEG_GRP_VARS].(X&_BP))

	ENDM


FIX	SEG_HEADER_HELPER
FIX	OUT_GRP_HELPER
FIX	OUT_SEG_HELPER
FIX	SEG_CLASS_SPACE
FIX	SEG_GROUP_SPACE
FIX	WM_CURN_SECTION_GINDEX
FIX	WM_BASE_SEGMENT_GINDEX
FIX	WM_START_SM_GINDEX
FIX	WM_NEXT_SEGMOD_GINDEX
FIX	WM_DET_FRAME
FIX	WM_DET_OFFSET
FIX	WM_SM_COMDAT_GINDEX
FIX	WM_NEXT_SECTION_GINDEX


L1$:
		PUSH	EBP
		MOV	EBP,ESP
		ASSUME	EBP:PTR SEG_GRP_VARS

		SUB	ESP,SIZE SEG_GRP_VARS
		;
		;SET UP JUMP TABLE ENTRIES
		;
if	fg_pe
		MOV	ESI,OFF PE_STUFF
		BITT	OUTPUT_PE
		JNZ	DM_1
endif

if	fg_prot
		MOV	ESI,OFF PROT_STUFF
if	fg_norm_exe
		BITT	OUTPUT_SEGMENTED
		JNZ	DM_1
endif
endif

if	fg_dosx
		CMP	EXETYPE_FLAG,DOSX_EXE_TYPE
		MOV	ESI,OFF DOSX_STUFF
		JZ	DM_1
endif

if	fg_norm_exe
		MOV	ESI,OFF REAL_STUFF
DM_1:
endif

		LEA	EDI,SEG_HEADER_HELPER
		MOVSD
		LODSD
		BITT	PRINT_GROUP
		JNZ	DM_2
		SUB	EDI,4
		STOSD
DM_2:
		MOVSD
		MOVSD
		MOVSD
		MOVSD
		;
		CAPTURE	SEGS_ORDERED_SEM		;WAIT TILL SEGMENTS ARE ALIGNED

		YIELD

		CALL	SEGMENTS_MAP_OUTPUT

		BITT	DETAILEDMAP_FLAG
		JZ	L5$
		CALL	UNUSE_SYMBOLS			;DECREMENT NEED FOR SYMBOL TABLE
L5$:
if	fg_pe
		BITT	OUTPUT_PE
		JNZ	L6$
endif
		CALL	GROUPS_MAP
L6$:
		MOV	ESP,EBP
		POP	EBP
		RET

DO_SEGMENTS_GROUPS_MAP	ENDP


SEGMENTS_MAP_OUTPUT	PROC	NEAR
		;
		;
		;
		MOV	EAX,SEG_HEADER_HELPER		;OUTPUT HEADER PLEASE
		CALL	HEADER_OUT
		;
		;NOW OUTPUT SEGMENTS AND SIZES
		;
		MOV	EAX,FIRST_SECTION_GINDEX
		JMP	TEST_SECTION


SECTION_LOOP:
		MOV	WM_CURN_SECTION_GINDEX,EAX

if	any_overlays
		;
		;IF DOING OVERLAYS, PRINT SECTION # AND NAME
		;
		BITT	DOING_OVERLAYS
		JZ	SL_1
		CONVERT_GINDEX_AX_DSSI	SECTION_GARRAY
		MOV	AX,[SI]._SECT_PARENT_AREA_GINDEX
		CONVERT_GINDEX_AX_DSSI	AREA_GARRAY
		CMP	[SI]._AREA_LEVEL,0
		FIXDS
		LEA	SI,RESIDENT_MSG
		JZ	SL_0
		LEA	DI,OVERLAY_MSG_NUM
		XOR	DX,DX
		MOV	AX,WM_CURN_SECTION_GINDEX
		CALL	HEXDWOUTSH	;WIERD, HEX WORD OUT, SUPPRESS 0, H
		LEA	SI,OVERLAY_MSG
SL_0:
;		MOV	AX,SEG OVERLAY_MSG
		MOV	AX,CS
		CALL	HEADER_OUT
SL_1:
endif

		XOR	EAX,EAX
		MOV	ESI,WM_CURN_SECTION_GINDEX

		MOV	WM_BASE_SEGMENT_GINDEX,EAX
		;
		;OK, START THROUGH MY SEGMODS
		;
		CONVERT	ESI,ESI,SECTION_GARRAY
		ASSUME	ESI:PTR SECTION_STRUCT

		MOV	ECX,[ESI]._SECT_NEXT_SECTION_GINDEX
		MOV	ESI,[ESI]._SECT_FIRST_SEGMOD_GINDEX

		MOV	WM_NEXT_SECTION_GINDEX,ECX
		JMP	TEST_SEGMOD

SEGMOD_LOOP:
		ASSUME	ESI:PTR SEGMOD_STRUCT
		;
		;THIS IS A NEW SEGMENT
		;
		MOV	EAX,[ESI]._SM_BASE_SEG_GINDEX
		MOV	WM_START_SM_GINDEX,ECX	;FOR USE BY DETAILED OUTPUT
		MOV	WM_BASE_SEGMENT_GINDEX,EAX
SEGMENT_LOOP:
		MOV	AL,' '
		MOV	EDI,OFF XOUTBUF+1

		MOV	XOUTBUF,AL
		MOV	ESI,WM_BASE_SEGMENT_GINDEX
		CONVERT	ESI,ESI,SEGMENT_GARRAY
		ASSUME	ESI:PTR SEGMENT_STRUCT

		CALL	OUT_SEG_HELPER		;OUTPUT NUMBERS
		;
		;NOW NAME
		;
		MOV	EBX,[ESI]._SEG_GROUP_GINDEX
		MOV	CL,[ESI]._SEG_32FLAGS

		PUSHM	EBX,ECX

		MOV	EAX,[ESI]._SEG_CLASS_GINDEX
		LEA	ESI,[ESI]._SEG_TEXT	;MOVE SEGMENT NAME...

		PUSH	EAX
		CALL	MOVE_ASCIZ_ESI_EDI

		MOV	ECX,SEG_CLASS_SPACE
		CALL	SPACE_OUT

		POP	ESI
		CONVERT	ESI,ESI,CLASS_GARRAY

		ADD	ESI,CLASS_STRUCT._C_TEXT 	;PRINT CLASS NAME
		CALL	MOVE_ASCIZ_ESI_EDI

		POP	EAX
		POP	EBX			;GROUP INDEX

		TEST	AL,MASK SEG32_USE32
		JZ	L5$

		MOV	ECX,SIZEOF USE32_TXT
		MOV	ESI,OFF USE32_TXT
		REP	MOVSB
L5$:
		TEST	EBX,EBX
		JZ	NO_GROUP

		GETT	AL,PRINT_GROUP

		TEST	AL,AL
		JZ	NO_GROUP


		CONVERT	ESI,EBX,GROUP_GARRAY
		MOV	ECX,SEG_GROUP_SPACE

		ADD	ESI,GROUP_STRUCT._G_TEXT
		CALL	SPACE_OUT

		CALL	MOVE_ASCIZ_ESI_EDI
NO_GROUP:
		CALL	LINE_OUT

		CALL	DETAILED_SEGMENTS
NEXT_SEGMOD:
		MOV	ESI,WM_NEXT_SEGMOD_GINDEX	;SET BY OUT_SEG_HELPER
TEST_SEGMOD:
		MOV	ECX,ESI
		TEST	ESI,ESI
		JZ	END_OF_SECTION
		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

		
		MOV	AL,[ESI]._SM_FLAGS

		TEST	AL,MASK SEG_ASEG+MASK SEG_CV_TYPES1 + MASK SEG_CV_SYMBOLS1
		JZ	SEGMOD_LOOP	;SKIP ASEG AND DEBUG SEGMENTS
NEXT_SEGMENT1:
if	fg_rom
		TEST	[SI]._SM_TYPE,MASK SEG_ASEG
		JZ	NEXT_SECTION
		BITT	OUTPUT_ABS
		JZ	NEXT_SEGMENT
		MOV	AX,NUL_PTR.OFFS 	;SKIP IF NUL NAME
		CMP	[BX]._SEG_NAME.OFFS,AX
		JNZ	SEGMENT_LOOP1
		MOV	AX,NUL_PTR.SEGM
		CMP	[BX]._SEG_NAME.SEGM,AX
		JZ	NEXT_SEGMENT
SEGMENT_LOOP1:
		JMP	SEGMENT_LOOP
else
;		JMP	NEXT_SECTION
endif

END_OF_SECTION:
NEXT_SECTION:
		MOV	EAX,WM_NEXT_SECTION_GINDEX
TEST_SECTION:
		TEST	EAX,EAX
		JNZ	SECTION_LOOP
EOS:
END_OF_SEGMENTS:
		RET

SEGMENTS_MAP_OUTPUT	ENDP


if	fg_prot

OUT_SEG_PROT	PROC	NEAR
		;
		;OUTPUT SEGMENTED-MODE SEGMENTS
		;
		ASSUME	ESI:PTR SEGMENT_STRUCT

		MOV	EAX,[ESI]._SEG_OS2_NUMBER
		CALL	HEXWOUT

		MOV	EAX,[ESI]._SEG_OFFSET
		MOV	BPTR [EDI],':'

		INC	EDI
		CALL	HEXWOUT

		MOV	EAX,[ESI]._SEG_LEN
		MOV	BPTR [EDI],' '

		INC	EDI
		CALL	OUT5

		MOV	ECX,OFF XOUTBUF+22
		CALL	SPACE_OUT
		;
		;NOW SKIP SEGMODS TILL NEW SEGMENT
		;
		MOV	EAX,WM_START_SM_GINDEX
		MOV	EBX,WM_BASE_SEGMENT_GINDEX
L2$:
		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		MOV	EDX,[EAX]._SM_BASE_SEG_GINDEX
		MOV	EAX,[EAX]._SM_NEXT_SEGMOD_GINDEX

		CMP	EDX,EBX
		JNZ	L4$

		MOV	ECX,EAX

		TEST	EAX,EAX
		JNZ	L2$
L4$:
		MOV	WM_NEXT_SEGMOD_GINDEX,ECX

		RET

OUT_SEG_PROT	ENDP

endif

if	fg_pe


OUT_SEG_PE	PROC	NEAR
		;
		;OUTPUT PE-MODE SEGMENTS
		;
		ASSUME	ESI:PTR SEGMENT_STRUCT

		MOV	EAX,[ESI]._SEG_PEOBJECT_NUMBER
		CALL	HEXWOUT

		MOV	EAX,[ESI]._SEG_LEN
		MOV	BPTR [EDI],':'

		MOV	EDX,[ESI]._SEG_PEOBJECT_GINDEX
		PUSH	EAX

		INC	EDI
		MOV	EAX,[ESI]._SEG_OFFSET

		CONVERT	EDX,EDX,PE_OBJECT_GARRAY
		ASSUME	EDX:PTR PE_OBJECT_STRUCT

		MOV	EBX,[EDX]._PEOBJECT_RVA
		MOV	ECX,PE_BASE

		SUB	EAX,EBX

		SUB	EAX,ECX
		CALL	HEXDWOUT

		POP	EAX
		MOV	BPTR [EDI],' '

		INC	EDI
		CALL	HEXDWOUT

		MOV	ECX,OFF XOUTBUF+26
		MOV	BPTR [EDI],'H'

		INC	EDI
		CALL	SPACE_OUT
		;
		;NOW SKIP SEGMODS TILL NEW SEGMENT
		;
		MOV	EAX,WM_START_SM_GINDEX
		MOV	EBX,WM_BASE_SEGMENT_GINDEX
L2$:
		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		MOV	EDX,[EAX]._SM_BASE_SEG_GINDEX
		MOV	EAX,[EAX]._SM_NEXT_SEGMOD_GINDEX

		CMP	EDX,EBX
		JNZ	L4$

		MOV	ECX,EAX

		TEST	EAX,EAX
		JNZ	L2$
L4$:
		MOV	WM_NEXT_SEGMOD_GINDEX,ECX

		RET

OUT_SEG_PE	ENDP

endif


if	fg_norm_exe


OUT_SEG_REAL	PROC	NEAR
		;
		;WM_START_SM YIELDS BASE, SCAN FOR MAX LENGTH
		;
		ASSUME	ESI:PTR SEGMENT_STRUCT

		MOV	EAX,[ESI]._SEG_OFFSET
		CALL	OUT5

		MOV	ECX,[ESI]._SEG_LEN
		MOV	EAX,[ESI]._SEG_OFFSET

		PUSH	ECX
		ADD	EAX,ECX
		;
		;NOW PRINT MAX ADDRESS		ECX IS MAX OFFSET FROM SEGMENT
		;
		TEST	ECX,ECX
		JZ	L41$

		DEC	EAX
L41$:
		CALL	OUT5

		POP	EAX
		CALL	OUT5
		;
		;NOW SKIP SEGMODS TILL NEW SEGMENT
		;
		MOV	EAX,WM_START_SM_GINDEX
		MOV	EBX,WM_BASE_SEGMENT_GINDEX
L2$:
		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		MOV	EDX,[EAX]._SM_BASE_SEG_GINDEX
		MOV	EAX,[EAX]._SM_NEXT_SEGMOD_GINDEX

		CMP	EDX,EBX
		JNZ	L4$

		MOV	ECX,EAX

		TEST	EAX,EAX
		JNZ	L2$
L4$:
		MOV	WM_NEXT_SEGMOD_GINDEX,ECX

		RET

OUT_SEG_REAL	ENDP

endif


if	fg_dosx


OUT_SEG_DOSX	PROC	NEAR
		;
		;WM_START_SM YIELDS BASE, SCAN FOR MAX LENGTH
		;
		ASSUME	ESI:PTR SEGMENT_STRUCT

		MOV	EAX,[ESI]._SEG_OFFSET
		CALL	OUT8

		MOV	ECX,[ESI]._SEG_LEN
		MOV	EAX,[ESI]._SEG_OFFSET

		PUSH	ECX
		ADD	EAX,ECX
		;
		;NOW PRINT MAX ADDRESS		ECX IS MAX OFFSET FROM SEGMENT
		;
		TEST	ECX,ECX
		JZ	L41$

		DEC	EAX
L41$:
		CALL	OUT8

		POP	EAX
		CALL	OUT8
		;
		;NOW SKIP SEGMODS TILL NEW SEGMENT
		;
		MOV	EAX,WM_START_SM_GINDEX
		MOV	EBX,WM_BASE_SEGMENT_GINDEX
L2$:
		CONVERT	EAX,EAX,SEGMOD_GARRAY
		ASSUME	EAX:PTR SEGMOD_STRUCT

		MOV	EDX,[EAX]._SM_BASE_SEG_GINDEX
		MOV	EAX,[EAX]._SM_NEXT_SEGMOD_GINDEX

		CMP	EDX,EBX
		JNZ	L4$

		MOV	ECX,EAX

		TEST	EAX,EAX
		JNZ	L2$
L4$:
		MOV	WM_NEXT_SEGMOD_GINDEX,ECX

		RET

OUT_SEG_DOSX	ENDP


OUT8		PROC
		;
		;
		;
		CALL	HEXDWOUT

		MOV	WPTR [EDI],' H'
		ADD	EDI,2

		RET

OUT8		ENDP


endif


DETAILED_SEGMENTS	PROC	NEAR
		;
		;WM_START_SM IS FIRST SEGMOD TO DO
		;
		GETT	AL,DETAILEDMAP_FLAG
		MOV	ESI,WM_BASE_SEGMENT_GINDEX

		OR	AL,AL
		JNZ	L0$

		RET

L0$:
		CONVERT	ESI,ESI,SEGMENT_GARRAY
		ASSUME	ESI:PTR SEGMENT_STRUCT

		MOV	AL,[ESI]._SEG_COMBINE
		MOV	ECX,[ESI]._SEG_FRAME
		;
		;COMMON, PRIVATE, PUBLIC, STACK, ASEG
		;
		AND	EAX,0FFH

		TEST	AL,AL
		JNS	L2$

		MOV	AL,3		;CALL IT ABSOLUTE

L2$:
		MOV	EDX,[ESI]._SEG_OFFSET
		MOV	WM_DET_FRAME,ECX

		MOV	WM_DET_OFFSET,EDX
		MOV	EAX,DETAIL_TYPE[EAX*4]

		MOV	EDI,OFF XOUTBUF
		PUSH	EAX

		MOV	ESI,OFF TYPE_EQ
		CALL	MOVEIT

		POP	ESI
		CALL	MOVEIT

		MOV	ESI,OFF SEGM_BASE_MSG
		CALL	MOVEIT
		;
		;CALCULATE FRAME AND PRINT IT
		;SAVE DX AS OFFSET TO SUBTRACT EVERYWHERE...
		;
if	fg_pe
		GETT	AL,OUTPUT_PE

		TEST	AL,AL
		JZ	L31$

		MOV	EAX,WM_DET_OFFSET
		CALL	HEXDWOUT
		JMP	L39$
endif

L31$:
		MOV	EAX,WM_DET_FRAME

if	fg_segm
		GETT	BL,OUTPUT_SEGMENTED

		OR	BL,BL
		JZ	L32$

		CALL	HEXWOUT

		MOV	EAX,WM_DET_OFFSET
		MOV	BPTR [EDI],':'

		INC	EDI
		CALL	HEXWOUT

		JMP	L39$

endif

L32$:

if	fg_norm_exe
		SHR	EAX,4
		CALL	HEXWOUT

		MOV	EAX,WM_DET_OFFSET
		MOV	EBX,WM_DET_FRAME

		SUB	EAX,EBX
		MOV	BPTR [EDI],':'

		INC	EDI
		CALL	HEXWOUT
endif

L39$:
		CALL	LINE_OUT

		MOV	ESI,WM_START_SM_GINDEX
		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

L4$:
		MOV	EBX,[ESI]._SM_NEXT_SEGMOD_GINDEX
		MOV	EAX,[ESI]._SM_START	;STARTING ADDRESS

		PUSH	EBX

		CALL	DET_SUB_1		;SUB SEG_OFFSET AND PRINT

		MOV	EDX,[ESI]._SM_LEN
		MOV	EBX,[ESI]._SM_START

		MOV	EAX,EDX
		SUB	EDX,EBX

		JZ	L41$

		DEC	EAX
L41$:
		CALL	DET_SUB_1		;SUB SEG_OFFSET AND PRINT

		MOV	EAX,[ESI]._SM_LEN
		MOV	EBX,[ESI]._SM_START

		SUB	EAX,EBX
		CALL	OUT5			;PRINT IT

		MOV	AL,[ESI]._SM_FLAGS_2
		XOR	ECX,ECX

		TEST	AL,MASK SM2_COMDAT	;DOES THIS SEGMOD BELONG TO A COMDAT?
		JZ	L42$

		ASSUME	ESI:PTR CDSEGMOD_STRUCT
		MOV	ECX,[ESI]._CDSM_COMDAT_GINDEX
		ASSUME	ESI:PTR SEGMOD_STRUCT

L42$:
		MOV	WM_SM_COMDAT_GINDEX,ECX
		MOV	EAX,ESI
		CALL	GET_SM_MODULE			;DS:SI IS PHYSICAL SEGMOD, AX RETURNS PARENT MODULE

		PUSH	EAX

		MOV	ESI,OFF MODULE_TXT
		CALL	MOVEIT

		POP	EAX

		TEST	EAX,EAX		;IS THERE A MODULE?
		JZ	L6$

		PUSH	EAX
		CONVERT	EAX,EAX,MODULE_GARRAY
		ASSUME	EAX:PTR MODULE_STRUCT

		MOV	ECX,[EAX]._M_FILE_LIST_GINDEX
		MOV	EAX,EDI

		TEST	ECX,ECX
		JZ	L51$

		push	ECX
		push	EAX
		call	_move_file_list_gindex_path_prim_ext
		add	ESP,8

L51$:
		LEA	EDI,[EAX+1]
		POP	ESI
		MOV	BPTR [EAX],'('

		CONVERT	ESI,ESI,MODULE_GARRAY
		ADD	ESI,MODULE_STRUCT._M_TEXT
		CALL	MOVE_ASCIZ_ESI_EDI

		MOV	ESI,WM_SM_COMDAT_GINDEX
		MOV	BPTR [EDI],')'

		INC	EDI

		TEST	ESI,ESI		;COMDAT?
		JZ	L6$
		CONVERT	ESI,ESI,SYMBOL_GARRAY
		ADD	ESI,SYMBOL_STRUCT._S_NAME_TEXT

		MOV	WPTR [EDI],'[ '
		ADD	EDI,2

		CALL	MOVE_ASCIZ_ESI_EDI

		MOV	BPTR [EDI],']'
		INC	EDI

L6$:
		CALL	LINE_OUT
L8$:
		POP	ESI

		TEST	ESI,ESI
		JZ	L85$

		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

		MOV	EAX,[ESI]._SM_BASE_SEG_GINDEX
		MOV	EBX,WM_BASE_SEGMENT_GINDEX

		CMP	EBX,EAX
		JZ	L4$
L85$:
		MOV	EDI,OFF XOUTBUF
		CALL	LINE_OUT

		RET

DETAILED_SEGMENTS	ENDP



DET_SUB_1	PROC	NEAR
		;
		;
		;
if	fg_pe OR fg_dosx

		GETT	DL,OUTPUT_PE
		MOV	CL,EXETYPE_FLAG

		TEST	DL,DL
		JNZ	OUT8

		CMP	CL,DOSX_EXE_TYPE
		JZ	OUT8

		JMP	OUT5

else
		JMP	OUT5
endif

DET_SUB_1	ENDP


GROUPS_MAP	PROC	NEAR
		;
		;
		;
		MOV	EAX,OFF GROUP_HEADER
		CALL	HEADER_OUT

		MOV	ESI,FIRST_GROUP_GINDEX
		JMP	GROUP_TEST

GROUP_LOOP:
		PUSH	EAX			;SAVE GROUP GINDEX
		;
		;OUTPUT ADDRESS...
		;
		MOV	AL,' '

		MOV	EDI,OFF XOUTBUF+1
		MOV	XOUTBUF,AL

		CALL	OUT_GRP_HELPER

		MOV	DPTR [EDI],'    '
		ADD	EDI,3

		ADD	ESI,GROUP_STRUCT._G_TEXT
		CALL	MOVE_ASCIZ_ESI_EDI

		CALL	LINE_OUT
		POP	ESI
GROUP_TEST:
		TEST	ESI,ESI
		JZ	GROUP_DONE

		CONVERT	ESI,ESI,GROUP_GARRAY
		ASSUME	ESI:PTR GROUP_STRUCT

		MOV	BL,[ESI]._G_TYPE
		MOV	EAX,[ESI]._G_NEXT_GROUP_GINDEX

		AND	BL,MASK SEG_ASEG
		JZ	GROUP_LOOP
if	fg_rom
		BITT	OUTPUT_ABS
		JNZ	GROUP_LOOP
endif
		JMP	GROUP_TEST
		;
GROUP_DONE:
		RET

GROUPS_MAP	ENDP


		ASSUME	ESI:PTR GROUP_STRUCT

if	fg_prot

OUT_GRP_PROT	PROC	NEAR
		;
		;
		;
		MOV	EAX,[ESI]._G_OS2_NUMBER
		CALL	HEXWOUT

		MOV	WPTR [EDI],'0:'
		ADD	EDI,2

		RET

OUT_GRP_PROT	ENDP

endif


if	fg_norm_exe

OUT_GRP_REAL	PROC	NEAR
		;
		;
		;
		MOV	EAX,[ESI]._G_OFFSET
		CALL	OUT5

		MOV	BL,':'
		MOV	AL,[EDI-3]

		MOV	[EDI-3],BL

		MOV	[EDI-2],AL
		DEC	EDI

		RET

OUT_GRP_REAL	ENDP

endif

if	fg_pe

OUT_GRP_PE	PROC	NEAR
		;
		;
		;
		RET

OUT_GRP_PE	ENDP

endif


		.CONST


		ALIGN	4
if	fg_prot

PROT_STUFF	DD	SEG_HEADER_PROT_G,SEG_HEADER_PROT,OUT_GRP_PROT,OUT_SEG_PROT,XOUTBUF+45,XOUTBUF+62

endif

if	fg_norm_exe

REAL_STUFF	DD	SEG_HEADER_REAL_G,SEG_HEADER_REAL,OUT_GRP_REAL,OUT_SEG_REAL,XOUTBUF+45,XOUTBUF+62

endif

if	fg_dosx

DOSX_STUFF	DD	SEG_HEADER_DOSX_G,SEG_HEADER_DOSX,OUT_GRP_REAL,OUT_SEG_DOSX,XOUTBUF+54,XOUTBUF+71

endif

if	fg_pe

PE_STUFF	DD	SEG_HEADER_PE_G,SEG_HEADER_PE,OUT_GRP_PE,OUT_SEG_PE,XOUTBUF+49,XOUTBUF+66

endif

		ALIGN	4

DETAIL_TYPE	DD	TYPE_PRIVATE
		DD	TYPE_MEMORY
		DD	TYPE_PUBLIC
		DD	TYPE_ABSOLUTE
		DD	TYPE_UNKNOWN
		DD	TYPE_STACK
		DD	TYPE_COMMON

GROUP_HEADER	DB	SIZEOF GROUP_HEADER-1,0DH,0AH,\
			' Origin   Group',0DH,0AH

if	fg_prot

SEG_HEADER_PROT_G DB	SIZEOF SEG_HEADER_PROT_G-1,0DH,0AH,\
			' Start     Length     Name                   Class',\
			'            Group',\
			0DH,0AH

SEG_HEADER_PROT DB	SIZEOF SEG_HEADER_PROT-1,0DH,0AH,\
			' Start     Length     Name                   Class',\
			0DH,0AH

endif

if	fg_norm_exe

SEG_HEADER_REAL_G 	DB	SIZEOF SEG_HEADER_REAL_G-1,0DH,0AH,\
			' Start  Stop   Length Name                   Class',\
			'            Group',\
			0DH,0AH

SEG_HEADER_REAL DB	SIZEOF SEG_HEADER_REAL-1,0DH,0AH,\
			' Start  Stop   Length Name                   Class',\
			0DH,0AH

endif


if	fg_dosx

SEG_HEADER_DOSX_G 	DB	SIZEOF SEG_HEADER_DOSX_G-1,0DH,0AH,\
			' Start     Stop      Length    Name                   Class',\
			'            Group',\
			0DH,0AH

SEG_HEADER_DOSX	DB	SIZEOF SEG_HEADER_DOSX-1,0DH,0AH,\
			' Start     Stop      Length    Name                   Class',\
			0DH,0AH

endif


if	fg_pe

SEG_HEADER_PE_G DB	SIZEOF SEG_HEADER_PE_G-1,0DH,0AH,\
			' Start         Length     Name                   Class',\
			'            Group',\
			0DH,0AH

SEG_HEADER_PE	DB	SIZEOF SEG_HEADER_PE-1,0DH,0AH,\
			' Start         Length     Name                   Class',\
			0DH,0AH

endif

TYPE_EQ 	DB	SIZEOF TYPE_EQ-1,'Type='

TYPE_PRIVATE	DB	SIZEOF TYPE_PRIVATE-1,'Private'
TYPE_MEMORY	DB	SIZEOF TYPE_MEMORY-1,'Memory'
TYPE_PUBLIC	DB	SIZEOF TYPE_PUBLIC-1,'Public'
TYPE_ABSOLUTE	DB	SIZEOF TYPE_ABSOLUTE-1,'Absolute'
TYPE_UNKNOWN	DB	SIZEOF TYPE_UNKNOWN-1,'Unknown'
TYPE_STACK	DB	SIZEOF TYPE_STACK-1,'Stack'
TYPE_COMMON	DB	SIZEOF TYPE_COMMON-1,'Common'

SEGM_BASE_MSG	DB	SIZEOF SEGM_BASE_MSG-1,'  Base Address='

MODULE_TXT	DB	SIZEOF MODULE_TXT-1,'  Module='

USE32_TXT	DB	' 32-bit'


if	any_overlays
RESIDENT_MSG	DB	SIZEOF RESIDENT_MSG-1,' Resident',0dh,0ah
OVERLAY_MSG	DB	SIZEOF OVERLAY_MSG-1,' Overlay      ',0dh,0ah
OVERLAY_MSG_NUM EQU	OVERLAY_MSG+10
endif

		END

