
module io_struc;

const CH_SPC		=	0;
const CH_SEP		=	4;
const CH_AT		=	8;
const CH_SEMI	 	=	12;
const CH_NL		=	16;
const CH_ESC		=	20;
const CH_NEXT		=	24;

struct NFN_STRUCT
{

    ubyte NFN_FLAGS;
    ubyte NFN_TYPE;
    ushort reserved1;
    ushort NFN_TIME;
    ushort NFN_DATE;
    int NFN_FILE_LENGTH ;
    int NFN_PATHLEN;
    int NFN_PRIMLEN;
    int NFN_EXTLEN;	// length of .ext, including '.'
    int NFN_TOTAL_LENGTH;
    ubyte[NFN_TEXT_SIZE] NFN_TEXT;

}

enum NFN_RECORD
{
	NFN_AMBIGUOUS = 1,
	NFN_PATH_SPECIFIED = 2,
	NFN_EXT_SPECIFIED = 4,
	NFN_PRIM_SPECIFIED = 8,
	NFN_NUL = 0x10,
	NFN_TIME_VALID = 0x20,
}

const NFN_OBJ_TTYPE	=	0;
const NFN_LIB_TTYPE	=	1;
const NFN_OLD_TTYPE	=	2;
const NFN_STUB_TTYPE	=	3;
const NFN_RES_TTYPE	=	4;
const NFN_DEF_TTYPE	=	5;
const NFN_LOD_TTYPE	=	6;

enum FNTBL_RECORD
{
	IS_NUMERIC		= 1,
	IS_ALPHA		= 2,
	FNTBL_ILLEGAL		= 4,
	FNTBL_PATH_SEPARATOR	= 8,
	FNTBL_AMBIGUOUS		= 0x10,
	FNTBL_DOT		= 0x20,
	SYMTBL_ILLEGAL		= 0x40,
}

struct FILE_LISTS
{

    int FILE_LAST_GINDEX;	// THESE ARE GINDEXES
    int FILE_FIRST_GINDEX;
}

struct FILE_LIST_STRUCT
{
    int FILE_LIST_NEXT_GINDEX;		// NEXT LOGICALLY
    int FILE_LIST_HASH_NEXT_GINDEX;	// NEXT THIS HASH
    int FILE_LIST_PATH_GINDEX;		// SEARCH PATH USED TO FIND THIS FILE
    version(any_overlays)
    {
	int FILE_LIST_SECTION_GINDEX;
    }
    ubyte FILE_LIST_PLTYPE;		// SECTION_ASSIGNED, LEVEL_0_
    ubyte FILE_LIST_PLINK_FLAGS;	// LIB_ALLOCATE, ETC
    ubyte FILE_LIST_FLAGS ;		// MOD_ADD, MOD_IGNORE, ETC
    ubyte FILE_LIST_TYPE;		// MOD_TYPE, OBJ, LIB, ETC

    version(fgh_inthreads)
    {
	int FILE_LIST_MY_NEXT_GINDEX;	// NEXT THIS THREAD (OS/2)
	int FILE_LIST_THREAD;		// THREAD OWNER
    }
    int FILE_LIST_HASH;			// HASH VALUE

    NFN_STRUCT FILE_LIST_NFN;

}

const FILE_LIST_PREV		=	FILE_LIST_MY_NEXT;

	// NO_VECTOR WAS IN HERE...


struct PLINK_FLAGS
{
	LIB_ALLOCATE:1,
	FL_DEBUG_TYPES:1,
	FL_DEBUG_PUBLICS:1,
	FL_DEBUG_LOCALS:1,
	FL_DEBUG_LINNUMS:1,
	FL_DEBUG_COVERAGES:1,
	FL_DEBUG_BROWSERDEFS:1,
	FL_DEBUG_BROWSERREFS:1
}

struct FL_FLAGS
{
	FLF_RANDOM:1,
	MOD_DELETE:1,
	MOD_EXTRACT:1,
	MOD_TBR:1,
	MOD_UNAMBIG:1,
	MOD_ADD:1,
	MOD_IGNORE:1

	// 0	OBJ FILE
	// 1	LIBRARY
	// 2	OLD
	// 3	STUB
	// 4	RESOURCE
}

struct MYO_STRUCT
{   // ********** MUST MATCH MYI ********
    int MYO_COUNT;
    int MYO_HANDLE;
    int MYO_PTR ;
    int MYO_BLOCK;	// BASE ADDRESS
    int MYO_FILE_LENGTH;
    int MYO_BYTE_OFFSET ;
    int MYO_PHYS_ADDR;
    DCA MYO_FLUSHBUF;
    int MYO_FILE_LIST_GINDEX;
    int MYO_BUSY;
    ushort MYO_TIME;
    // *********************************
    ushort MYO_DATE;

    int MYO_BYTES;
    int MYO_DESPOT;	// DESIRED FILE POSITION
    ubyte MYO_SPEC_FLAGS;
    ubyte MYO_TYPE_FLAGS;
    ushort reserved;

    version(fgh_outhreads)
    {
	int MYO_BYTE_OFFSET2;
    }
    // ushort MYO_CURN_BUFFER;
    // ushort MYO_STACK_SEGMENT;
}

version(fgh_inthreads)
{

struct OPEN_STRUCT
{
    int OPENFILE_HANDLE ;	// HANDLE OF OPEN FILE
    int OPENFILE_FLAGS;		// NZ ON OPEN IF LIBRARY FILE

    int OPENFILE_NAME;		// IN MYI2_NAMS

    int OPENFILE_ADDR;		// CURRENT PHYSICAL ADDRESS

    ubyte[16] OPENFILE_HEADER;	// LIBRARY FILE HEADER

    // ushort OPENFILE_TIME;	// TIME STAMP ON FILE
    // ushort OPENFILE_DATE;	// DATE STAMP ON FILE

    int OPENFILE_PATH_GINDEX;	// IF FOUND BY SEARCHING A PATH...
}


struct INPUT_STRUCT
{
    int INS_BLOCK;	// BLOCK ADDRESS
    int INS_BYTES;	// # OF BYTES READ

    int INS_OPENFILE;	// PTR BACK TO OPENFILE ENTRY
}


struct OUTPUT_STRUCT
{
    GLOBALSEM_STRUCT OUT_FULL_SEM;
    GLOBALSEM_STRUCT OUT_AVAIL_SEM;

    int OUT_ADDR;
    int OUT_BUFFER;
    int OUT_PTR;
    int OUT_BYTES;

    ubyte OUT_FLAGS;
    ubyte reserved1;	// EVEN
    ushort reserved2;
}


struct MYO2_STRUCT
{
    int MYO2_NEXT_FULL_BUFFER;
    int MYO2_NEXT_AVAIL_BUFFER;

    int MYO2_THREAD_ID;
    int MYO2_NUM_HANDLES ;

    int MYO2_RESULT;
    int MYO2_WRITE_FLAGS;

    GLOBALSEM_STRUCT MYO2_TERM_SEM;

    ubyte[16] MYO2_TND_BUF;

    OUTPUT_STRUCT[4] MYO2_OUT_STRUC;
    ubyte[NFN_STRUCT.sizeof] MYO2_NFN;
    ubyte[NFN_TEXT_SIZE + 4] MYO2_ASCIZ;
}

}

struct F_FLAGS
{
	F_SEEK_FIRST:1,
	F_TRUNC_FILE:1,
	F_CLOSE_FILE:1,
	F_CLEAR_BLOCK:1,
	F_RELEASE_BLOCK:1,
	F_SET_TIME:1
}

struct MYI_STRUCT
{
	// ************ MUST MATCH MYO ****************

    int MYI_COUNT;		// BYTES LEFT IN BUFFER
    int MYI_HANDLE;
    int MYI_PTRA ;		// READ/WRITE POINTER
    int MYI_BLOCK;		// BASE ADDRESS OF CURRENT BUFFER
    int MYI_FILE_LENGTH;
    int MYI_BYTE_OFFSET;	// ADDR AT BEGINNING OF BLOCK
    int MYI_PHYS_ADDR;		// CURRENT FILE POSITION (ADDR AT END OF BLK)
    int MYI_FILLBUF;		// FUNCTION TO FILL BUFFER
    int MYI_FILE_LIST_GINDEX;	// POINTS TO FN_STRUCT (MYI_NAM)
    int MYI_BUSY;
    ushort MYI_TIME;
	// *********************************
    ushort MYI_DATE;

	// ********************************************

    ushort MYI_CURRENT_TYPE;	// NON-ZERO IS LIBRARY
    ubyte MYI_BUFCNT;
    ubyte reserved;

    version(fgh_inthreads)
    {
	int MYI_LOCALS;
    }
}


version(fgh_inthreads)
{

struct MYI2_STRUCT
{
    // THIS STUFF IN SEPARATE SEGMENT PER THREAD

    int MYI2_NEXT_OPEN_STRUC;	// 0-3, NEXT OPENFILE STRUCTURE TO USE BY ME
    int MYI2_NEXT_OPEN_FILE;	// NEXT FILE TO BE 'OPENED' BY THREAD 1

    int MYI2_NEXT_16K_BLOCK;	// NEXT BLOCK TO BE READ BY THREAD 1
    int MYI2_OPREAD_THREAD_ID;
    int MYI2_OPREAD_THREAD_HANDLE;

    int MYI2_LAST_OPENFILE;
    int MYI2_NUM_HANDLES ;	// NUMBER OF HANDLES WHEN I STARTED THIS OPEN

    int MYI2_LAST_FILENAME_OPENED_GINDEX;

    FILE_LISTS MYI2_OBJ_LIST;	// FILES LINKED TO ME

    GLOBALSEM_STRUCT MYI2_FILENAME_LIST_SEM;	// CLEARED WHEN MY FILE LIST HAS BEEN MODIFIED...

    FIRST_MYI2_SEMAPHORE	=	<MYI2_FILENAME_LIST_SEM>

    GLOBALSEM_STRUCT OPENFILE_AVAIL_SEM;	// IN-USE SEMAPHORE
    GLOBALSEM_STRUCT OPENFILE_OPEN_SEM;		// FILE OPEN SEMAPHORE
    GLOBALSEM_STRUCT OPENFILE_HEADER_SEM;	// HEADER-IS-VALID SEMAPHORE

    GLOBALSEM_STRUCT INS_FULL_SEM;	// BLOCK HAS BEEN READ FLAG
    GLOBALSEM_STRUCT INS_AVAIL_SEM;	// THIS ENTRY AVAILABLE FLAG

    const N_MYI2_SEMAPHORES = 6;

    int MYI2_RESULT;
    int MYI2_NEXT_FILE_BUFFER;
    int MYI2_OPEN_FLAGS;

    ubyte MYI2_TYPE;		// NON-ZERO IS
    ubyte MYI2_THREAD_NUM;	// 0-3
    ushort MYI2_LAST_OPEN_ERROR;

    ubyte[0x40] MYI2_TEMP_RECORD;

    INPUT_STRUCT[4] MYI2_INPUT_STRUC;

    OPEN_STRUCT[4] MYI2_OPEN_STRUC;

    // ubyte[NFN_TEXT_SIZE+4] MYI2_ASCIZ;
    // ubyte[64] MYI2_QFH_BUFFER;

    NFN_STRUCT[4] MYI2_NAMS;
}


struct MYL2_STRUCT
{
    // THIS STUFF IN SEPARATE SEGMENT PER THREAD

    // GLOBALSEM_STRUCT MYL2_TERM_SEM;

    GLOBALSEM_STRUCT MYL2_LIB_BLOCK_SEM;	// LIBREAD WAITS ON THIS FOR A NEW BLOCK TO BE READ
    GLOBALSEM_STRUCT MYL2_BLOCK_READ_SEM;	// THREAD 1 WAITS ON THIS FOR A BLOCK TO BE READ

    int MYL2_LIBREAD_THREAD_ID;
    int MYL2_LIBREAD_THREAD_HANDLE;
    int MYL2_OPEN_FLAGS;

    int MYL2_DESIRED_BYTES;
    int MYL2_BUFFER_ADDRESS;

    int MYL2_FIRST_REQUEST_LIB_GINDEX;
    int MYL2_LAST_REQUEST_LIB_GINDEX;

    int MYL2_CURRENT_LIB_GINDEX;	// FOR ERROR MESSAGES...

    ubyte[NFN_TEXT_SIZE+4] MYL2_ASCIZ;

    ubyte[NFN_STRUCT.sizeof] MYL2_NAM;
}

}

struct OUTFILE_STRUCT
{

    int _OF_FILE_LIST_GINDEX;	// PTR TO FILE_LIST ENTRY
    int _OF_NEXT_HASH_GINDEX;	// NEXT ITEM HASH ORDER

    int _OF_FINAL_HIGH_WATER;
    int _OF_PHYS_ADDR;		// CURRENT PHYSICAL POINTER

    int _OF_NEXT_OUTFILE_ORDER;	// NEXT OUTFILE IN INDEX ORDER
    int _OF_OUTFILE_NUMBER;	// FOR OVERLAYS, OUTPUT FILE #

    int _OF_SECTIONS;		// # OF SECTIONS USING THIS FILE

    ubyte _OF_FLAGS;		// FILE CREATED,
    ubyte reserved1;
    ushort reserved2;

    int _OF_HANDLE;		// FILE HANDLE IF OPEN

}

struct OF_RECORD
{
	OF_CREATED:1,
	OF_CLOSED:1,
	OF_TRUNCATED:1,
	OF_ROOT:1
}
