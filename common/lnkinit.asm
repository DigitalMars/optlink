		TITLE LNKINIT - Copyright (c) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	INITCODE
		INCLUDE	SECTS
		INCLUDE	IO_STRUC
		INCLUDE	SEGMENTS
		INCLUDE	SECTIONS
		INCLUDE	CLASSES
		INCLUDE	EXES
		INCLUDE	MODULES
		INCLUDE	SYMBOLS
if	fgh_win32
		INCLUDE	WINMACS
endif
if	fg_td
		INCLUDE	TDBG
endif
if	fg_segm OR fg_pe
		INCLUDE	SEGMSYMS
endif
if	fg_pe
		INCLUDE	PE_STRUC
endif
if	J EQ 4
		INCLUDE	RELJOHN
else
		INCLUDE	RELEASE
endif

if	fgh_win32
		INCLUDE	WIN32DEF
endif
		PUBLIC	LNKINIT,DO_SIGNON,VERIFY_DEFINES,MOVE_DEFAULT_FLAGS

if	fg_segm
;		PUBLIC	PIPL_1,SET_STACK_1
endif

		EXTERNDEF	OPREADT:PROC

		EXTERNDEF	CFLAGS:BYTE


XSEG		SEGMENT	AT 0

X		MYI_STRUCT	<>

XSEG		ENDS

		externdef	_init_semaphores:proc
		externdef	_init_eax:proc
		EXTERNDEF	$$SLR_OVCOFF:PROC,ABORT_C:PROC,ABORT_CRITI:PROC

		EXTERNDEF	CRITI_HANDLER:DWORD

		EXTERNDEF	LIBSTUFF:CMDLINE_STRUCT,PATHSTUFF:CMDLINE_STRUCT,OBJSTUFF:CMDLINE_STRUCT,LOCAL_INFO:CMDLINE_STRUCT
		EXTERNDEF	MAPSTUFF:CMDLINE_STRUCT,EXESTUFF:CMDLINE_STRUCT,RCSTUFF:CMDLINE_STRUCT


		.DATA

		EXTERNDEF	INBUF:BYTE,TEMP_RECORD:BYTE,DTA:BYTE,CTRL_C_FLAG:BYTE,MRU_TABLE:BYTE,MRU_THREAD:BYTE,CV_HEADER:BYTE
		EXTERNDEF	SHARE_ANDER:BYTE,FLAGS:BYTE,DOS_VERSION:BYTE,CURN_PLTYPE:BYTE,CV_INFO_TYPE:BYTE,EXETYPE_FLAG:BYTE
		EXTERNDEF	FIRST_SECTION_PLTYPE:BYTE,EXETYPE_CMDLINE_FLAG:BYTE,CODEVIEW_PLTYPE:BYTE,BEGIN_BSS:BYTE,CRLF:BYTE
		EXTERNDEF	UPPER_TABLE:BYTE,FINISH_BSS:BYTE,ME_TEXT:BYTE,SYMBOL_TEXT:BYTE

		EXTERNDEF	CURN_COUNT:DWORD,FILESTUFF_PTR:DWORD,BSS_CLASS_GINDEX:DWORD,BEGDATA_CLASS_GINDEX:DWORD,__psp:DWORD
		EXTERNDEF	SYM_HASH:DWORD,SYM_HASH_LOG:DWORD,RAINBOW_HASH_LOG:DWORD,GRP_COUNT:DWORD,OUTFILE_NUMBER:DWORD
		EXTERNDEF	MOVABLE_MASK:DWORD,MULTI_HASH_LOG:DWORD,SYM_HASH_PHYS:DWORD,SECTION_NUMBER:DWORD,SECTION_SIZE:DWORD
		EXTERNDEF	VECTOR_SIZE:DWORD,AREA_COUNT:DWORD,OVERLAY_INTERRUPT_NUMBER:DWORD,THREAD_LOCALS:DWORD,__envptr:DWORD
		EXTERNDEF	NEXT_READ_THREAD:DWORD,NUMBLKS:DWORD,FALLOC_CNT:DWORD,INPTR1:DWORD,ENVIRONMENT_BLOCK:DWORD
		EXTERNDEF	MAX_LEVEL:DWORD,PLINK_LEVEL:DWORD,PL_DFLT_RADIX:DWORD,PAGEWIDTH:DWORD,PACKCODE:DWORD,PACKDATA:DWORD
		EXTERNDEF	OPTI_STOSD_SIZE:DWORD,FLAG_0C:DWORD,MAP_DEVICE:DWORD,SEG_PAGE_SHIFT:DWORD,SEG_PAGE_SIZE_M1:DWORD
		EXTERNDEF	NOT_SEG_PAGE_SIZE:DWORD,EXEPACK_TAIL_LIMIT:DWORD,CODE_DEFAULTS:DWORD,DATA_DEFAULTS:DWORD
		EXTERNDEF	ALIGNMENT:DWORD,LINNUM_ADDER:DWORD,LAST_SEG:DWORD,_OUTFILE_GINDEX:DWORD,MAPFILE_GINDEX:DWORD
		EXTERNDEF	CURN_OUTFILE_GINDEX:DWORD,DATA_SECTION_GINDEX:DWORD,CODEVIEW_SECTION_GINDEX:DWORD,_STDOUT:DWORD
		EXTERNDEF	FIRST_SECTION_GINDEX:DWORD,CURN_SECTION_GINDEX:DWORD,STACK_CLASS_GINDEX:DWORD,OLD_DTA_SEG:DWORD
		EXTERNDEF	DEBTYP_CLASS_GINDEX:DWORD,DEBSYM_CLASS_GINDEX:DWORD,CODE_CLASS_GINDEX:DWORD,WINMAIN_GINDEX:DWORD
		EXTERNDEF	TD_GTYPE_HASH_LOG:DWORD,TD_GSMEM_HASH_LOG:DWORD,SYM_HASH_BLK:DWORD,DATA_DEFAULTS:DWORD
		EXTERNDEF	TLINK_OUTTYPE:DWORD,DATA_DEFAULTS_MASK:DWORD,DEBNAM_CLASS_GINDEX:DWORD,OLD_GP_FAULT_HI:DWORD
		EXTERNDEF	PMODE:DWORD,HOST_BASE:DWORD,HINSTANCE:DWORD,HPREV:DWORD,CMDSHOW:DWORD,GLOBAL_BLOCKS:DWORD
		EXTERNDEF	IMPLIB_FILE_GINDEX:DWORD,IMPLIB_COFF_FILE_GINDEX:DWORD,IMPDEF_FILE_GINDEX:DWORD
		EXTERNDEF	MDB_STRUCT_SIZE:DWORD,SYMBOL_LENGTH:DWORD
		EXTERNDEF	LOCAL_HASH_TABLE_PTR_OLD:DWORD,FIRST_UNDECORATED_GINDEX:DWORD,tls_CLASS_GINDEX:DWORD

		EXTERNDEF	MYSTACK:DWORD,HEX_TABLE:DWORD,OMF_TABLE:DWORD,CURN_INPTR:DWORD,LAST_FILENAME_OPENED:DWORD
		EXTERNDEF	CLASS_HASH_TABLE_PTR:DWORD,TD_GSMEM_HASH_PTR:DWORD,ME_PTR:DWORD,SEGMENT_HASH_TABLE_PTR:DWORD
		EXTERNDEF	GROUP_HASH_TABLE_PTR:DWORD,MODULE_HASH_TABLE_PTR:DWORD,LOCAL_HASH_TABLE_PTR:DWORD
		EXTERNDEF	TD_GCLASS_HASH_PTR:DWORD,OLD_GP_FAULT:DWORD,VIRDEF_MCD_HASH_TABLE_PTR:DWORD
		EXTERNDEF	FILENAME_HASH_TABLE_PTR:DWORD,THEADR_HASH_TABLE_PTR:DWORD,OLD_DTA:DWORD,HEAP_SIZE:DWORD
		EXTERNDEF	STACK_SIZE:DWORD,IMPMOD_HASH_TABLE_PTR:DWORD,ENTRYPOINT_TXT:DWORD,ENTRYPOINT_GINDEX:DWORD

		EXTERNDEF	LIB_LIST:FILE_LISTS,LIBPATH_LIST:FILE_LISTS,OBJ_LIST:FILE_LISTS,OBJPATH_LIST:FILE_LISTS
		EXTERNDEF	STUB_LIST:FILE_LISTS,STUBPATH_LIST:FILE_LISTS,OLD_LIST:FILE_LISTS,RC_LIST:FILE_LISTS
		EXTERNDEF	LOD_LIST:FILE_LISTS

		EXTERNDEF	_NONRES_LENGTH_SEM:QWORD,LOCKED_STUFF:LKD_ALLOC_STRUCT,MDB_GARRAY:QWORD

		EXTERNDEF	_FILE_LIST_GARRAY:STD_PTR_S,OUTFILE_GARRAY:STD_PTR_S,SECTION_GARRAY:STD_PTR_S,CLASS_GARRAY:STD_PTR_S
		EXTERNDEF	CV_LTYPE_GARRAY:STD_PTR_S,CV_GSYM_GARRAY:STD_PTR_S,CV_GTYPE_GARRAY:STD_PTR_S

		EXTERNDEF	SEGMENT_STUFF:ALLOCS_STRUCT,SSYM_STUFF:ALLOCS_STRUCT,TILLMIDDLE_STUFF:ALLOCS_STRUCT

;		EXTERNDEF	TD_SYMBOL_PARRAY,TD_GSCOPE_PARRAY,TD_OPTSYM_PARRAY,MDB_PARRAY,TD_GLOCAL_STUFF
;		EXTQ	TD_COVERAGE_PARRAY,TD_GTYPE_GARRAY32,TD_GTYPE_STUFF,TD_LTYPE_GARRAY,TD_LCLASS_GARRAY,TD_LSMEM_GARRAY
;		EXTQ	TD_GSMEM_GARRAY32,TD_GSMEM_STUFF,TD_GCLASS_GARRAY,TD_GLOCAL_GARRAY32,PE_OBJECT_PARRAY


		EXTERNDEF	MYI_STUFF:MYI_STRUCT,SYMBOL_TPTR:TPTR_STRUCT,SRCNAM:NFN_STRUCT,FILNAM:NFN_STRUCT

		EXTERNDEF	OPTI_MOVE:DWORD,LOUTALL:DWORD

if	fg_cvpack

		EXTERNDEF	CV_LTYPE_OVERSIZE_CNT:DWORD,CV_GTYPE_OVERSIZE_CNT:DWORD
		EXTERNDEF	CV_LTYPE_SPECIAL_BLOCK:DWORD,CV_GTYPE_SPECIAL_BLOCK:DWORD
endif
		.CODE	STARTUP_TEXT

		externdef	_lnkinit:proc
		EXTERNDEF	_capture_eax:proc
		EXTERNDEF	_release_eax:proc
		EXTERNDEF	_release_eax_bump:proc
		EXTERNDEF	_get_new_phys_blk:proc
		EXTERNDEF	OPENT:PROC,READT:PROC,_store_filnam:PROC,INIT_ARRAYS:PROC,SET_TINY:PROC,SET_BINARY:PROC
		EXTERNDEF	LOC_11_RETT:PROC,HANDLE_LIBS:PROC,HANDLE_OBJPATHS:PROC,HANDLE_RCS:PROC,PROCESS_POSIT_CMDLINE:PROC
		EXTERNDEF	_check_nul:proc,CS_MESOUT:PROC,WARN_RET:PROC,GETNST_SLASH:PROC,VERIFY_SECTION:PROC,HANDLE_EOF:PROC
		EXTERNDEF	SIGNON:PROC,_get_filename:proc,_set_case_mode:proc,DEFINE_CLASS:PROC,DO_NEW_SECTION:PROC
		EXTERNDEF	DO_FILENAME:PROC,INIT_AREA:PROC,MOVE_SRCPRIM_TO_FILNAM_CLEAN:PROC,NAME_INSTALL:PROC
		EXTERNDEF	GET_NEW_LOG_BLK:PROC,DO_DOSSEMCLEAR_AX:PROC,OUTPUT_PROC1:PROC,DO_DOSSEMSET_AX:PROC
		EXTERNDEF	NEW_XREF_BLK_INIT:PROC,FORCE_SIGNON:PROC,LOC_11_R:PROC,PROCESS_FREE_CMDLINE:PROC,XCNOTIFY:PROC
		EXTERNDEF	DO_DOSSEMWAIT_AX:PROC,_do_dossleep_0:PROC,_end_of_indirect:proc,ERR_INBUF_ABORT:PROC,SCAN_SC_INI:PROC
		EXTERNDEF	SET_OUTPUT_ABS:PROC,SELECT_OUTPUT:PROC,DO_DOSSLEEP_TWICE:PROC,DO_DOSCREATETHREAD:PROC
		EXTERNDEF	FIX_TARGETS_A:PROC,MOVE_BXPATH_TO_FILNAM:PROC,_get_4k_segment:proc
		EXTERNDEF	DO_DOSSEMCLEAR_DSAX:PROC,DO_DOSSEMSET_DSAX:PROC,CAPTURE_EAX:PROC,LOUTALL_CON:PROC,TLINK_HELP:PROC
		EXTERNDEF	ALLOCATE_MEMORY:PROC,LOCK_BLOCK:PROC,_lib_routine_final:proc,HANDLE_STUBPATHS:PROC,PROCESS_DEF:PROC
		EXTERNDEF	AX_MESOUT:PROC,YYLEX_FILENAME:PROC,_err_abort:proc,TIME_ERROR:PROC,PERSONALITY:PROC
		EXTERNDEF	GET_TIME_AND_DATE:PROC,INIT_STD_ARRAYS:PROC,INSTALL_CLASS_SYMBOL:PROC,FILENAME_INSTALL:PROC
		EXTERNDEF	LIST_INIT:PROC,ROOT_RET:PROC,FIND_CVPACK:PROC,FAR_INSTALL:PROC,INIT_PARALLEL_ARRAY:PROC
		EXTERNDEF	TD_GTYPE_POOL_GET:PROC,INIT_ARRAY32:PROC,MARRAY_INIT:PROC,TD_GSMEM_POOL_GET:PROC,YY_FILENAME:PROC
		EXTERNDEF	FREEZE_MULTI_ES:PROC,FIND_PROCESS_CFG:PROC,RELEASE_PARALLEL_ARRAY:PROC,SELECT_OUTPUT_SEGMENTED:PROC
		EXTERNDEF	MY_GP_FAULT_16:PROC,RELEASE_LOCKED:PROC,MY_GP_FAULT_32:PROC,ALLOC_LOCKED:PROC
		EXTERNDEF	PARSE_IMPDEF_FILENAME:PROC,PARSE_IMPLIB_FILENAME:PROC,PARSE_IMPLIB_COFF_FILENAME:PROC
		EXTERNDEF	FLUSH_PHYS_IO_TEMP:PROC,RELEASE_EAX:PROC
		EXTERNDEF	TD_GLOCAL_POOL_GET:PROC,SELECT_OUTPUT_PE:PROC,RELEASE_BLOCK:PROC,ADD_TO_EXTERNAL_LIST:PROC
		EXTERNDEF	TRY_UNDECORATED:PROC,MOVE_ASCIZ_ESI_EDI:PROC,MESOUT:PROC,UNDECO_INSTALL:PROC
		EXTERNDEF	ADD_TO_UNDECORATED_LIST:PROC

		EXTERNDEF	FLAG_LEN:ABS,SEGM_COM_SYS_ERR:ABS,OVL_COM_SYS_ERR:ABS,MISSING_ENDAREA_ERR:ABS,DLL_NO_LIB_ERR:ABS
		EXTERNDEF	THREAD_FAIL_ERR:ABS,CMDLINE_ERR:ABS,CREATESEM_ERR:ABS

		public	_initcode1
_initcode1	proc	near
		INITCODE1
		ret
_initcode1	endp

LNKINIT:
		call	_lnkinit

;		INITSYMHASH
;		INITMULTIHASH

		INITCODE2

if	fg_cfg

CFG_H1		PROC

		CALL	FIND_PROCESS_CFG

CFG_H1		ENDP

endif

if	fgh_inthreads
		BITT	_HOST_THREADED
		JZ	CFG_H2

		MOV	EAX,OBJ_LIST.FILE_LAST_GINDEX
		MOV	LAST_FILENAME_OPENED,EAX

		CAPTURE	_NONRES_LENGTH_SEM		;'OLD' NOT STARTED
CFG_H2:
endif
		CALL	_set_case_mode			;SET DEFAULT CASE SIGNIFICANCE MODE

		CALL	PERSONALITY

		SETT	FORCE_PATH

		MOV	EAX,OFF OBJ_ENVIRONMENT
		CALL	ENVIRON_SCAN

		RESS	FORCE_PATH

if	fg_mscmd
		MOV	FILESTUFF_PTR,OFF LOCAL_INFO
endif

		;
		;SET FLAGS BASE ON COMMAND LINE
		;
FIX_INBUF	PROC

		MOV	ECX,CURN_COUNT
		MOV	ESI,CURN_INPTR
		JECXZ	L5$
L1$:
		LODSB
		CMP	AL,' '
		JZ	L19$
		CMP	AL,9
		JZ	L19$
		CMP	AL,0DH
		JZ	L5$
		SETT	CMDLINE_FINAL
		JMP	L5$

L19$:
		LOOP	L1$
L5$:
		MOV	ECX,CURN_COUNT
		CMP	ECX,PAGE_SIZE-4
		JB	L7$
		MOV	CL,CMDLINE_ERR
		push	EAX
		call	_err_abort

L7$:
		push	ECX
		push	EDX
		call	_get_new_phys_blk
		pop	EDX
		pop	ECX

		MOV	EDI,EAX
		MOV	ESI,CURN_INPTR
		MOV	CMDLINE_BLOCK_LOG,EAX
		MOV	CURN_INPTR,EAX
		OPTI_MOVSB
		MOV	WPTR [EDI],0A0DH

		MOV	EAX,OFF INBUF+4
		ADD	CURN_COUNT,3
		MOV	INPTR1,EAX
		MOV	WPTR [EAX],0A0DH

FIX_INBUF	ENDP

if	0

DEBUG_STUFF	PROC

;		jmp	l2$
;		db	0,0,0

		MOV	EAX,CURN_INPTR
		MOV	ECX,CURN_COUNT

		DEC	ECX
		CALL	LOUTALL_CON
;		jmp	L1$
;		db	0,0,0
		;
		;DUMP ENVIRONMENT
		;
		MOV	EDI,ENVIRONMENT_BLOCK
L1$:
		XOR	EAX,EAX
		MOV	ECX,64K

		MOV	EDX,EDI

		REPNE	SCASB

		MOV	EAX,EDX
		LEA	ECX,[EDI-1]

		SUB	ECX,EDX
;		CALL	LOUTALL_CON
		jmp	l3$
		db	0,0,0

		MOV	EAX,OFF CRLF
		CALL	MESOUT
l3$:
		CMP	BPTR [EDI],0
		JNZ	L1$
l2$:
DEBUG_STUFF	ENDP

endif

		CALL	GET_TIME_AND_DATE

FIX_MSCMDLIN	PROC
		;
		;ACCOUNT FOR CL'S  @"\"TOM\"
		;
		MOV	EDI,CURN_INPTR
		MOV	ECX,CURN_COUNT
		MOV	ESI,EDI
		DEC	ECX
		JZ	L9$
		;
		;SCAN FOR OPENING "
		;
L1$:
		MOV	AL,[ESI]
		INC	ESI
		MOV	[EDI],AL
		INC	EDI
		CMP	AL,'"'
		JZ	L5$
L2$:
		DEC	ECX
		JNZ	L1$
		JMP	L9$		;SKIP IT...

		;
		;LEADING " FOUND, DELETE ANY \" UNTIL PLAIN "
		;
L3$:
		MOV	AL,[ESI]
		INC	ESI
L4$:
		MOV	[EDI],AL
		INC	EDI
		CMP	AL,"\"
		JZ	L6$		;YES, GO LOOK FOR "
		CMP	AL,'"'
		JZ	L2$		;PLAIN ", LOOK FOR " AGAIN
L5$:
		DEC	ECX
		JNZ	L3$
		JMP	L9$

L6$:
		DEC	ECX
		JZ	L9$
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'"'
		JNZ	L4$
		DEC	EDI		;DON'T COUNT \"
		JMP	L5$

L9$:
		SUB	EDI,CURN_INPTR
		INC	EDI
		MOV	CURN_COUNT,EDI

FIX_MSCMDLIN	ENDP


if	any_overlays
		SETT	OVERLAY_CLASS_DEFINED
endif
		CALL	INIT_AREA		;INITIALIZE AREA

if	fg_td
		BITT	TLINK_SYNTAX
		PUSHF
		RESS	TLINK_SYNTAX
endif

		BITT	SCAN_LINK_ENVIRONMENT
		JZ	NO_LINK
		MOV	EAX,OFF LINK_ENVIRONMENT
		CALL	ENVIRON_SCAN
NO_LINK:

if	fg_mscmd
		MOV	EAX,OFF OPTLNK_ENVIRONMENT	;HANDLE OPTLINK= SLASH COMMANDS
		CALL	ENVIRON_SCAN
endif

if	fg_td
		RESS	TLINK_SYNTAX
		POPF
		JZ	NOT_TL_SYNTAX
		SETT	TLINK_SYNTAX
NOT_TL_SYNTAX:
endif


;		MOV	FIRST_SECTION_GINDEX,1
		MOV	FIRST_SECTION_PLTYPE,MASK LEVEL_0_SECTION

if	fg_plink AND fg_mscmd
		BITT	CMDLINE_FREEFORMAT
		JZ	MSCMD
endif
if	fg_plink
		CALL	PROCESS_FREE_CMDLINE
		JMP	CMDLINE_DONE
endif
if	fg_mscmd
MSCMD:
		CALL	PROCESS_POSIT_CMDLINE
endif

;if	fg_winpack
;		RESS	WINPACK_SELECTED
;		RESS	SEGPACK_SELECTED
;endif
;		RESS	EXEPACK_SELECTED

CMDLINE_DONE	PROC

if	fg_td
		CALL	HANDLE_TLINK_DEFAULT
endif

		CALL	HANDLE_EOF
		;
		;SEE IF WE NEED A MAP FILENAME
		;
		CALL	PROCESS_MAPSTUFF	;OPEN IT IF WE NEED IT...
if	fg_def
;		ALLMSG	'Process DEF'

		CALL	PROCESS_DEF

;		ALLMSG	'After def'

		CALL	AFTER_DEF
endif


		CALL	FIX_ENTRYPOINT

		CALL	SCAN_HASHES_FOR_UNDECORATEDS

		MOV	EAX,CMDLINE_BLOCK_LOG
		CALL	RELEASE_BLOCK

if	V5
		CALL	FIX_IMP_DEF
endif

if	fg_segm OR fg_pe
		;
		;SEE IF RC_SUPPLIED BUT NO FILENAME...
		;
RCFIX		PROC

		BITT	RC_SUPPLIED
		JZ	L9$
		MOV	EAX,RC_LIST.FILE_FIRST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		MOV	EAX,[EAX].FILE_LIST_STRUCT.FILE_LIST_NEXT_GINDEX
		MOV	ECX,OFF INBUF
		OR	EAX,EAX
		JNZ	L9$		;JUMP IF NAME SUPPLIED
		MOV	WPTR [ECX],0A0DH
		MOV	INPTR1,ECX
		MOV	EAX,OFF RCSTUFF
		CALL	YYLEX_FILENAME
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_RCS
		SETT	RC_GUESSED
L9$:

RCFIX		ENDP

endif
		;
		;MAKE SURE ALL NECESSARY ENDAREAS HAVE BEEN DONE...
		;
if	fg_plink
		CMP	PLINK_LEVEL,0
		JZ	2$
		MOV	AL,MISSING_ENDAREA_ERR
		CALL	ERR_INBUF_ABORT

2$:
endif
		CALL	VERIFY_SECTION
		;
		;IF ONLY ONE SECTION EXISTS, WE AREN'T DOING OVERLAYS...
		;
if	any_overlays
		CMP	SECTION_NUMBER,1
		JZ	91$
		CALL	INIT_OVERLAYS
91$:
		LEA	SI,CURN_SECTION_GINDEX
		LEA	DI,DATA_SECTION_GINDEX
		MOVSW
		MOVSB			;PLTYPE (LEVEL_0_SECTION)
endif
		CALL	DO_NEW_SECTION
		MOV	EAX,CURN_SECTION_GINDEX
		MOV	CL,CURN_PLTYPE
		MOV	CODEVIEW_SECTION_GINDEX,EAX
		MOV	CODEVIEW_PLTYPE,CL

		CONVERT	EAX,EAX,SECTION_GARRAY
		OR	[EAX].SECTION_STRUCT._SECT_FLAGS,MASK SECT_CODEVIEW
		;
		;NOW SET CURN_SECTION BACK TO FIRST_SECTION FOR SEARCH LIBS
		;
		MOV	EAX,FIRST_SECTION_GINDEX
		MOV	CURN_PLTYPE,MASK LEVEL_0_SECTION
		MOV	CURN_SECTION_GINDEX,EAX
if	any_overlays
		;
		;CALCULATE SECTION_SIZE
		;
		MOV	AX,4			;PARA OFFSET AND FLAGS
		CMP	AREA_COUNT,3
		JBE	92$
		SETT	MULTI_LEVEL_MULTI_AREA
		SETT	SEXE_LOAD_PARA_FLAG
		MOV	MULTI_AREA_BYTE,'Y'
		ADD	AL,2			;LOAD ADDRESS
		CMP	MAX_LEVEL,2
		JB	92$
		SETT	SEXE_END_PARENT_FLAG
		MOV	MULTI_LEVEL_BYTE,'Y'
		ADD	AL,4			;LOAD ADDRESS, END ADDRESS, PARENT
		JMP	929$

92$:
		CMP	CACHE_BYTE,'Y'
		JNZ	929$
		SETT	SEXE_LENGTH_FLAG
		ADD	AL,2			;_SEXE_LENGTH
929$:
		CMP	OUTFILE_NUMBER,4
		JBE	93$
		MOV	MULTI_FILES_BYTE,'Y'
		SETT	SEXE_FILES_FLAG
		ADD	AL,2
93$:
		MOV	SECTION_SIZE,AX
		;
		;CALCULATE VECTOR SIZE
		;
;		MOV	AX,12			;SIZE IF FAR CALL(5), FAR JMP(5), AND SECTION #
;		BITT	USE_OVERLAY_INT
;		JZ	94$
		MOV	AL,8			;INT 3F, OFFSET, SEGMENT, SECTION
;94$:
		CMP	MODEL_FAR_BYTE,'Y'
		JZ	94$
		MOV	AL,6
94$:
		MOV	VECTOR_SIZE,AX
endif
if	any_overlays
		BITT	DOING_OVERLAYS
		JZ	991$
		LDS	SI,OUTFILE
		ASSUME	DS:NOTHING
		SYM_CONV_DS
		INC	[SI]._OF_SECTIONS		;COUNT VECTOR_SECTIONS TABLE
		OR	[SI]._OF_FLAGS,MASK OF_ROOT

991$:
		FIXES
		FIXDS
		RESS	OVERLAY_CLASS_DEFINED
;		MOV	SECTION_SIZE,SIZE SECT_EXE_STRUCT
endif
		XOR	EAX,EAX
		DEC	SECTION_NUMBER		;DON'T COUNT CODEVIEW SECTION
		MOV	CURN_OUTFILE_GINDEX,EAX

CMDLINE_DONE	ENDP

if	fg_segm

SEGM_INIT	PROC
		;
		;DETERMINE WHAT WILL CAUSE MOVABLE ENTRY POINTS.
		;
		BITT	OUTPUT_SEGMENTED
		JZ	L19$			;NO MOVABLES IF NOT SEGMENTED YET...
		BITT	ALLOW_WINDOWS_EXEPACK
		JNZ	L1$
		CMP	EXETYPE_FLAG,WIN_SEGM_TYPE
		JNZ	L1$
		RESS	EXEPACK_SELECTED	;DISABLE EXEPACK FOR WINDOWS...
L1$:
		BITT	IOPL_USED
		JNZ	L15$			;YES, MOVABLES POSSIBLE IF IOPL
		BITT	PROTMODE		;NO MOVABLES IF PROTMODE AND NO IOPL
		JNZ	L19$
		CMP	EXETYPE_FLAG,OS2_SEGM_TYPE	;NO MOVABLES IF OS/2 AND NO IOPL
		JZ	L19$
		BITT	MOVABLE_USED
		JZ	L19$
L15$:
		SETT	ENTRIES_POSSIBLE
		MOV	MOVABLE_MASK,1 SHL SR_DPL	;ONLY IOPL AND NONCONFORMING IF OS2 OR PROTMODE
		BITT	PROTMODE
		JNZ	L19$
		CMP	EXETYPE_FLAG,OS2_SEGM_TYPE
		JZ	L19$
		MOV	MOVABLE_MASK,MASK SR_MOVABLE+MASK SR_DISCARD+(1 SHL SR_DPL)
L19$:

SEGM_INIT	ENDP
endif

if	fg_pe

PE_INIT		PROC

		BITT	OUTPUT_PE
		JZ	L9$

L9$:

PE_INIT		ENDP

endif

if	fg_dosx

DOSX_INIT	PROC

		CMP	EXETYPE_FLAG,DOSX_EXE_TYPE
		JNZ	L9$

		SETT	OUTPUT_32BITS
L9$:

DOSX_INIT	ENDP

endif

		;
		;END OF PROMPTING, CHECK A COUPLE THINGS...
		;
		BITT	INDIRECT_MODE
		JZ	NO_INDIRECT
		CALL	_end_of_indirect		;MAKE SURE FILE CLOSE AND BUFFER RELEASED
NO_INDIRECT:

if	fg_td AND fg_cv
		BITT	CODEVIEW_FLAG		;MAKE SURE ONLY ONE DEBUG TYPE SELECTED
		JZ	NCVTD
		RESS	TD_FLAG
NCVTD:
endif

		MOV	EAX,_OUTFILE_GINDEX
		CONVERT	EAX,EAX,OUTFILE_GARRAY
		MOV	EAX,[EAX].OUTFILE_STRUCT._OF_FILE_LIST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		LEA	EAX,[EAX].FILE_LIST_STRUCT.FILE_LIST_NFN
		push	EAX
		call	_check_nul		;SET FLAG IF NUL OUTPUT FILE
		add	ESP,4
		SETT	FORCE_PATH

		BITT	SCAN_LIB_ENVIRONMENT
		JZ	NO_SCANLIB

;if	fgh_dosx OR (fgh_win32 AND NOT fgh_win32dll)

if	fgh_win32dll
		BITT	_HOST_THREADED
		JNZ	SKIP_THREADED_NT
endif

		CALL	SCAN_SC_INI

SKIP_THREADED_NT:

;endif
		SETT	FORCE_PATH
		MOV	EAX,OFF LIB_ENVIRONMENT
		CALL	ENVIRON_SCAN		;ADD LIB SEARCH DIRECTORIES
NO_SCANLIB:
		;
if	fg_segm
		BITT	OLD_SUPPLIED
		JNZ	YO_1
		BITT	STUB_SUPPLIED		;IF STUB OR OLD WAS SPECIFIED, GET
		JNZ	YO_1			;PATH DIRECTORIES...
endif
		BITT	CODEVIEW_FLAG		;WE NEED PATH TO FIND CVPACK
		JZ	NO_STUB
YO_1:
		SETT	FORCE_PATH

		CALL	DO_HOME_PATH

		MOV	EAX,OFF PATH_ENVIRONMENT
		CALL	ENVIRON_SCAN
NO_STUB:
		RESS	FORCE_PATH

		CALL	INIT_ARRAYS		;INIT LNAMES, SEGDEF, GRPDEF, EXTDEF ARRAYS
		;
		;SET UP POINTERS FOR:     DGROUP
		;
ife	fg_def
		CALL	VERIFY_DEFINES		;MAKE SURE SOME TEXTS ARE DEFINED
endif

ife	fg_cv
		RESS	CODEVIEW_FLAG
endif
ife	fg_td
		RESS	TD_FLAG
endif
		;
		;IF LINNUMBERS_FLAG OR CODEVIEW_FLAG
		;
		XOR	EAX,EAX			;FOR DETERMINING IF LINNUM RECORDS ARE KEPT, AND
		BITT	LINENUMBERS_FLAG
		JZ	LN_2
		INC	EAX
		SETT	KEEPING_LINNUMS		;ONE SET FOR /LI
LN_2:
		BITT	CODEVIEW_FLAG
		JNZ	LN_25
		BITT	TD_FLAG
		JZ	LN_3
LN_25:
		INC	EAX
		SETT	KEEPING_LINNUMS		;ONE SET FOR CODEVIEW OR TD
LN_3:
if	fg_rom
		BITT	OMF_LINES
		JZ	LN_4
		INC	EAX
		SETT	KEEPING_LINNUMS		;ONE SET FOR OMF
LN_4:
endif
		DEC	EAX
		BITT	KEEPING_LINNUMS
		MOV	LINNUM_ADDER,EAX
		JZ	LN_9
		MOV	EAX,MDB_SIZE_CV
		MOV	MDB_STRUCT_SIZE,EAX

LN_9:
		;
		;OUTPUT ABSOLUTE?
		;
		CALL	CHECK_OUTPUT_TYPE	;DETERMINE IF .COM, .SYS, .EXE, ETC

if	fg_rom
		BITT	OUTPUT_ABS
		JZ	FR_1
		CALL	FIX_TARGETS_A		;LINK TO CLASS & MAKE PRIVATE
FR_1:
endif

if	fgh_inthreads
		SETT	OBJS_DONE		;SIGNAL OK TO PROCESS LIBRARY
endif

if	fg_rat
		MOV	SEG_PAGE_SHIFT,4	;PARAGRAPH ALIGNMENT
		MOV	NOT_SEG_PAGE_SIZE,NOT 16
		MOV	SEG_PAGE_SIZE_M1,15
endif

if	fg_dospack

SLRPACKING	PROC
		BITT	SLRPACK_SELECTED
		JZ	L9$
		SETT	EXEPACK_SELECTED
;		SETT	PACKCODE_FLAG		;found asm code that croaks
;		SETT	FARCALLTRANSLATION_FLAG
L9$:
SLRPACKING	ENDP

endif

INIT_FINAL	PROC
		;
		;
		;
;if	fg_pe
;		MOV	ECX,OFF PE_OBJECT_PARRAY
;		MOV	EAX,SIZE PE_OBJECT_STRUCT
;		CALL	INIT_PARALLEL_ARRAY
;endif

if	fgh_inthreads
		CALL	OS2_FIXER		;START READ THREADS FOR OBJS AND LIBS
endif
		CALL	SIGNON			;IN CASE NOT SIGNED ON YET...
		SETT	DEBUGGING_THIS
		BITT	FANCY_DEBUG
		JZ	C1
		RESS	DEBUGGING_THIS
C1:
if	fg_cv
		CALL	CODEVIEW_FINISH		;FIXUP BASED ON CODEVIEW TYPE SELECTED
endif
if	fg_td
		CALL	TD_FINISH
endif
if	fg_winpack
;		CALL	WINPACK_FINISH
endif
		RET

INIT_FINAL	ENDP


PROCESS_MAPSTUFF	PROC	NEAR
		;
		;
		;
if	fg_plink
		BITT	MAPFILE_SELECTED
		JZ	8$
		CMP	MAPFILE.SEGM,0
		JNZ	8$

		CALL	MOVE_SRCPRIM_TO_FILNAM_CLEAN
		MOV	FILESTUFF_PTR,OFF MAPSTUFF
		CALL	DO_FILENAME
		push	EAX
		CALL	_store_filnam
		add	ESP,4
		MOV	MAPFILE.OFFS,BX
		MOV	MAPFILE.SEGM,AX
		FIXES
8$:
		;
		;IF NO OUTFILE, MAKE IT MATCH SRCNAM
		;
		CMP	OUTFILE.SEGM,0
		JNZ	99$

		CALL	MOVE_SRCPRIM_TO_FILNAM_CLEAN
		MOV	FILESTUFF_PTR,OFF EXESTUFF
		CALL	DO_FILENAME
		CALL	OUTPUT_PROC1
99$:
endif
		MOV	EAX,MAPFILE_GINDEX
		OR	EAX,EAX
		JZ	MAP_NUL
if	fg_td
		BITT	TLINK_X_MAPFILE
		JNZ	MAP_NUL
endif
		CONVERT	EAX,EAX,OUTFILE_GARRAY
		MOV	EAX,[EAX].OUTFILE_STRUCT._OF_FILE_LIST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		LEA	EAX,[EAX].FILE_LIST_STRUCT.FILE_LIST_NFN
		MOV	ESI,EAX
		push	EAX
		CALL	_check_nul
		add	ESP,4
		TEST	[ESI].NFN_STRUCT.NFN_FLAGS,MASK NFN_NUL	;NUL ?
		JZ	MAP_NOT_NUL
MAP_NUL:
		XOR	EAX,EAX
		MOV	MAPFILE_GINDEX,EAX
		RESS	SYMBOLS_OUT,AL		;CLEAR MAP OUTPUT FLAGS IF MAP FILE NUL
		RESS	LINENUMBERS_FLAG,AL
		RESS	XREF_OUT,AL
		RESS	SEGMENTS_MAP,AL
MAP_NOT_NUL:
		BITT	XREF_OUT		;INIT XREF BLOCK IF SELECTED
		JZ	NO_XREF
		CALL	NEW_XREF_BLK_INIT
NO_XREF:
		;
		;
		;
		MOV	EAX,MAPFILE_GINDEX	;ARE WE DOING A MAP FILE?
		CALL	LIST_INIT		;SET UP FOR OUTPUT.
		MOV	MAP_DEVICE,EAX		;SAVE MAP DEVICE
		RET

PROCESS_MAPSTUFF	ENDP


DO_HOME_PATH	PROC
		;
		;
		;
		PUSHM	EDI,ESI,EBX

		MOV	ESI,ME_PTR
		MOV	EDI,OFF TEMP_RECORD		;TEMP BUFFER...

		TEST	ESI,ESI
		JZ	L9$

		MOV	BPTR [EDI],'"'
		INC	EDI
L1$:
		MOV	AL,[ESI]
		INC	ESI

		MOV	[EDI],AL
		INC	EDI

		OR	AL,AL
		JNZ	L1$
		;
		;NOW BACK UP TO FIRST \ OR :
		;
		MOV	ESI,OFF TEMP_RECORD+1
		MOV	ECX,EDI

		SUB	ECX,ESI			;# OF CHARS TO CHECK
		JZ	L9$
L11$:
		MOV	AL,[EDI-1]
		DEC	EDI

		DEC	ECX
		JZ	L9$

		CMP	AL,'\'
		JZ	L13$

		CMP	AL,':'
		JNZ	L11$
L13$:
		MOV	BPTR [EDI+1],'"'
		INC	EDI

		MOV	AL,0DH
		INC	EDI

		STOSB

		MOV	EDX,OFF TEMP_RECORD
		MOV	ECX,OFF FILNAM

		MOV	EAX,OFF PATHSTUFF

		push	EDX
		push	ECX
		push	EAX
		call	_get_filename
		add	ESP,12

		MOV	EAX,OFF FILNAM
		CALL	HANDLE_STUBPATHS
L9$:
		POPM	EBX,ESI,EDI

		RET

DO_HOME_PATH	ENDP


if	fg_segm
if	V5

FIX_IMP_DEF	PROC	NEAR
		;
		;
		;
		BITT	IMPDEF_FLAG		;WAS A .DIN OUTPUT REQUESTED?
		JZ	L5$
		CMP	IMPDEF_FILE_GINDEX,0	;WAS A FILENAME SUPPLIED?
		JNZ	L5$
		CALL	PARSE_IMPDEF_FILENAME
L5$:
		BITT	IMPLIB_FLAG		;WAS A .LIB OUTPUT REQUESTED?
		JZ	L8$
		CMP	IMPLIB_FILE_GINDEX,0	;WAS A FILENAME SUPPLIED?
		JNZ	L8$
		CALL	PARSE_IMPLIB_FILENAME
L8$:
		BITT	IMPLIB_COFF_FLAG	;WAS A COFF.LIB OUTPUT REQUESTED?
		JZ	L9$
		CMP	IMPLIB_COFF_FILE_GINDEX,0 ;WAS A FILENAME SUPPLIED?
		JNZ	L9$
		CALL	PARSE_IMPLIB_COFF_FILENAME
L9$:
		RET

FIX_IMP_DEF	ENDP


endif
endif

if	fg_def

AFTER_DEF	PROC	NEAR
		;
		;HERE WE DO .DEF POST PROCESSING, INCLUDING HANDLING /Twe ETC
		;
		SETT	AFTER_DEF_DONE

		BITT	DEFFILE_SELECTED
		JNZ	L5$
		MOV	AL,EXETYPE_CMDLINE_FLAG
		OR	AL,AL
		JNZ	L3$
		BITT	TLINK_OUTTYPE_FOUND
		JZ	L2$
L1$:
		CALL	TLINK_SLASH_T
		JMP	L8$

L2$:
if	fg_td
		BITT	TLINK_DEFAULT_MODE
		JZ	L25$
		SETT	FORCE_DOS_MODE
L25$:
endif
		RET

L3$:
		;
		;IF POSSIBLE, CONVERT EXETYPE TO TLINK_OUTTYPE
		;
		MOV	AH,4		;Tw
		CMP	AL,WIN_SEGM_TYPE
		JZ	L35$
if	fg_pe
		CMP	AL,PE_EXE_TYPE
		MOV	AH,8		;Tp
		JZ	L35$
endif
if	fg_dosx
		CMP	AL,DOSX_EXE_TYPE
		MOV	AH,12
		JZ	L35$
endif
		MOV	EXETYPE_FLAG,AL
		JMP	L8$

L35$:
		MOV	BPTR TLINK_OUTTYPE,AH
		JMP	L1$

L5$:
		;
		;THERE WAS A DEF FILE
		;
		MOV	AL,EXETYPE_CMDLINE_FLAG
		OR	AL,AL
		JNZ	L6$
		BITT	TLINK_OUTTYPE_FOUND
		JZ	L55$
L51$:
		CALL	TLINK_SLASH_OVERRIDES
L55$:
		JMP	L8$

L6$:
		;
		;IF POSSIBLE, CONVERT EXETYPE TO TLINK_OUTTYPE
		;
		MOV	AH,4		;Tw
		CMP	AL,WIN_SEGM_TYPE
		JZ	L65$
if	fg_pe
		CMP	AL,PE_EXE_TYPE
		MOV	AH,8		;Tp
		JZ	L65$
endif
if	fg_dosx
		CMP	AL,DOSX_EXE_TYPE
		MOV	AH,12
		JZ	L65$
endif
		MOV	EXETYPE_FLAG,AL
		JMP	L8$

L65$:
		MOV	BPTR TLINK_OUTTYPE,AH
		JMP	L51$

L8$:
		BITT	FORCE_DOS_MODE
		JNZ	L9$
		MOV	AL,EXETYPE_FLAG
		CMP	AL,DOS_EXE_TYPE		;DOS TYPE SELECTED
		JZ	L9$
		CMP	AL,DOSX_EXE_TYPE
		JZ	L9$
if	fg_pe
		CMP	AL,PE_EXE_TYPE
		JZ	L85$
endif
		CALL	SELECT_OUTPUT_SEGMENTED
		JMP	L9$

if	fg_pe
L85$:
		CALL	SELECT_OUTPUT_PE
endif

L9$:
		RET

AFTER_DEF	ENDP


SCAN_HASHES_FOR_UNDECORATEDS	PROC
		;
		;SCAN HASH TABLE FOR SYMBOLS ALREADY INSTALLED
		;
		MOV	EAX,FIRST_UNDECORATED_GINDEX

		TEST	EAX,EAX
		JZ	L9$

		PUSHM	EDI,ESI,EBX
		MOV	EDI,SYM_HASH_PHYS	;BEGINNING OF HASH TABLE

		MOV	ECX,SYM_HASH		;SIZE OF HASH TABLE
L1$:
		XOR	EAX,EAX

		REPE	SCASD			;LOOK FOR A NON-ZERO HASH ENTRY

		PUSH	ECX
		JZ	L8$

		MOV	ECX,[EDI-4]		;WENT ONE BEYOND
		PUSH	EDI
L2$:
		MOV	EAX,ECX
		CONVERT	ECX,ECX,SYMBOL_GARRAY
		ASSUME	ECX:PTR SYMBOL_STRUCT
		MOV	EDI,OFF SYMBOL_TEXT

		PUSHM	ECX,EAX

		LEA	ESI,[ECX]._S_NAME_TEXT
		CALL	MOVE_ASCIZ_ESI_EDI

		SUB	EDI,OFF SYMBOL_TEXT
		POP	EAX

		MOV	SYMBOL_LENGTH,EDI
		POP	ECX

		CALL	TRY_UNDECORATED		;RETURNS SAME

		MOV	ECX,[ECX]._S_NEXT_HASH_GINDEX

		TEST	ECX,ECX
		JNZ	L2$

		POPM	EDI,ECX

		JMP	L1$

L8$:
		POPM	ECX,EBX,ESI,EDI
L9$:
		RET

		ASSUME	ECX:NOTHING

SCAN_HASHES_FOR_UNDECORATEDS	ENDP


TLINK_SLASH_T	PROC	NEAR
		;
		;if Tw, SET UP WINDOWS DEFAULTS
		;
		MOV	EAX,TLINK_OUTTYPE
		MOV	BL,-1
		CMP	AL,4		;0,1,2 DOS
		JB	L3$
if	fg_pe OR fg_dosx
		CMP	AL,8
		JAE	L5$
		RESS	OUTPUT_PE,AH
endif
		;
		;WINDOWS OUTPUT SELECTED, ANY PARTICULAR TYPE?
		;	Tw == 4, Twe == 5, Twd == 6
		;
		RESS	FORCE_DOS_MODE,AH
		MOV	CODE_DEFAULTS,MASK SR_MOVABLE OR MASK SR_DISCARD	;TLINK ALSO DOES PRELOAD...
		SETT	MOVABLE_USED,BL
		OR	FLAG_0C,300H		;WINDOWAPI
		BITT	HEAP_SIZE_FLAG,AH
		JNZ	L0$
		MOV	HEAP_SIZE,4096		;SET HEAP IF NOT ALREADY DEFINED
		SETT	HEAP_SIZE_FLAG,BL
L0$:
		CMP	AL,6
		JZ	L2$
		;
		;.EXE OUTPUT
		;
		BITT	STACK_SIZE_FLAG,AH
		JNZ	L1$
		MOV	STACK_SIZE,5120		;SET STACK IF NOT ALREADY DEFINED
		SETT	STACK_SIZE_FLAG,BL
L1$:
		MOV	DATA_DEFAULTS,MASK SR_PRELOAD OR MASK SR_MOVABLE OR (2 SHL SR_MULTIPLE) OR 1
		CMP	AL,4
		JNZ	L19$
		RESS	TLINK_OUTTYPE_FOUND,AH	;GENERIC, LET EXTENSION OVERIDE .DLL VS .EXE
L19$:
		RET

L2$:
		;
		;.DLL OUTPUT
		;
		MOV	DATA_DEFAULTS,MASK SR_PRELOAD OR MASK SR_MOVABLE OR MASK SR_SHARED OR (1 SHL SR_MULTIPLE) OR 1
		OR	FLAG_0C,MASK APPTYPE		;LIBRARY
		RET

L3$:
		;
		;DOS OUTPUT SELECTED, ANY PARTICULAR TYPE?
		;	Td == 0, Tdc == 1, Tde == 2
		;
		MOV	EXETYPE_FLAG,DOS_EXE_TYPE
L30$:
if	fg_pe
		RESS	OUTPUT_PE,AH
endif
if	fg_segm
		RESS	OUTPUT_SEGMENTED,AH
endif
		SETT	FORCE_DOS_MODE,BL
if	fg_winpack
		RESS	WINPACK_SELECTED,AH
		RESS	SEGPACK_SELECTED,AH
endif
		OR	AL,AL
		JZ	L31$			;NO FORCING OF COM VS EXE, ALLOW .EXTENT TO SET .SYS OR .COM, ETC
		CMP	AL,1
		JZ	L32$
		;
		;DOS .EXE
		;
		RESS	OUTPUT_COM_SYS,AH
		RESS	OUTPUT_SYS,AH
		RESS	OUTPUT_COM,AH		;MUST BE DOS EXE OUTPUT
L31$:
		RET

L32$:
		;
		;DOS .COM
		;
		CALL	SET_TINY
		RESS	EXEPACK_SELECTED,AH
if	fg_dospack
		RESS	SLRPACK_SELECTED,AH
endif
		SETT	CV_SEPARATE,BL
		RET

if	fg_pe OR fg_dosx

L5$:
		CMP	AL,12
		JAE	L6$
endif
if	fg_pe
		;
		;PE OUTPUT SELECTED, ANY PARTICULAR TYPE?
		;	Tp == 8, Tpe == 9, Tpd == 10
		;
		RESS	OUTPUT_SEGMENTED,AH
		RESS	FORCE_DOS_MODE,AH
		MOV	CODE_DEFAULTS,MASK SR_DISCARD
		MOV	DATA_DEFAULTS,1
		MOV	EXETYPE_FLAG,PE_EXE_TYPE
		CMP	AL,9
		JZ	L58$
		CMP	AL,10
		JNZ	L57$
		OR	FLAG_0C,MASK APPTYPE
L58$:
		RET

L57$:
		RESS	TLINK_OUTTYPE_FOUND,AH
		RET

endif

if	fg_dosx
L6$:
		MOV	EXETYPE_FLAG,DOSX_EXE_TYPE
		JMP	L30$
endif

TLINK_SLASH_T	ENDP


TLINK_SLASH_OVERRIDES	PROC	NEAR
		;
		;OVERRIDE .DEF FINDINGS...
		;
		MOV	EAX,TLINK_OUTTYPE
		MOV	BL,-1
		CMP	AL,4
		JB	L5$
		RESS	FORCE_DOS_MODE,AH
if	fg_pe OR fg_dosx
		CMP	AL,8
		JAE	L6$
		RESS	OUTPUT_PE,AH
endif
		;
		;WINDOWS 16-BIT
		;
		CMP	EXETYPE_FLAG,WIN_SEGM_TYPE
		JZ	L1$
		MOV	EXETYPE_FLAG,AH		;ALLOW WINDOWS DEFAULTS TO HAPPEN
L1$:
		CMP	AL,4
		JZ	L18$			;OK, DO WINDOWS....
		CMP	AL,5
		JZ	L2$
		;
		;MUST BE FORCING .DLL
		;
		OR	FLAG_0C,MASK APPTYPE
		TEST	DATA_DEFAULTS_MASK,MASK SR_MULTIPLE+MASK SR_SHARED
		JNZ	L19$
		OR	DATA_DEFAULTS,MASK SR_SHARED
L19$:
		RET

L18$:
		RESS	TLINK_OUTTYPE_FOUND,AH
		RET

L2$:
		;
		;FORCING .EXE OUTPUT
		;
		AND	FLAG_0C,NOT MASK APPTYPE	;CLEAR LIBRARY BITS
		TEST	DATA_DEFAULTS_MASK,MASK SR_MULTIPLE+MASK SR_SHARED
		JNZ	L29$
		AND	DATA_DEFAULTS,NOT MASK SR_SHARED
L29$:
		RET

L5$:
		;
		;UH OH, FORCING DOS OUTPUT
		;
		CALL	TLINK_SLASH_T
		RET

if	fg_pe OR fg_dosx

L6$:
		CMP	AL,12
		JAE	L7$
endif

if	fg_pe
		;
		;FORCING PE OUTPUT, DESPITE .DEF FILE CONTENTS
		;
		RESS	OUTPUT_SEGMENTED,AH
		MOV	EXETYPE_FLAG,PE_EXE_TYPE
		CMP	AL,9
		JZ	L68$
		CMP	AL,10
		JNZ	L69$
		OR	FLAG_0C,MASK APPTYPE
		RET

L68$:
		AND	FLAG_0C,NOT MASK APPTYPE	;CLEAR LIBRARY BITS
		RET

L69$:
		RESS	TLINK_OUTTYPE_FOUND,AH
		RET

endif

if	fg_dosx

L7$:
		CALL	TLINK_SLASH_T
		RET

endif

TLINK_SLASH_OVERRIDES	ENDP

endif

if	fg_td

HANDLE_TLINK_DEFAULT	PROC	NEAR
		;
		;
		;
		BITT	TLINK_DEFAULT_MODE
		JZ	L9$
		CMP	SRCNAM.NFN_PRIMLEN,0
		JNZ	L9$
		CALL	TLINK_HELP
L9$:
		RET

HANDLE_TLINK_DEFAULT	ENDP

endif


FIX_ENTRYPOINT	PROC	NEAR
		;
		;
		;
		MOV	ESI,ENTRYPOINT_TXT
		MOV	EDI,OFF SYMBOL_LENGTH

		TEST	ESI,ESI
		JZ	L9$

		LODSD
		STOSD

		OR	EAX,EAX
		JZ	L9$

		CALL	OPTI_MOVE
		;
		;SEE IF DECORATED
		;
		MOV	EDI,OFF SYMBOL_TEXT
		MOV	ECX,SYMBOL_LENGTH

		MOV	AL,'@'

		REPNE	SCASB

		JZ	L4$		;'@' MEANS DECORATED

		CALL	UNDECO_INSTALL	;SEPARATE HASH & ADDR SPACE
		ASSUME	ECX:PTR SYMBOL_STRUCT

		MOV	DL,[ECX]._S_NSYM_TYPE
		MOV	ENTRYPOINT_GINDEX,EAX

		OR	DL,DL
		JNZ	L3$

		CALL	ADD_TO_UNDECORATED_LIST
L3$:
		OR	[ECX]._S_REF_FLAGS,MASK S_REFERENCED

		RET

L4$:
		CALL	FAR_INSTALL
		ASSUME	ECX:PTR SYMBOL_STRUCT
		;
		;ADD UNDEFINED SYMBOL-TYPE TO EXTERNAL-REFERENCED LIST
		;
		MOV	ENTRYPOINT_GINDEX,EAX
		JNC	L1$

		CMP	[ECX]._S_NSYM_TYPE,NSYM_UNDEFINED
		JNZ	L2$
L1$:
		OR	[ECX]._S_REF_FLAGS,MASK S_REFERENCED
		CALL	ADD_TO_EXTERNAL_LIST
L2$:
L9$:
		RET

		ASSUME	ECX:NOTHING

FIX_ENTRYPOINT	ENDP



if	any_overlays

		ASSUME	DS:NOTHING

INIT_OVERLAYS	PROC
		;
		;
		;

		SETT	DOING_OVERLAYS
		;
		;ASSIGN $$SLR$$ CLASS TO FIRST SECTION
		;
		CALL	VERIFY_DEFINES
		MOV	AX,$$SLR$$_PTR.OFFS
		MOV	SEG_CLASS_NAME.OFFS,AX
		MOV	BX,$$SLR$$_PTR.SEGM
		MOV	SEG_CLASS_NAME.SEGM,BX
		SETT	SKIP_ORDERING
		CALL	DEFINE_CLASS
		ASSUME	DS:NOTHING
		MOV	DS,DX
		MOV	AX,FIRST_SECTION.OFFS
		MOV	[BX]._C_SECTION.OFFS,AX
		MOV	AX,FIRST_SECTION.SEGM
		MOV	[BX]._C_SECTION.SEGM,AX
		OR	[BX]._C_PLTYPE,MASK LEVEL_0_SECTION

		BITT	$$SLR_CODE_FIRST
		JZ	3$
		RESS	SKIP_ORDERING
3$:
		FIXDS
		FIXES
		MOV	AX,$$SLR_CODE_PTR.OFFS
		MOV	SEG_CLASS_NAME.OFFS,AX
		MOV	BX,$$SLR_CODE_PTR.SEGM
		MOV	SEG_CLASS_NAME.SEGM,BX
		CALL	DEFINE_CLASS
		ASSUME	DS:NOTHING
		MOV	DS,DX
		MOV	AX,FIRST_SECTION.OFFS
		MOV	[BX]._C_SECTION.OFFS,AX
		MOV	AX,FIRST_SECTION.SEGM
		MOV	[BX]._C_SECTION.SEGM,AX
		OR	[BX]._C_PLTYPE,MASK LEVEL_0_SECTION
		FIXDS
		FIXES
		MOV	AX,$$SLR_SCODE_PTR.OFFS
		MOV	SEG_CLASS_NAME.OFFS,AX
		MOV	BX,$$SLR_SCODE_PTR.SEGM
		MOV	SEG_CLASS_NAME.SEGM,BX
		CALL	DEFINE_CLASS
		ASSUME	DS:NOTHING
		MOV	DS,DX
		MOV	AX,FIRST_SECTION.OFFS
		MOV	[BX]._C_SECTION.OFFS,AX
		MOV	AX,FIRST_SECTION.SEGM
		MOV	[BX]._C_SECTION.SEGM,AX
		OR	[BX]._C_PLTYPE,MASK LEVEL_0_SECTION
		RESS	SKIP_ORDERING
		;
		;IF LAST SECTION HAS NO SUBAREAS, USE IT FOR DATA
		;
		LDS	SI,CURN_SECTION
		MOV	CX,DS
		SYM_CONV_DS
		CMP	[SI]._SECT_FIRST_AREA.SEGM,0
		FIXDS
		FIXES
		JZ	9$
		CALL	DO_NEW_SECTION
9$:
		LEA	SI,CURN_SECTION
		LEA	DI,DATA_SECTION
		MOVSW
		MOVSW
		MOVSB			;PLTYPE (LEVEL_0_SECTION)
		MOV	AX,ENDCODE_PTR.OFFS
		MOV	SEG_CLASS_NAME.OFFS,AX
		MOV	AX,ENDCODE_PTR.SEGM
		MOV	SEG_CLASS_NAME.SEGM,AX
		CALL	DEFINE_CLASS
		ASSUME	DS:NOTHING
		MOV	DS,DX
		MOV	AX,DATA_SECTION.OFFS
		MOV	[BX]._C_SECTION.OFFS,AX
		MOV	AX,DATA_SECTION.SEGM
		MOV	[BX]._C_SECTION.SEGM,AX
		OR	[BX]._C_PLTYPE,MASK LEVEL_0_SECTION
		FIXDS
		FIXES
		RET

INIT_OVERLAYS	ENDP

endif

VERIFY_DEFINES	PROC
		;
		;
		;
		CMP	DGROUP_TPTR.TPTR_STRUCT._TP_HASH,0
		JZ	L1$
		RET

L1$:
		PUSHM	EDI,ESI,EBX
		MOV	ESI,OFF DGROUP_TPTR		;IF .DEF SUPPORT, THIS WAS
		CALL	DEFINE_SYMBOLS
		;
		;OK, NOW DEFINE SOME SPECIAL CLASSES FOR EASY CHECKING LATER...
		;	DEBTYP, DEBSYM, BSS, BEGDATA, STACK, CODE
		;
		MOV	ESI,OFF SPEC_CLASSES
L2$:
		PUSH	ESI
		MOV	EAX,4[ESI]		;PLACE TO STORE RESULT
		MOV	ESI,[ESI]		;TPTR
		ASSUME	ESI:PTR TPTR_STRUCT

		PUSH	EAX
		MOV	EDI,OFF SYMBOL_TPTR._TP_TEXT
		MOV	ECX,[ESI]._TP_LENGTH
		MOV	EDX,[ESI]._TP_HASH
		MOV	SYMBOL_TPTR._TP_LENGTH,ECX
		SHR	ECX,2
		LEA	ESI,[ESI]._TP_TEXT
		ASSUME	ESI:NOTHING

		INC	ECX
		REP	MOVSD

		CALL	INSTALL_CLASS_SYMBOL

		POPM	EBX,ESI
		MOV	[EBX],EAX
		MOV	EAX,[ESI+8]
		ADD	ESI,8
		INC	EAX
		JNZ	L2$
		;
		;NOW SET BITS FOR DEBUG CLASSES
		;
		MOV	EAX,DEBTYP_CLASS_GINDEX
		CONVERT	EAX,EAX,CLASS_GARRAY
		ASSUME	EAX:PTR CLASS_STRUCT
		OR	[EAX]._C_TYPE_FLAG,MASK SEG_CV_TYPES1

		MOV	EAX,DEBSYM_CLASS_GINDEX
		CONVERT	EAX,EAX,CLASS_GARRAY
		OR	[EAX]._C_TYPE_FLAG,MASK SEG_CV_SYMBOLS1

		MOV	EAX,DEBNAM_CLASS_GINDEX
		CONVERT	EAX,EAX,CLASS_GARRAY
		OR	[EAX]._C_TYPE_FLAG,MASK SEG_CV_SYMBOLS1 + MASK SEG_CV_TYPES1
		POPM	EBX,ESI,EDI
		RET

		ASSUME	ESI:NOTHING,EAX:NOTHING

VERIFY_DEFINES	ENDP


DO_SIGNON	PROC
		;
		;
		;
		SETT	SIGNON_DONE
		MOV	EAX,OFF TITLE_MESS
		CALL	AX_MESOUT
		RET

DO_SIGNON	ENDP


CHECK_OUTPUT_TYPE	PROC
		;
		;DETERMINE OUTPUT FILE TYPE
		;
		MOV	EAX,_OUTFILE_GINDEX
		CONVERT	EAX,EAX,OUTFILE_GARRAY
		MOV	EAX,[EAX].OUTFILE_STRUCT._OF_FILE_LIST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		LEA	ESI,[EAX].FILE_LIST_STRUCT.FILE_LIST_NFN
		ASSUME	ESI:PTR NFN_STRUCT

		XOR	EDX,EDX
		MOV	EBX,[ESI].NFN_PATHLEN
		ADD	EBX,[ESI].NFN_PRIMLEN
		MOV	EAX,DPTR [ESI].NFN_FLAGS
		MOV	ECX,[ESI].NFN_EXTLEN
		LEA	ESI,[EBX+ESI].NFN_TEXT
		ASSUME	ESI:NOTHING

		MOV	EBX,0FFH
		TEST	AL,MASK NFN_EXT_SPECIFIED
		JNZ	L5$			;EXTENT SPECIFIED, MAKE SURE OPTIONS REFLECT IT
		;
		;NO EXTENT SPECIFIED, MAKE SURE IT REFLECTS OPTIONS
		;
		MOV	EDX,'SYS'
		BITT	OUTPUT_SYS,BH
		JNZ	SET_EXT
		MOV	EDX,'MOC'
		BITT	OUTPUT_COM,BH
		JNZ	SET_EXT
if	fg_segm
if	fg_td
		BITT	TLINK_DEFAULT_MODE,BH		;TLINK DEFAULT RENAMES TO .DLL EVEN IF WINDOWS OUTPUT
		JNZ	L4$
endif
		CMP	EXETYPE_FLAG,WIN_SEGM_TYPE	;FOR WINDOWS APPS, DLL NOT RENAMED
		JZ	L9$
L4$:
		MOV	EDX,'LLD'
		TEST	FLAG_0C,MASK APPTYPE
		JNZ	SET_EXT
endif
		;
		;THATS ALL I CAN THINK OF...
		;
		RET

SET_EXT		LABEL	PROC

		MOV	[ESI+1],EDX
L9$:
		RET

L5$:
		;
		;EXTENT HAS BEEN SPECIFIED
		;
		BITT	TLINK_OUTTYPE_FOUND,BH		;IGNORE ITS EFFECTS IF OUTTYPE SPECIFIED ELSEWHERE
		JNZ	L9$
		CMP	CL,4
		MOV	EAX,[ESI+1]
		JNZ	L9$
		AND	EAX,0FFFFFFH
if	fg_segm
		CMP	EAX,'LLD'
		JZ	L51$		;PROBABLY DLL
endif
		CMP	EAX,'MOC'
		JZ	L52$		;PROBABLY COM
		CMP	EAX,'SYS'
		JZ	L53$		;PROBABLY SYS
		;
		;AGAIN, THATS ALL FOR NOW
		;
		RET

if	fg_segm OR fg_pe

L51$:
		;
		;DLL
		;
		TEST	FLAG_0C,MASK APPTYPE	;IT IS DLL, IS IT A LIBRARY ?
		JNZ	L9$
		MOV	CL,DLL_NO_LIB_ERR	;NOPE, WARN THEM
		CALL	WARN_RET
		JMP	L9$
endif

L52$:
		;
		;'COM'
		;
if	fg_segm
		BITT	OUTPUT_SEGMENTED,BH
		JNZ	L8$
endif
if	fg_pe
		BITT	OUTPUT_PE,BH
		JNZ	L8$
endif
if	any_overlays
		BITT	DOING_OVERLAYS,BH
		JNZ	L81$
endif
if	fg_dosx
		CMP	EXETYPE_FLAG,DOSX_EXE_TYPE
		JZ	L8$
endif
		CALL	SET_TINY
		JMP	SET_ABS

L53$:
		;
		;'SYS'
		;
if	fg_segm
		BITT	OUTPUT_SEGMENTED,BH
		JNZ	L8$
endif
if	fg_pe
		BITT	OUTPUT_PE,BH
		JNZ	L8$
endif
if	any_overlays
		BITT	DOING_OVERLAYS,BH
		JNZ	L81$
endif
if	fg_dosx
		CMP	EXETYPE_FLAG,DOSX_EXE_TYPE
		JZ	L8$
endif
		CALL	SET_BINARY

SET_ABS		LABEL	PROC

		MOV	AL,0
		MOV	AH,-1
		RESS	EXEPACK_SELECTED,AL
		SETT	OUTPUT_COM_SYS,AH
;		RESS	CHECKSUM_EXE_FLAG,AL
if	fg_dospack
		RESS	SLRPACK_SELECTED,AL
endif
if	fg_winpack
		RESS	WINPACK_SELECTED,AL
		RESS	SEGPACK_SELECTED,AL
endif
		SETT	CV_SEPARATE,AH
		RET

if	fg_segm OR fg_pe OR fg_dosx
L8$:
		;
		;CANNOT DO SEGMENTED .COM OR .SYS FILE
		;
		MOV	EDX,'EXE'
		CALL	SET_EXT
		MOV	CL,SEGM_COM_SYS_ERR
		CALL	WARN_RET
		JMP	L9$
endif

if	any_overlays
L81$:
		;
		;CANNOT OVERLAY .COM OR .SYS FILE
		;
		MOV	EDX,'EXE'
		CALL	SET_EXT
		MOV	CL,OVL_COM_SYS_ERR
		CALL	WARN_RET
		JMP	L9$
endif

CHECK_OUTPUT_TYPE	ENDP


DEFINE_SYMBOLS	PROC
		;
		;DS:SI IS TEXTS
		;
		;USED BY OTHERS TO GET PARTICULAR CLASS NAMES, ETC.
		;
		MOV	EBX,ESI
		LEA	EDI,[ESI].TPTR_STRUCT._TP_TEXT
		MOV	EAX,[ESI].TPTR_STRUCT._TP_LENGTH
		LEA	ESI,[ESI].TPTR_STRUCT._TP_TEXT	;POINT TO LENGTH

		CALL	OPTI_MOVE			;TRANSLATE AND HASH
		ADD	ESI,4
		AND	ESI,-4
		MOV	[EBX + TPTR_STRUCT._TP_HASH],EDX	;STORE HASH
		MOV	AL,[ESI]
		CMP	AL,-1
		JNZ	DEFINE_SYMBOLS
;YY:
		RET

DEFINE_SYMBOLS	ENDP

		public	_move_default_flags
_move_default_flags	proc
		mov	EAX,4[ESP]
_move_default_flags	endp

MOVE_DEFAULT_FLAGS	PROC
		;
		;MOVE BYTES SET BY CONFIG PROGRAM TO DATA AREA
		;
		PUSHM	ESI,EDI
		MOV	ESI,EAX
		MOV	EDI,OFF FLAGS
		MOV	ECX,FLAG_LEN
L11$:
		MOV	AH,[ESI]
		INC	ESI
		MOV	EDX,8
L1$:

		XOR	AL,AL
		SHR	AH,1
		SBB	AL,AL
		STOSB
		DEC	EDX
		JNZ	L1$
		DEC	ECX
		JNZ	L11$

		MOV	EDI,OFF PAGEWIDTH
		MOVSD		;PAGEWIDTH
		MOVSD		;PAGELENGTH
		MOVSD		;CODEVIEW DATA TYPE, CASE_TYPE, TD_INFO_TYPE, XTRA
		MOVSD		;PACK_DEFAULT_SIZE
		POPM	EDI,ESI
		RET

MOVE_DEFAULT_FLAGS	ENDP

if	fgh_anythreads

		PUBLIC	INIT_EAX

INIT_EAX	PROC
	push	EAX
	call	_init_eax
	add	ESP,4
	ret
INIT_EAX	ENDP

endif


if	fgh_inthreads

OS2_FIXER	PROC	NEAR
		;
		;OK, FIRST ADD OBJ FILES TO THREAD LISTS...
		;
		BITT	_HOST_THREADED
		JZ	L9$

		MOV	EAX,OBJ_LIST.FILE_FIRST_GINDEX
		CALL	STICK_IN_THREAD_LIST

		MOV	EAX,LIB_LIST.FILE_FIRST_GINDEX
		CALL	STICK_IN_THREAD_LIST

		PUSH	0
		CALL	Sleep		;MAKE SURE THEY GET ROLLING
L9$:
		RET

OS2_FIXER	ENDP


		PUBLIC	STICK_IN_THREAD_LIST

STICK_IN_THREAD_LIST	PROC
		;
		;
		;
		JMP	CHK_0

L1$:
		;
		;SET UP THINGS LINK_TO_THREAD NEEDS
		;
		MOV	OBJ_LIST.FILE_LAST_GINDEX,EAX
		CALL	LINK_TO_THREAD		;ASSIGN THIS GUY TO NEXT THREAD

		MOV	EAX,OBJ_LIST.FILE_LAST_GINDEX
CHK_0:
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		ASSUME	EAX:PTR FILE_LIST_STRUCT

		MOV	EAX,[EAX].FILE_LIST_NEXT_GINDEX

		TEST	EAX,EAX
		JNZ	L1$

		RET

STICK_IN_THREAD_LIST	ENDP


		PUBLIC	LINK_TO_THREAD


LINK_TO_THREAD	PROC
		;
		;LINK THIS TO NEXT THREAD, START HIM IF NECESSARY
		;
		PUSH	EBX
		MOV	EBX,NEXT_READ_THREAD

		INC	EBX

		AND	EBX,N_R_THREADS-1	;CURRENTLY UP TO FOUR THREADS

		MOV	NEXT_READ_THREAD,EBX
		;
		;IS THIS THREAD RUNNING YET?
		;
		CMP	THREAD_LOCALS[EBX*4],0		;STACK EXISTS IF RUNNING...
		JNZ	L2$

		MOV	EAX,EBX
		CALL	INIT_THREAD
L2$:
		MOV	EAX,EBX				;THREAD #
		;
		;LINK THIS ITEM TO THIS THREAD...
		;
;		CAPTURE	FILE_LIST_SEM			;ENSURE EXCLUSIVE USE OF OBJ_LIST PTRS

		MOV	ECX,OBJ_LIST.FILE_LAST_GINDEX
		CONVERT	ECX,ECX,_FILE_LIST_GARRAY
		ASSUME	ECX:PTR FILE_LIST_STRUCT

		MOV	EBX,THREAD_LOCALS[EBX*4]
		ASSUME	EBX:PTR MYI2_STRUCT

		MOV	[ECX].FILE_LIST_THREAD,EAX	;MARK OWNING THREAD...

		MOV	EDX,[EBX].MYI2_OBJ_LIST.FILE_LAST_GINDEX

		CONVERT	EDX,EDX,_FILE_LIST_GARRAY
		ASSUME	EDX:PTR FILE_LIST_STRUCT

		MOV	EAX,OBJ_LIST.FILE_LAST_GINDEX

		MOV	[EDX].FILE_LIST_MY_NEXT_GINDEX,EAX
		MOV	[EBX].MYI2_OBJ_LIST.FILE_LAST_GINDEX,EAX

;		RELEASE	FILE_LIST_SEM			;RELEASE LOCK ON OBJ_LIST PTRS

		LEA	EAX,[EBX].MYI2_FILENAME_LIST_SEM	;TELL THREAD WE UPDATED HIS PTRS
		CALL	RELEASE_EAX

;		CALL	_do_dossleep_0		;LET THOSE THREADS GRAB IT..

		POP	EBX

		RET

LINK_TO_THREAD	ENDP


INIT_THREAD	PROC	NEAR
		;
		;EAX IS THREAD #
		;
		PUSHM	EDI,ESI

		PUSH	EBX
		MOV	EBX,EAX
		;
		;FIRST, ALLOCATE STACK SPACE
		;
		;ALLOCATE 4K STACK PLEASE
		push	EDX
		push	ECX
		call	_get_4k_segment
		pop	ECX
		pop	EDX

		MOV	THREAD_LOCALS[EBX*4],EAX

		IMUL	EBX,EBX,SIZE MYI_STRUCT

		MOV	MYI_STUFF[EBX].MYI_LOCALS,EAX
		MOV	EBX,EAX
		ASSUME	EBX:PTR MYI2_STRUCT

		MOV	EDI,EAX
		MOV	ECX,(SIZE MYI2_STRUCT)/4

		XOR	EAX,EAX

		REP	STOSD

		MOV	AL,FILE_LIST_STRUCT.FILE_LIST_NFN
		TEXT_POOL_ALLOC		;EAX

		MOV	EDI,EAX
		INSTALL_POINTER_GINDEX	_FILE_LIST_GARRAY

		MOV	[EBX].MYI2_LAST_FILENAME_OPENED_GINDEX,EAX	;LAST FILENAME I OPENED
		MOV	[EBX].MYI2_OBJ_LIST.FILE_LAST_GINDEX,EAX	;FILES ASSIGNED TO ME...
		MOV	[EBX].MYI2_OBJ_LIST.FILE_FIRST_GINDEX,EAX
		XOR	EAX,EAX
		MOV	ECX,FILE_LIST_STRUCT.FILE_LIST_NFN/4
		REP	STOSD

		DEC	EAX

		MOV	[EBX].MYI2_NEXT_OPEN_STRUC,EAX	;NEXT OPENFILE STRUCTURE USED BY ME
		MOV	[EBX].MYI2_NEXT_FILE_BUFFER,EAX	;NEXT BUFFER I WILL READ INTO
		MOV	[EBX].MYI2_NEXT_OPEN_FILE,EAX	;NEXT FILE THREAD 1 WILL OPEN
		MOV	[EBX].MYI2_NEXT_16K_BLOCK,EAX	;NEXT BLOCK THREAD 1 WILL READ
		;
		;INITIALIZE OPENFILE STUFF
		;
		MOV	[EBX].MYI2_OPEN_FLAGS,0H+80H+20H+100H;R/O, NO INHERIT,DENY WRITE, SEQUENTIAL ACCESS
		;
		;SET FOR FLAGS, MARKING FILES NOT OPEN
		;
;		LEA	EAX,[EBX].MYI2_OPREAD_TERM_SEM
;		CALL	INIT_EAX

;		LEA	EAX,[EBX].MYI2_OPREAD_TERM_SEM
;		CALL	CAPTURE_EAX			;THREAD STILL READING

		LEA	EAX,[EBX].MYI2_FILENAME_LIST_SEM
		CALL	INIT_EAX

		LEA	EAX,[EBX].MYI2_FILENAME_LIST_SEM
		CALL	CAPTURE_EAX			;FILENAME_LIST IS EMPTY

		LEA	EAX,[EBX].OPENFILE_AVAIL_SEM	;ITEM AVAILABLE TO OPREAD THREAD
		CALL	INIT_EAX

		LEA	EAX,[EBX].OPENFILE_AVAIL_SEM	;2 ITEMS AVAILABLE TO OPREAD THREAD
		CALL	RELEASE_EAX

		LEA	EAX,[EBX].OPENFILE_AVAIL_SEM	;3 ITEMS AVAILABLE TO OPREAD THREAD
		CALL	RELEASE_EAX

		LEA	EAX,[EBX].OPENFILE_AVAIL_SEM	;4 ITEMS AVAILABLE TO OPREAD THREAD
		CALL	RELEASE_EAX

		LEA	EAX,[EBX].OPENFILE_OPEN_SEM
		CALL	INIT_EAX

		LEA	EAX,[EBX].OPENFILE_OPEN_SEM
		CALL	CAPTURE_EAX			;NO FILES OPEN

		LEA	EAX,[EBX].OPENFILE_HEADER_SEM
		CALL	INIT_EAX

		LEA	EAX,[EBX].OPENFILE_HEADER_SEM
		CALL	CAPTURE_EAX			;HEADER NOT READ YET
		;
		;SET FOR FLAGS, MARKING BUFFERS NOT FULL
		;
		LEA	EAX,[EBX].INS_FULL_SEM
		CALL	INIT_EAX

		LEA	EAX,[EBX].INS_FULL_SEM
		CALL	CAPTURE_EAX			;NOTHING IN DATA BUFFER

		LEA	EAX,[EBX].INS_AVAIL_SEM
		CALL	INIT_EAX			;BUFFER AVAILABLE TO OPREAD

		LEA	EAX,[EBX].INS_AVAIL_SEM
		CALL	RELEASE_EAX			;BUFFER AVAILABLE TO OPREAD

		LEA	EAX,[EBX].INS_AVAIL_SEM
		CALL	RELEASE_EAX			;BUFFER AVAILABLE TO OPREAD

		LEA	EAX,[EBX].INS_AVAIL_SEM
		CALL	RELEASE_EAX			;BUFFER AVAILABLE TO OPREAD
		;
		;NOW START THREAD
		;
		LEA	EAX,[EBX].MYI2_OPREAD_THREAD_ID

		PUSH	EAX
		PUSH	0				;DON'T CREATE SUSPENDED

		PUSH	EBX				;MY LOCAL STORAGE
		PUSH	OFF OPREADT			;THREAD HEAD

		PUSH	4K				;STACK COMMIT SIZE
		PUSH	0				;SECURITY DESCRIPTOR

		CALL	CreateThread

		TEST	EAX,EAX
		JZ	L9$

		MOV	[EBX].MYI2_OPREAD_THREAD_HANDLE,EAX

		PUSH	0
		CALL	Sleep			;LET HIM HAVE A TICK

		POPM	EBX,ESI,EDI

		RET

L9$:
		MOV	AL,THREAD_FAIL_ERR
		push	EAX
		call	_err_abort

		ASSUME	ESI:NOTHING
		ASSUME	EBX:NOTHING

INIT_THREAD	ENDP

endif


END_ENVIRON_SCAN	PROC
		;
		;
		;
		POPM	EBX,ESI,EDI
		RESS	USING_TEMP_RECORD
		RET

END_ENVIRON_SCAN	ENDP


ENVIRON_SCAN	PROC
		;
		;SI IS TABLE (IN CODE), SEARCH ENVIRONMENT FOR THIS STRING
		;	DD	STRING (IN CODE)
		;	DD	ROUTINE	(IN CURRENT CS)
		;
		PUSHM	EDI,ESI,EBX
		MOV	ESI,EAX
		XOR	EAX,EAX
		MOV	EDI,ENVIRONMENT_BLOCK
		MOV	EBX,OFF END_ENVIRON_SCAN
		SETT	USING_TEMP_RECORD
		PUSH	EBX
		TEST	EDI,EDI
		JZ	L99$

		MOV	EBX,4[ESI]
		MOV	EDX,[ESI]
		PUSH	EBX
		JMP	L7$

L1$:
		XOR	ECX,ECX
		LEA	ESI,[EDX+1]
		MOV	CL,[EDX]	;STRING LENGTH (INCLUDING =)
		MOV	EBX,EDI
if	fgh_win32
		PUSHM	EBP,EDX

		PUSHM	EBX,EAX

		XOR	EAX,EAX
		XOR	EBX,EBX

		MOV	EBP,OFF UPPER_TABLE
		;
		;COMPARE IGNORING CASE
		;
L11$:
		MOV	AL,[ESI]
		MOV	BL,[EDI]

		INC	ESI
		INC	EDI

		MOV	AL,[EBP+EAX]
		MOV	BL,[EBP+EBX]

		CMP	AL,BL
		JNZ	L15$

		DEC	ECX
		JNZ	L11$
L15$:
		POPM	EAX,EBX

		POPM	EDX,EBP

else
		REPE	CMPSB	;COMPARE ECX BYTES
endif
		JZ	L4$	;MATCH, JUMP

		DEC	EDI	;NEED TO FIND END OF STRING
		MOV	CH,4	;1K MAX, ABORT
		XOR	AL,AL
		REPNE	SCASB	;THANK-YOU
		JNZ	L9$
L7$:
		CMP	[EDI],AL	;TRAILING ZERO?
		JNZ	L1$
L9$:
		;
		;NOTHING FOUND, RETURN
		;
		POP	EAX		;GARBAGE
L99$:
		RET

L8$:
		POP	EDI
		JMP	L9$

L4$:
		;
		;ES:DI POINTS TO STRING...
		;
		PUSH	EDI
L41$:
		;
		;SEE IF ANY NON-BLANK CHARACTERS
		;
		MOV	AL,[EDI]
		INC	EDI
		CMP	AL,0
		JZ	L8$
		CMP	AL,' '
		JZ	L41$
		CMP	AL,9
		JZ	L41$

		POP	ESI
		RET		;JUMP WITH DS:SI AS INPUT STRING...

ENVIRON_SCAN	ENDP


SCAN_HELPER	PROC
		;
		;
		;
		MOV	EDI,OFF TEMP_RECORD+4	;BUFFER AVAILABLE...
		XCHG	EBX,ESI
		SUB	EBX,ESI
L1$:
		MOV	AL,[ESI]		;MOVE STRING TILL 0
		INC	ESI
		MOV	[EDI],AL
		INC	EDI
		OR	AL,AL
		JNZ	L1$
		MOV	DPTR [EDI-1],1A0DH
		SUB	EDI,OFF TEMP_RECORD+4
		LEA	EAX,TEMP_RECORD+4[EBX]
		MOV	DPTR TEMP_RECORD,EDI
		RET

SCAN_HELPER	ENDP


SCAN_HELPER_SLASH	PROC
		;
		;
		;
		MOV	EDI,OFF TEMP_RECORD+4	;BUFFER AVAILABLE...
		XCHG	EBX,ESI
		SUB	EBX,ESI
L1$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'/'
		JZ	L5$
L19$:
		MOV	[EDI],AL
		INC	EDI
		OR	AL,AL
		JNZ	L1$
		MOV	DPTR [EDI-1],1A0DH
		SUB	EDI,OFF TEMP_RECORD+4
		LEA	EAX,TEMP_RECORD+4[EBX]
		MOV	DPTR TEMP_RECORD,EDI
		RET

L5$:
		MOV	AL,'\'
		JMP	L19$

SCAN_HELPER_SLASH	ENDP


if	fg_virt


TMP_ROUTINE	PROC
		;
		;
		;
		CALL	SCAN_HELPER_SLASH

		MOV	INPTR1,EAX
		SETT	FORCE_PATH
		MOV	BX,OFF LIBSTUFF

		push	EDX
		push	ECX
		push	EAX
		call	_get_filename		;NOW, WAS A PATH SUPPLIED?
		add	ESP,12

		RESS	FORCE_PATH
		RET

TMP_ROUTINE	ENDP

endif


LIB_ROUTINE	PROC
		;
		;
		;
		CALL	SCAN_HELPER_SLASH
		push	EAX
		call	_lib_routine_final
		add	ESP,4
		RET

LIB_ROUTINE	ENDP


PATH_ROUTINE	PROC
		;
		;
		;
		CALL	SCAN_HELPER_SLASH
		MOV	ESI,EAX
		SETT	FORCE_PATH
		JMP	L2$

L1$:
		MOV	EDX,ESI
		MOV	ECX,OFF FILNAM
		MOV	EAX,OFF PATHSTUFF

		push	EDX
		push	ECX
		push	EAX
		call	_get_filename		;NOW, WAS A PATH SUPPLIED?
		add	ESP,12

		MOV	ESI,EAX
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_STUBPATHS
L2$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,';'
		JZ	L2$			;SKIP ';'
		CMP	AL,','
		JZ	L2$
		CMP	AL,' '
		JZ	L2$
		CMP	AL,0DH
		JZ	L9$
		DEC	ESI
		CMP	AL,1AH
		JNZ	L1$
L9$:
		RESS	FORCE_PATH
		RET

PATH_ROUTINE	ENDP


OPTLIB_ROUTINE	PROC
		;
		;
		;
		CALL	SCAN_HELPER
		PUSH	INPTR1
		MOV	INPTR1,EAX
		CALL	GETNST_SLASH
		POP	INPTR1
		RET

OPTLIB_ROUTINE	ENDP


OBJ_ROUTINE	PROC
		;
		;
		;
		CALL	SCAN_HELPER_SLASH
		MOV	ESI,EAX
		SETT	FORCE_PATH
		JMP	L2$

L1$:
		MOV	EDX,ESI
		MOV	ECX,OFF FILNAM
		MOV	EAX,OFF PATHSTUFF

		push	EDX
		push	ECX
		push	EAX
		call	_get_filename		;NOW, WAS A PATH SUPPLIED?
		add	ESP,12

		MOV	ESI,EAX
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_OBJPATHS
L2$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,';'
		JZ	L2$			;SKIP ';'
		CMP	AL,','
		JZ	L2$
		CMP	AL,' '
		JZ	L2$
		CMP	AL,0DH
		JZ	L9$
		DEC	ESI
		CMP	AL,1AH
		JNZ	L1$
L9$:
		RESS	FORCE_PATH
		RET

OBJ_ROUTINE	ENDP


if	fg_cv

CODEVIEW_FINISH	PROC	NEAR
		;
		;BASED ON CV_INFO_TYPE, FIX UP OTHER THINGS...
		;
		BITT	CODEVIEW_FLAG
		JZ	L9$		;NO CV SELECTED

if	fg_pe
		BITT	OUTPUT_PE
		JZ	L1$
		BITT	CODEVIEW_FLAG
		JZ	L1$
		SETT	CV_SYM1_TYPE
                CMP	CV_INFO_TYPE,5
                JE	L1$
		RESS	CV_SYM1_TYPE
		MOV	CV_INFO_TYPE,4
L1$:
endif
		RESS	NEW_CV_INFO
		MOV	CL,CV_INFO_TYPE
		MOV	AX,'00'
		CMP	CL,3
		JB	L5$
		JZ	L4$
		SETT	CV_4_TYPE
		MOV	AH,'5'
		MOV	WPTR CV_HEADER+2,AX
		BITT	CVPACK_FLAG
		JZ	L3$
if	fg_cvpack
		MOV	BPTR CV_HEADER+3,'9'

		MOV	EAX,OFF CV_LTYPE_GARRAY
		CALL	MARRAY_INIT
		MOV	EAX,OFF CV_GTYPE_GARRAY
		CALL	MARRAY_INIT
		MOV	EAX,OFF CV_GSYM_GARRAY
		CALL	MARRAY_INIT
else
		CALL	FIND_CVPACK
endif

L3$:
		CMP	CV_INFO_TYPE,5		;check for /CO:5 
		JNZ	L3_1$

		MOV	DPTR CV_HEADER,'1RTJ'
L3_1$:
		RET

L4$:
		SETT	NEW_CV_INFO
		MOV	AH,'2'
L5$:
		RESS	CVPACK_FLAG
		MOV	WPTR CV_HEADER+2,AX
L9$:
		RET

CODEVIEW_FINISH	ENDP

endif

if	fg_td

TD_FINISH	PROC	NEAR
		;
		;BASED ON TD_INFO_TYPE, FIX UP OTHER THINGS
		;
		BITT	TD_FLAG
		JNZ	1$
		RET

1$:
		RESS	PACKFUNCTIONS_FLAG

		LEA	SI,MDB_PARRAY
		CALL	RELEASE_PARALLEL_ARRAY

		LEA	SI,MDB_PARRAY
		MOV	AX,SIZE MDB_STRUCT
		CALL	INIT_PARALLEL_ARRAY

		LEA	SI,TD_SYMBOL_PARRAY
		MOV	AX,SIZE TD_S_STRUCT
		CALL	INIT_PARALLEL_ARRAY

		LEA	SI,TD_GSCOPE_PARRAY
		MOV	AX,SIZE TD_GSCOPES_STRUCT
		CALL	INIT_PARALLEL_ARRAY

		LEA	SI,TD_OPTSYM_PARRAY
		MOV	AX,SIZE TD_OPTSYMS_STRUCT
		CALL	INIT_PARALLEL_ARRAY

		LEA	SI,TD_COVERAGE_PARRAY
		MOV	AX,2
		CALL	INIT_PARALLEL_ARRAY

		LEA	SI,TD_LTYPE_GARRAY
		CALL	MARRAY_INIT

		LEA	SI,TD_LCLASS_GARRAY
		CALL	MARRAY_INIT

		LEA	SI,TD_GCLASS_GARRAY
		CALL	MARRAY_INIT

		LEA	SI,TD_LSMEM_GARRAY
		CALL	MARRAY_INIT

		FIXDS
		LEA	SI,TD_GTYPE_GARRAY32
		LEA	CX,TD_GTYPE_STUFF
if	@CodeSize
		MOV	AX,SEG TD_GTYPE_POOL_GET
endif
		MOV	BX,OFF TD_GTYPE_POOL_GET
		CALL	INIT_ARRAY32

		FIXDS
		LEA	SI,TD_GLOCAL_GARRAY32
		LEA	CX,TD_GLOCAL_STUFF
if	@CodeSize
		MOV	AX,SEG TD_GLOCAL_POOL_GET
endif
		MOV	BX,OFF TD_GLOCAL_POOL_GET
		CALL	INIT_ARRAY32

		FIXDS
		LEA	SI,TD_GSMEM_GARRAY32
		LEA	CX,TD_GSMEM_STUFF
if	@CodeSize
		MOV	AX,SEG TD_GSMEM_POOL_GET
endif
		MOV	BX,OFF TD_GSMEM_POOL_GET
		CALL	INIT_ARRAY32

		CALL	GET_NEW_LOG_BLK
		MOV	ES,AX
		MOV	TD_GTYPE_HASH_LOG,AX
		CONV_ES
		XOR	DI,DI
		MOV	CX,PAGE_SIZE/2
		XOR	AX,AX
		REP	STOSW

		CALL	GET_NEW_LOG_BLK
		MOV	ES,AX
		MOV	TD_GSMEM_HASH_LOG,AX
		CONV_ES
		XOR	DI,DI
		MOV	CX,PAGE_SIZE/2
		MOV	TD_GSMEM_HASH_PTR.OFFS,DI
		MOV	TD_GCLASS_HASH_PTR.OFFS,CX
		XOR	AX,AX
		REP	STOSW

		FIXES
9$:
		RET

TD_FINISH	ENDP

		ASSUME	DS:NOTHING

endif

if	0	;fg_winpack

		ASSUME	DS:NOTHING

WINPACK_FINISH	PROC	NEAR
		;
		;
		;
		BITT	WINPACK_SELECTED
		JZ	9$
		CALL	FORCE_SIGNON
ife	fgh_os2
		MOV	AH,2CH
		INT21
		PUSH	DX			;SAVE MINUTES-SECONDS
endif
		MOV	AX,SEG WINPACK_TEXT
		MOV	DS,AX
		ASSUME	DS:NOTHING
		MOV	SI,OFF WINPACK_TEXT
		MOV	AX,WINPACK_TEXT_LENGTH
		CALL	LOUTALL_CON
ife	fgh_os2
		POP	BX
		FIXDS
		ADD	BH,5
		CMP	BH,60
		JB	1$
		SUB	BH,60
1$:
		MOV	AH,2CH
		INT21
		CMP	BH,DH
		JNZ	1$
endif

9$:
		RET

WINPACK_FINISH	ENDP

WINPACK_TEXT	DB	0DH,0AH
		DB	'A compressed program (a .dll or .exe incorporating SLR''s Windows compression',0dh,0ah
		DB	'technology) may be sublicensed, sold, leased, or otherwise disposed of for use',0dh,0ah
		DB	'on a single CPU, without any additional licensing or fees, provided that the',0dh,0ah
		DB	'total number of units sublicensed, sold, leased, or otherwise disposed of does',0dh,0ah
		DB	'not exceed five hundred (500).  Contact SLR Systems, Inc. for licensing details',0dh,0ah
		DB	'on higher quantities.',0dh,0ah,0dh,0ah

WINPACK_TEXT_LENGTH	EQU	$-WINPACK_TEXT

endif

if	0

MCBTA8		MACRO	XX
		LOCAL	X,Y,Z

Z		=	0
X		=	XX
Y		=	X/100
X		=	X-Y*100

if	Y
		DB	Y+30H
Z		=	1
endif

Y		=	X/10
X		=	X-Y*10

if	Y OR Z
		DB	Y+30H
Z		=	1
endif

Y		=	X
		DB	Y+30H

		ENDM


if	_PRODUCT EQ 5			;OPTLINK SEGMENTED

if	0

PROD_TEXT	EQU	<OPTLINK/2>

else

PROD_TEXT	EQU	<OPTLINK for Windows>

endif

elseif	_PRODUCT EQ 7			;OPTLINK/COMPRESS

PROD_TEXT	EQU	<OPTLINK/Compress>

endif

DEMO_TEXT	DB	' ',0DH,0AH
		DB	'Welcome to the '
%		DB	'&PROD_TEXT '
		DB	(HIGH RELEASE_NUM)+30H,'.'
		DB	(LOW RELEASE_NUM)/16+30H,((LOW RELEASE_NUM) MOD 16)+30H
		DB	' demo.  This is a full-function',0DH,0AH
		db	'version of OPTLINK for your evaluation.  You may ONLY use this software',0DH,0AH
		db	'to test the functionality and performance of '
%		DB	'&PROD_TEXT.  All',0DH,0AH
		db	'of your rights to this software expire on '
		MCBTA8	EXPIRE_MONTH
		DB	'/'
		MCBTA8	EXPIRE_DAY
		DB	'/'
		MCBTA8	EXPIRE_YEAR-1900
		DB	'.',0DH,0AH
		db	' ',0DH,0AH
		db	'For a distribution copy of '
%		DB	'&PROD_TEXT'
		DB	' including comprehensive manual,',0DH,0AH
		db	'CALL NOW!!:',0DH,0AH
		db	'               SLR Systems, Inc.',0DH,0AH
		db	'               1622 N. Main St.',0DH,0AH
		db	'               Butler, PA  16001',0DH,0AH
		db	'               (412)282-0864 VOICE',0DH,0AH
		db	'               (412)282-7965 FAX',0DH,0AH
		db	'               (412)282-2799 BBS',0DH,0AH
		db	' ',0DH,0AH
		db	'Now, for benchmarking, be sure to subtract the 30-seconds that this message',0DH,0AH
		db	'sits here...',0DH,0AH

DEMO_TEXT_LENGTH	EQU	$-DEMO_TEXT

endif

		DB	'(SCVersion)@link '
		DB	(HIGH RELEASE_NUM)+30H,'.'
		DB	(LOW RELEASE_NUM)/16+30H,((LOW RELEASE_NUM) MOD 16)+30H
		DB	'B'
if	(RELEASE_SUBNUM)/16
		DB	(RELEASE_SUBNUM)/16+30H
endif
		DB	((RELEASE_SUBNUM) MOD 16)+30H
		DB	0

TITLE_MESS	DB	TITLE_LEN-1,0DH

ifdef	MSCOPE
		DB	'MultiScope '
endif

if	J EQ 4
		DB	'ROMLINK'
elseif fg_plink
		DB	'OPTLINK/Overlays'
elseif fg_dospack
		DB	'OPTLINK/Compress'
elseif fg_rom
		DB	'OPTLINK/Locate'
elseif J EQ 5
		DB	'OPTLINK (R) /Segmented'
;elseif (_PRODUCT EQ 12 )
;		DB	'WINPACK'
;if	fgh_dpmi
;		DB	' (DPMI)'
;endif
elseif fg_pe
		DB	'OPTLINK (R) for Win32'
if	fgh_dpmi
		DB	' (DPMI)'
endif
elseif fg_segm AND NOT 0;fgh_os2
		DB	'OPTLINK (R) for Windows'
if	fgh_dpmi
		DB	' (DPMI)'
endif
elseif fg_segm AND 0;fgh_os2
		DB	'OPTLINK (R) /2'
elseif	fg_virt
		DB	'OPTLINK'
elseif 0;fgh_os2
		DB	'OPTLINK/R'
else
		DB	'OLINK'
endif
		DB	'  Release '
		DB	(HIGH RELEASE_NUM)+30H,'.'
		DB	(LOW RELEASE_NUM)/16+30H
		DB	((LOW RELEASE_NUM) MOD 16)+30H
ifdef	RELEASE_SUB
		DB	RELEASE_SUB
else
		DB	' '
endif
ifdef	RELEASE_SUBNUM
if	(RELEASE_SUBNUM)/16
		DB	(RELEASE_SUBNUM)/16+30H
endif
		DB	((RELEASE_SUBNUM) MOD 16)+30H
endif
if	fg_symc
		DB	'  for DMC++'
endif
		DB	0DH,0AH
		DB	'Copyright (C) Digital Mars 1989-2010'
		DB	'  All rights reserved.',0DH,0AH
		db	'http://www.digitalmars.com/ctg/optlink.html',0DH,0AH

TITLE_LEN	EQU	$-TITLE_MESS

if	fg_virt

TMP_STRING	DB	4,'TMP='

endif

if	fg_mscmd

if	fg_dospack
OPTLIB_STRING	DB	8,'OPTCOMP='
elseif _PRODUCT eq 5
OPTLIB_STRING	DB	9,'OPTLINKS='
elseif _PRODUCT eq 12
OPTLIB_STRING	DB	9,'OPTLINKS='
else
OPTLIB_STRING	DB	8,'OPTLINK='
endif

endif

LINK_STRING	DB	5,'LINK='

LIB_STRING	DB	4,'LIB='

PATH_STRING	DB	5,'PATH='

OBJ_STRING	DB	4,'OBJ='


		ALIGN	4

if	fg_mscmd

OPTLNK_ENVIRONMENT	LABEL	WORD

		DD	OPTLIB_STRING
		DCA	OPTLIB_ROUTINE

endif

LINK_ENVIRONMENT	LABEL	WORD

		DD	LINK_STRING
		DCA	OPTLIB_ROUTINE

if	fg_virt

TMP_ENVIRONMENT	DD	TMP_STRING
		DCA	TMP_ROUTINE

endif

LIB_ENVIRONMENT	DD	LIB_STRING
		DCA	LIB_ROUTINE


PATH_ENVIRONMENT DD	PATH_STRING		;USED FOR FINDING CVPACK, STUB, OLD, ETC
		DCA	PATH_ROUTINE


OBJ_ENVIRONMENT	DD	OBJ_STRING
		DCA	OBJ_ROUTINE

		.DATA

		ALIGN	4

GEN_TPTRS	MACRO	XX
		LOCAL	X

		PUBLIC	XX&_TPTR
XX&_TPTR	DD	0			;;MODULE # IF LOCAL
		DD	0			;;HASH
		DD	SIZEOF X		;;STRING LENGTH
X		DB	'&XX'			;;STRING
		REPT	4 - ((SIZEOF X) AND 3)
		DB	0			;;TRAILING ZERO
		ENDM
		ENDM

		ALIGN	4

GEN_TPTRS	DGROUP
GEN_TPTRS	CODE
GEN_TPTRS	DEBTYP
GEN_TPTRS	DEBSYM
GEN_TPTRS	DEBNAM
GEN_TPTRS	BSS
GEN_TPTRS	BEGDATA
GEN_TPTRS	STACK
GEN_TPTRS	c_common
GEN_TPTRS	FAR_BSS
GEN_TPTRS	FAR_DATA
GEN_TPTRS	HUGE_BSS
GEN_TPTRS	COMDAT_SEGNNNNN
if	fg_pe
GEN_TPTRS	ICODE
GEN_TPTRS	IMP__DATA
GEN_TPTRS	tls
endif
if	fg_rom
GEN_TPTRS	STARTUP
endif
GEN_TPTRS	_TEXT
if	any_overlays
GEN_TPTRS	$$SLR$$
GEN_TPTRS	$$SLR_CODE
GEN_TPTRS	$$SLR_SCODE
GEN_TPTRS	$$SLR_VECTORS
GEN_TPTRS	$$SLR_SECTIONS
GEN_TPTRS	$$SLR_FNAMES
GEN_TPTRS	$$SLR_TABLE
endif

NUL_TPTR	DD	0,0
		DD	0,0

		DB	-1

		ALIGN	4

SPEC_CLASSES	LABEL	DWORD

		DD	CODE_TPTR,CODE_CLASS_GINDEX
		DD	DEBTYP_TPTR,DEBTYP_CLASS_GINDEX
		DD	DEBSYM_TPTR,DEBSYM_CLASS_GINDEX
		DD	DEBNAM_TPTR,DEBNAM_CLASS_GINDEX
		DD	BSS_TPTR,BSS_CLASS_GINDEX
		DD	BEGDATA_TPTR,BEGDATA_CLASS_GINDEX
		DD	STACK_TPTR,STACK_CLASS_GINDEX
if	fg_pe
		DD	tls_TPTR,tls_CLASS_GINDEX
endif
		DD	-1

;if	fg_segm
;WINMAIN_TEXT	DB	LENGTH WINMAIN_TEXT-1,'WINMAIN'
;endif

.DATA?
		ALIGN	4

CMDLINE_BLOCK_LOG	DD	?


		END

