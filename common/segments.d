
module segments;

struct SEGMENT_STRUCT
{

    uint _SEG_NEXT_HASH_GINDEX;	// NEXT SEGMENT THIS HASH
    uint _SEG_LAST_SEGMOD_GINDEX; // NEXT SEGMENT THIS CLASS

    uint _SEG_CLASS_GINDEX;	// CLASS POINTER
    uint _SEG_GROUP_GINDEX;	// GROUP AFFILLIATION

    uint _SEG_OFFSET;		// OFFSET FROM FRAME FOR SEGMENTED, ELSE REAL ADDRESS

    uint _SEG_OS2_NUMBER;	// SEGMENT NUMBER (DWORD FRAME ADDRESS IN REAL MODE AND FOR ASEGS) (PE_SECTION)
    uint _SEG_OS2_FLAGS;	// PRELOAD, MOVABLE, ETC

    uint _SEG_FIRST_SEGMOD_GINDEX;
    uint _SEG_NEXT_SEG_GINDEX;

    version(fg_rom)
    {
	uint _SEG_PHASE;
    }

    version(fg_plink)
    {
	uint _SEG_SECTION_GINDEX;	// ASSIGNED SECTION
	ubyte _SEG_PLTYPE;		// (PLTYPES RECORD)
	ubyte _SEG_32FLAGS;
	ushort reserved;
    }
    else
    {

	ubyte _SEG_32FLAGS;	// SEG32_FLAGS_REC (USE_32, ETC)
	ubyte reserved1;
	ushort reserved2;
    }

    uint _SEG_CV_NUMBER;	// SEGMENT # FOR 16-BIT CODEVIEW...
    version(fg_cv)
    {
	uint _SEG_NEXT_CV_GINDEX; // NEXT SEGMENT CV ORDER (FOR OLD 16-BIT COMPATIBILITY)
    }
    ubyte _SEG_ORDER_FLAG;	// ORDERING STUFF
    ubyte _SEG_MAX_ALIGN;	// MAXIMUM ALIGNMENT THIS SEGMENT
    ubyte _SEG_COMBINE;		// SEGMENT ATTRIBUTES(PUBLIC, STACK, PRIVATE)
    ubyte _SEG_TYPE;		// ASEG, RELOC, UNDEFINED

    uint _SEG_HASH;
    uint _SEG_TEXT;	// ACTUAL NAME...

	// ***** MUST BE EVEN WORDS *****
}

_SEG_LEN		EQU	(_SEG_NEXT_HASH_GINDEX)

_SEG_FRAME		EQU	(_SEG_OS2_NUMBER)

_SEG_PEOBJECT_NUMBER	EQU	<_SEG_CV_NUMBER>
_SEG_PEOBJECT_GINDEX	EQU	<_SEG_OS2_NUMBER>

enum SEG32_FLAGS_REC
{
	SEG32_USE16:1,
	SEG32_NONZERO:1,
	SEG32_USE32:1
}

enum DEF_RECORD
{
	DEF_NEXT_DIFFERENT:1,
	DEF_ORDERED:1,
	DEF_ORGED:1,
	DEF_OMITTED:1,
	DEF_PHASEE:1,
	DEF_PHASE_TARG:1,
	DEF_OS2_DEFINED:1,
	DEF_ALIGNED:1
}

version(fg_segm)
{

enum SEGREC
{
	SR_1:1,		// ??? USED BY FIXUPP2 AS 'IMPORTED' FLAG
	SR_HUGE:1,	// SEGMENT IS HUGE
	SR_32:1,	// SEGMENT IS 32-BIT
	SR_DISCARD:1,	// SEGMENT IS DISCARDABLE
	SR_DPL:2,	// 286 DPL BITS???
	SR_CONF:1,	// SEGMENT IS CONFORMING
	SR_RELOC:1,	// SEGMENT HAS RELOCATION RECORDS
	SR_EO_RO:1,	// SEGMENT IS EXECUTE-ONLY, OR READ-ONLY
	SR_PRELOAD:1,	// SEGMENT PRELOADS
	SR_SHARED:1,	// SEGMENT IS SHARABLE
	SR_MOVABLE:1,	// SEGMENT IS MOVABLE
	SR_ITERATE:1,	// SEGMENT IS ITERATED
	SR_TYPE:3	// SEGMENT TYPE 0=CODE, 1=DATA
}


enum SEGREC1
{
	SR_2:13,
	SR_MULTIPLE:2,
	SR_3:1
}

SR_READ		=	<SR_HUGE>	// JUST DURING .DEF PROCESSING
SR_WRITE	=	<SR_RELOC>
SR_EXECUTE	=	<SR_ITERATE>

}

	// **** MUST MAKE SURE CDDATA MATCHES ****
struct SEGMOD_STRUCT
{

    uint _SM_BASE_SEG_GINDEX;		// PTR BACK TO BASE SEGMENT
    uint _SM_NEXT_SEGMOD_GINDEX;	// NEXT SEGMOD THIS SEGMENT OR SECTION

    uint _SM_START;	// OFFSET FROM FRAME IF SEGMENTED, ELSE REAL ADDRESS
    uint _SM_LEN;	// LENGTH THIS PIECE - LATER LENGTH + SM_START
    uint _SM_FIRST_DAT;	// LEDATA, LIDATA, FIXUPP, FORREF (VM)

    uint _SM_SECTION_GINDEX;	// NEED THIS EVEN WITHOUT OVERLAYS...

    ubyte _SM_PLTYPE;		// (PLTYPES RECORD)
    ubyte _SM_FLAGS_2;		// CSEG DEFINED
    ubyte _SM_ALIGN;		// ALIGN THIS PIECE
    ubyte _SM_FLAGS;

    uint _SM_MODULE_CSEG_GINDEX;	// OWNING MODULE, OR DEBUG CSEG PTR

    uint _SM_COMDAT_LINK;

	// ***** MUST MAKE SURE CDDATA MATCHES *****
}

const _SM_RELOC_CNT = _SM_START;	// HERE CAUSE SECTION MAY NOT BE ASSIGNED YET...

enum SEGMENT_REC
{
	SEG_CV_TYPES1:1,
	SEG_CV_SYMBOLS1:1,
	SEG_IN_DGROUP:1,
	SEG_CLASS_IS_CODE:1,
	SEG_CONST:1,
	SEG_RELOC:1,
	SEG_ASEG:1,
	SEG_MOVEABLE:1
}

enum SM_REC_2
{
	SM2_COMDAT:1,
	SM2_DATA_IN_CODE:1,
	SM2_CSEG_DONE:1
}

const SC_PRIVATE	=	0
const SC_MEMORY	=	1	// TREATED LIKE PUBLIC
const SC_PUBLIC	=	2
const SC_STACK	=	5
const SC_COMMON	=	6
const SC_ABSOLUTE	=	0FEH
const SC_UNDEFINED	=	0FFH

const SA_ABSOLUTE	=	0
const SA_BYTE 	=	1	//   1
const SA_WORD 	=	2	//   2
const SA_PARA 	=	3	//  16
const SA_PAGE 	=	4	// 256
const SA_DWORD	=	5	//   4
const SA_4K	=	6	// 999

