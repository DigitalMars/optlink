		TITLE	OBJ_MOD - Copyright (c) SLR Systems 1994

		INCLUDE MACROS
		INCLUDE	IO_STRUC
		INCLUDE	SECTS
		INCLUDE	MODULES
		INCLUDE	CDDATA
		INCLUDE	FIXTEMPS
if	fg_td
		INCLUDE	TDBG
endif

		PUBLIC	OBJ_MOD,MODEND_RETURN,DO_DEFINE_MODULE,VERBOSE_MODULENAME
                PUBLIC	LAST_MODULE_GINDEX_EXT

		.DATA

		EXTERNDEF	MODULE_NAME:BYTE,OUTBUF:BYTE,OVR_EXTRN:BYTE,BYTES:BYTE,TEMP_RECORD:BYTE,CACHE_BYTE:BYTE
		EXTERNDEF	MOD_PLTYPE:BYTE,DEBUG_TYPES_SELECTED:BYTE,SYMBOL_TEXT:BYTE

		EXTERNDEF	SYMBOL_LENGTH:DWORD,OVR_EXTRN_TABLE:DWORD,OBJ_DEVICE:DWORD,RECORD_LENGTH:DWORD,SRC_COUNT:DWORD
		EXTERNDEF	END_OF_RECORD:DWORD,FILE_FLAGS:DWORD,SECTION_NUMBER:DWORD,CURNLIB_NUMBER:DWORD,LIB_PAGE_SIZE:DWORD
		EXTERNDEF	TYPDEF_ANDER:DWORD,LINNUM_DELTA:DWORD,EXTDEF_DELTA:DWORD,DEFAULT_SIZE:DWORD,CURNMOD_GINDEX:DWORD
		EXTERNDEF	TD_N_LSCOPES:DWORD,LDATA_SEGMOD_GINDEX:DWORD,MOD_FIRST_PUBLIC_GINDEX:DWORD
		EXTERNDEF	CURN_FILE_LIST_GINDEX:DWORD,XR_CURNMOD_GINDEX:DWORD,LAST_MYCOMDAT_LINDEX:DWORD
		EXTERNDEF	MOD_FIRST_SRC_GINDEX:DWORD,MOD_PREV_CSEGS:DWORD,N_MDB_STRUCTS:DWORD,MOD_CSEG_COUNT:DWORD
		EXTERNDEF	MOD_FIRST_CSEGMOD_GINDEX:DWORD,MOD_TD_LOCALS_INDEX32:DWORD,MOD_TD_LOCALS_COUNT:DWORD
		EXTERNDEF	MOD_TD_COMP_PARAMS:DWORD,TD_OPTIMIZATIONS_FLAG:DWORD,LAST_EXTDEF_GINDEX:DWORD
		EXTERNDEF	LAST_PUBDEF_GINDEX:DWORD,STACK_AREA1:DWORD,MYSTACK:DWORD,MATCHED_COUNT:DWORD,MATCHED_BUFFER:DWORD
		EXTERNDEF	MOD_CV_TYPES_SEGMOD:DWORD,MOD_CV_SYMBOLS_SEGMOD:DWORD,RECORD_TYPE:DWORD,OVR_INIT_ADDR:DWORD
		EXTERNDEF	MOD_SECTION:DWORD,FILE_SECTION:DWORD,VIRDEF_MCD_HASH_TABLE_PTR:DWORD,MOD_TD_OPTFLAGS:DWORD
		EXTERNDEF	MOD_TD_FIRST_LOCAL:DWORD,MATCHED_PTR:DWORD,LAST_TD_MATCHED:DWORD,LOCAL_HASH_TABLE_PTR:DWORD
		EXTERNDEF	MOD_LAST_SRC_GINDEX:DWORD,MDB_STRUCT_SIZE:DWORD,LAST_MDB_GINDEX:DWORD,FIRST_MDB_GINDEX:DWORD

		EXTERNDEF	SYMBOL_LARRAY:LARRAY_STRUCT,GROUP_LARRAY:LARRAY_STRUCT,LNAME_LARRAY:LARRAY_STRUCT
		EXTERNDEF	SEGMOD_LARRAY:LARRAY_STRUCT

		EXTERNDEF	LNAME_STUFF:ALLOCS_STRUCT,MODULE_GARRAY:STD_PTR_S,_FILE_LIST_GARRAY:STD_PTR_S,CSEG_GARRAY:STD_PTR_S
		EXTERNDEF	FILNAM:NFN_STRUCT,PRE_THREADS:THREAD_STUFF_STRUCT,SYMBOL_TPTR:TPTR_STRUCT

		EXTERNDEF	OPTI_MOVE:DWORD
		EXTERNDEF	LAST_MODULE_GINDEX_EXT:DWORD


		.CODE	PASS1_TEXT

		EXTERNDEF	GET_RECORD:PROC,FORREF:PROC,FORREF32:PROC,_check_checksum:proc
		EXTERNDEF	PROCESS_EXTERNALS:PROC,BAD_RECORD:PROC,THEADR:PROC,COMENT:PROC,MODEND:PROC,MODEND32:PROC
		EXTERNDEF	EXTDEF:PROC,RHEADR:PROC,PUBDEF:PROC,PUBDEF32:PROC,LINNUM:PROC,LINNUM32:PROC,LNAMES:PROC,SEGDEF:PROC
		EXTERNDEF	SEGDEF32:PROC,GRPDEF:PROC,FIXUPP:PROC,FIXUPP32:PROC,LEDATA:PROC,LEDATA32:PROC
		EXTERNDEF	LIDATA:PROC,LIDATA32:PROC,COMDEF:PROC,_err_abort:proc,LEXTDF:PROC,LPUBDF:PROC,LPUBDF32:PROC
		EXTERNDEF	RELEASE_ARRAYS:PROC,INIT_ARRAYS:PROC,RIDATA:PROC,RIDATA32:PROC,REDATA32:PROC,REDATA:PROC
		EXTERNDEF	PEDATA:PROC,PEDATA32:PROC,PIDATA:PROC,PIDATA32:PROC,LCOMDF:PROC,INSTALL_MODULE:PROC
		EXTERNDEF	ALLOC_MODULE:PROC,MOVE_ESI_EDI_STG:PROC,MOVE_ASCIZ_ESI_EDI:PROC,FLUSH_OUTBUF:PROC,ALIASS:PROC,CEXTDEF:PROC
		EXTERNDEF	COMDAT:PROC,COMDAT32:PROC,LINSYM:PROC,LINSYM32:PROC,FLUSH_COMDAT:PROC,HEXWOUT:PROC,NBKPAT:PROC
		EXTERNDEF	NBKPAT32:PROC,LLNAMES:PROC,LNAME_INSTALL:PROC
		EXTERNDEF	INIT_LOCAL_STORAGE:PROC,RELEASE_LOCAL_STORAGE:PROC,_move_file_list_gindex_path_prim_ext:proc
		EXTERNDEF	INIT_PARALLEL_ARRAY:PROC,PROCESS_MODEND_TD:PROC,RELEASE_PARALLEL_ARRAY:PROC,SAY_VERBOSE:PROC
		EXTERNDEF	GET_FIRST_RECORD:PROC

		EXTERNDEF	TOO_COMPLEX_ERR:ABS,OVR_EXTRN_COUNT:ABS,CEXTDEF_ERR:ABS

		public _obj_mod
_obj_mod	proc
		push	EBX
		push	ESI
		push	EDI
		call	OBJ_MOD
		pop	EDI
		pop	ESI
		pop	EBX
		ret
_obj_mod	endp

OBJ_MOD		PROC
		;
		;WELL, FIRST WE WILL CLEAR OUT THE THREAD ARRAYS
		;
		CALL	GET_FIRST_RECORD

		MOV	EAX,RECORD_TYPE
		MOV	ECX,RECORD_LENGTH

		CMP	AL,0F0H
		JNZ	OBJ_NORM
		;
		;MUST BE A LIBRARY FILE
		;
		MOV	AL,-1
		ADD	ECX,3

		SETT	LIB_OR_NOT,AL
		MOV	LIB_PAGE_SIZE,ECX	;FOR ROUNDING ADDRESSES...

if	fgh_inthreads
		BITT	_HOST_THREADED
		JNZ	OS_1
endif
		MOV	EAX,OBJ_DEVICE		;ADJUST MAX FILE SIZE TO READ
		MOV	ECX,[ESI]
		MOV	EAX,[EAX].MYI_STRUCT.MYI_FILE_LIST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY

		MOV	[EAX].FILE_LIST_STRUCT.FILE_LIST_NFN.NFN_FILE_LENGTH,ECX
OS_1:

LIB_LOOP	LABEL	PROC

		CALL	GET_RECORD
		CMP	RECORD_TYPE,0F1H
		JZ	LIB_DONE
		CALL	OBJ_NORM		;HANDLE LIKE STANDARD MODULE
		;
		;NOW, ROUND POINTER AND COUNTER
		;
		MOV	EBX,OBJ_DEVICE
		ASSUME	EBX:PTR MYI_STRUCT

		MOV	ECX,LIB_PAGE_SIZE
		MOV	EAX,[EBX].MYI_PTRA
		DEC	ECX
		MOV	EDX,EAX
		ADD	EAX,ECX
		NOT	ECX
		AND	EAX,ECX
		SUB	EAX,EDX
		SUB	[EBX].MYI_COUNT,EAX
		JC	FAIL
		ADD	EAX,EDX
		MOV	[EBX].MYI_PTRA,EAX
		JMP	LIB_LOOP

FAIL		LABEL	PROC

		MOV	[EBX].MYI_COUNT,0 ;UNEXPECTED EOF NEXT
		JMP	LIB_LOOP


LIB_DONE	LABEL	PROC

		XOR	AL,AL
		RESS	REC_TYPE_VALID,AL
		RESS	LIB_OR_NOT,AL
		RET


OBJ_NORM	LABEL	PROC

		MOV	EAX,0FFH
		PUSH	ESI

		RESS	FOUND_THEADR,AH
		GETT	CL,DEBUG_ALL

		SETT	DEBUGGING_THIS,AL
		GETT	CH,FANCY_DEBUG

		MOV	DEBUG_TYPES_SELECTED,AL		;SELECT ALL TYPES TO KEEP
		TEST	CL,CL

		JNZ	L19$

		TEST	CH,CH
		JZ	L19$

		MOV	EAX,CURN_FILE_LIST_GINDEX	;HANDLE DEBUG SELECTION BY FILE
		RESS	DEBUGGING_THIS,CL

if	fg_winpack
		TEST	EAX,EAX
		JZ	L1$
endif
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		MOV	AL,[EAX].FILE_LIST_STRUCT.FILE_LIST_PLINK_FLAGS
		TEST	AL,MASK FL_DEBUG_TYPES+MASK FL_DEBUG_LINNUMS+MASK FL_DEBUG_LOCALS+MASK FL_DEBUG_PUBLICS+MASK FL_DEBUG_COVERAGES+MASK FL_DEBUG_BROWSERDEFS+MASK FL_DEBUG_BROWSERREFS
		JZ	L1$
		SETT	DEBUGGING_THIS,CH
L1$:
		MOV	DEBUG_TYPES_SELECTED,AL
L19$:
		;
		;INITIALIZE FIXUPP THREADS
		;
		MOV	EDI,OFF PRE_THREADS.FS_FILLER
		XOR	EAX,EAX

		MOV	ECX,8
		MOV	LDATA_SEGMOD_GINDEX,EAX
L2$:
		MOV	[EDI],EAX
		ADD	EDI,SIZE THREAD_STUFF_STRUCT

		DEC	ECX
		JNZ	L2$
		;
		;IF ARRAYS HAVE BEEN EXPANDED, RELEASE ANY EXCESS... GO BACK
		;TO SINGLE SEGMENT STUFF
		;
		;
		;INITIALIZE LNAME_STUFF
		;
		CALL	INIT_LOCAL_STORAGE		;DOES INIT_ARRAYS TOO

		XOR	EAX,EAX
		MOV	MOD_FIRST_PUBLIC_GINDEX,EAX
		MOV	TYPDEF_ANDER,EAX 	;IGNORE TYPES...
		MOV	LINNUM_DELTA,EAX
		MOV	EXTDEF_DELTA,EAX
		MOV	LOCAL_HASH_TABLE_PTR,EAX	;NEED TO CLEAR OUT LOCAL HASH TABLE BEFORE USING
		MOV	LAST_MYCOMDAT_LINDEX,EAX
		RESS	ANY_LNAMES,AL
if	fg_td
		MOV	LAST_EXTDEF_GINDEX,EAX
		MOV	LAST_PUBDEF_GINDEX,EAX
		RESS	KEEPING_THIS_TDBG,AL
		MOV	LAST_TD_MATCHED,EAX
		MOV	MATCHED_PTR,OFF MATCHED_BUFFER
		MOV	MATCHED_COUNT,16
endif
		POP	ESI

		RESS	LAST_DATA_KEEP,AL
		BITT	DO_CHECKSUMING
		JNZ	DO_LOOP1
		JMP	DONT_LOOP1

		;start processing records
DO_LOOP:
		SUB	AL,6EH
		CMP	AL,0D0H-6EH
		JNC	DO_FAIL
DO_LOOP2:
		CALL	REC_TABLE[EAX*4]
		CALL	GET_RECORD
DO_LOOP1:
		push	ESI
		call	_check_checksum
		add	ESP,4
		MOV	EAX,RECORD_TYPE
		JMP	DO_LOOP

DO_FAIL:
		MOV	AL,0CFH-6EH	;FORCE BAD_RECORD
		JMP	DO_LOOP2

		;start processing records
DONT_LOOP:
		SUB	AL,6EH
		CMP	AL,0D0H-6EH
		JNC	DONT_FAIL
DONT_LOOP2:
		CALL	REC_TABLE[EAX*4]


;		MOV	EAX,OFF SAY_OMF_RET_MSG
;		CALL	SAY_OMF_VERBOSE

		CALL	GET_RECORD
DONT_LOOP1:
;		CALL	SAY_OMF_TYPE

		MOV	EAX,RECORD_TYPE
		JMP	DONT_LOOP

DONT_FAIL:
		MOV	AL,0CFH-6EH
		JMP	DONT_LOOP2

OBJ_MOD		ENDP


DO_DEFINE_MODULE	PROC
		;
		;build list of modules
		;
		PUSHM	EDI,ESI

		MOV	EAX,DPTR MODULE_NAME
		MOV	ESI,OFF MODULE_NAME+4

		MOV	EDI,OFF SYMBOL_TEXT
		MOV	SYMBOL_LENGTH,EAX

		CALL	OPTI_MOVE
		;
		;FIRST DETERMINE IF THERE ARE ANY FIXUPPS
		;
		MOV	EAX,OFF SYMBOL_TPTR
		CALL	INSTALL_MODULE
		ASSUME	ECX:PTR MODULE_STRUCT

		PUSH	EBX
		MOV	CURNMOD_GINDEX,EAX
if	fg_xref
		MOV	XR_CURNMOD_GINDEX,EAX
endif
		;
		;SEE IF THAT MODULE RECORD ALREADY USED (DUPLICATE MOD NAME..)
		;
		;
		;HANDLE DEBUG BY MODULE NAME
		;
		MOV	AL,[ECX]._M_FLAGS
		MOV	DL,-1

		TEST	AL,MASK M_DEBUG_GLOBAL
		JZ	L1$

		SETT	DEBUGGING_THIS,DL
		MOV	DEBUG_TYPES_SELECTED,DL		;SELECT ALL DEBUGGING TYPES...
L1$:
		OR	AL,MASK M_USED
		MOV	EDX,CURNLIB_NUMBER

		MOV	[ECX]._M_FLAGS,AL
		MOV	EAX,CURN_FILE_LIST_GINDEX

		MOV	[ECX]._M_LIBNUM,EDX
		MOV	[ECX]._M_FILE_LIST_GINDEX,EAX
if	fg_plink
		MOV	EAX,[ECX]._M_SECTION_GINDEX
		MOV	DL,[ECX]._M_PLTYPE
		MOV	MOD_SECTION_GINDEX,EAX
		MOV	MOD_PLTYPE,DL
endif
if	any_overlays
		TEST	FILE_FLAGS,MASK SECT_AUTOSECT
		JZ	L8$
		CALL	CLONE_SECTION
L8$:
endif
		CALL	VERBOSE_MODULENAME

;		CMP	DPTR MODULE_NAME+4,'gniw'
;		JNZ	L2$

;		SETT	VERBOSE_OMF

;L2$:

		;
		;KEEP TYPES IF TYPES ARE SELECTED FOR THIS MODULE, AND WE ARE DOING CODEVIEW INFORMATION
		;
		GETT	CL,CODEVIEW_FLAG
		MOV	AL,DEBUG_TYPES_SELECTED

		OR	CL,CL
		JZ	L5$

		TEST	AL,MASK FL_DEBUG_TYPES
		JZ	L5$
		MOV	TYPDEF_ANDER,-1		;KEEP TYPES NOW...
L5$:

if	fg_td
		BITT	TD_FLAG
		JZ	9$
		BITT	DEBUGGING_THIS
		JZ	9$
		SETT	KEEPING_THIS_TDBG

		LEA	SI,TD_LSCOPE_PARRAY
		MOV	AX,SIZE TD_LSCOPES_STRUCT
		CALL	INIT_PARALLEL_ARRAY

		LEA	SI,TD_LSRC_PARRAY
		MOV	AX,SIZE TD_LSRC_STRUCT
		CALL	INIT_PARALLEL_ARRAY

;		LEA	SI,TD_LTYPES_PARRAY
;		MOV	AX,4
;		CALL	INIT_PARALLEL_ARRAY

;		LEA	SI,TD_LCLASS_PARRAY
;		MOV	AX,4
;		CALL	INIT_PARALLEL_ARRAY

		XOR	AX,AX
		MOV	TD_N_LSCOPES,AX
		MOV	AX,CSEG_GARRAY._STD_LIMIT
		MOV	MOD_PREV_CSEGS,AX
endif

L9$:
		POPM	EBX,ESI,EDI
		RET

DO_DEFINE_MODULE	ENDP


if	any_overlays

CLONE_SECTION	PROC	NEAR
		;
		;NEED ANOTHER SECTION JUST LIKE THIS ONE...
		;
		;
		MOV	AX,SIZE SECTION_STRUCT		;ALLOCATE ANOTHER SECTION
		SYM_POOL_ALLOC	#T
		XCHG	AX,DX
		MOV	BX,DI
		LDS	SI,FILE_SECTION
		SYM_CONV_DS
		MOV	AX,[SI]._SECT_LAST_CLONE.OFFS
		MOV	CX,[SI]._SECT_LAST_CLONE.SEGM
		MOV	[SI]._SECT_LAST_CLONE.OFFS,BX
		MOV	[SI]._SECT_LAST_CLONE.SEGM,DX
		MOV	FILE_SECTION.OFFS,BX
		MOV	FILE_SECTION.SEGM,DX
		JCXZ	1$
		MOV	DS,CX
		XCHG	AX,SI
		SYM_CONV_DS
1$:
		MOV	CX,(SIZE SECTION_STRUCT)/2	;DUPLICATE ENTRIES
		REP	MOVSW
		;
		;CLEAR OUT FIRST_AREA, LAST_AREA, NAME, CHILDREN, FIRST_SEGMOD, LAST_SEGMOD
		;
		LEA	DI,[BX]._SECT_FIRST_AREA
		XOR	AX,AX
		STOSW
		STOSW
		LEA	DI,_SECT_LAST_AREA-(_SECT_FIRST_AREA+4)[DI]
		STOSW
		STOSW
		LEA	DI,_SECT_NAME-(_SECT_LAST_AREA+4)[DI]
		STOSW
		STOSW
		LEA	DI,_SECT_CHILDREN[BX]
		STOSW
		LEA	DI,_SECT_FIRST_SEGMOD[BX]
		STOSW
		STOSW
		LEA	DI,_SECT_LAST_SEGMOD-(_SECT_FIRST_SEGMOD+4)[DI]
		STOSW
		STOSW
		LEA	SI,-SIZE SECTION_STRUCT[SI]
		MOV	[SI]._SECT_NEXT_SECTION.OFFS,BX
		MOV	[SI]._SECT_NEXT_SECTION.SEGM,DX
		MOV	[SI]._SECT_NEXT_SECTION_ORDER.OFFS,BX
		MOV	[SI]._SECT_NEXT_SECTION_ORDER.SEGM,DX
		CMP	ES:[BX]._SECT_NEXT_SECTION.SEGM,0	;NEXT SECTION THIS AREA...
		JNZ	2$
		LDS	SI,[SI]._SECT_PARENT_AREA
		SYM_CONV_DS
		MOV	[SI]._AREA_LAST_SECTION.OFFS,BX
		MOV	[SI]._AREA_LAST_SECTION.SEGM,DX
2$:
		;
		;INC	OUTFILE COUNT
		;
		LDS	SI,ES:[BX]._SECT_OUTFILE
		MOV	CX,DS
		JCXZ	3$
		SYM_CONV_DS
		INC	[SI]._OF_SECTIONS
3$:
		;
		;INC SECTION NUMBERS
		;
		PUSHM	DX,BX
		LDS	SI,ES:[BX]._SECT_PARENT_AREA
4$:
		MOV	CX,DS
		JCXZ	5$
		SYM_CONV_DS
		LDS	SI,[SI]._AREA_PARENT_SECTION
		MOV	CX,DS
		JCXZ	5$
		SYM_CONV_DS
		INC	[SI]._SECT_CHILDREN
		LDS	SI,[SI]._SECT_PARENT_AREA
		JMP	4$

5$:
		;
		;INC SECTION # IN LINKED LIST
		;
		POPM	SI,DS
6$:
		SYM_CONV_DS
		INC	[SI]._SECT_NUMBER
		LDS	SI,[SI]._SECT_NEXT_SECTION_ORDER
		MOV	AX,DS
		OR	AX,AX
		JNZ	6$
		INC	SECTION_NUMBER
		RET

CLONE_SECTION	ENDP

endif


VERBOSE_MODULENAME	PROC
		;
		;
		;
		GETT	AL,INFORMATION_FLAG

		OR	AL,AL
		JZ	L9$

		PUSHM	EDI,ESI

		PUSH	EBX
		MOV	EDI,OFF OUTBUF

		MOV	ESI,OFF READINGMOD_MSG
		CALL	MOVE_ESI_EDI_STG

		MOV	EAX,CURNMOD_GINDEX
		CONVERT	EAX,EAX,MODULE_GARRAY
		ASSUME	EAX:PTR MODULE_STRUCT

		MOV	ECX,[EAX]._M_FILE_LIST_GINDEX
		LEA	ESI,[EAX]._M_TEXT

		PUSH	ECX
		CALL	MOVE_ASCIZ_ESI_EDI	;PHYSICAL

		MOV	ESI,OFF FROMFILE_MSG
		CALL	MOVE_ESI_EDI_STG

		POP	ECX

		TEST	ECX,ECX
		JZ	L2$

		MOV	EAX,EDI

		push	ECX
		push	EAX
		call	_move_file_list_gindex_path_prim_ext
		add	ESP,8

		MOV	EDI,EAX
L2$:
		CALL	FLUSH_OUTBUF
		POPM	EBX,ESI,EDI
L9$:
		RET

VERBOSE_MODULENAME	ENDP


if	any_overlays

DO_OVR_EXTRN_SYMBOL	PROC	NEAR
		;
		;
		;
		PUSH	CX
		LEA	DI,TEMP_RECORD
		LODSW				;PTR TO TEXT STRING
		XCHG	AX,BX			;BX PTS TO TEXT STRING
		LODSB				;AL IS # OF Y/N BYTES TO ADD
		CBW
		XCHG	AX,DX			;DX IS COUNT OF Y/N BYTES
		XCHG	BX,SI			;SI PTS TO STRING LEN, BX PTS TO FIRST Y/N OFFSET
		LODSB
		CBW
		MOV	CX,AX			;CX IS BYTES IN STRING
		ADD	AX,DX			;AL IS TOTAL LENGTH WITH Y/N'S
		STOSB
		REP	MOVSB			;MOVE HEAD OF STRING
		MOV	SI,BX			;SI POINTS TO Y/N OFFSET
		MOV	CX,DX			;CX IS COUNT OF Y/N'S
4$:
		LODSB				;OFFSET OF NEXT Y/N
		LEA	BX,BYTES
		ADD	BX,AX
		MOV	AL,[BX]			;LOAD Y/N
		STOSB
		LOOP	4$
		XOR	AL,AL
		STOSB				;TYP-INDEX
		MOV	END_OF_RECORD,DI
		PUSH	SI
		LEA	SI,TEMP_RECORD
		CALL	EXTDEF
		POPM	SI,CX
		FIXDS
		FIXES
		RET

DO_OVR_EXTRN_SYMBOL	ENDP

endif


if	any_overlays

FIRSTT		PROC
		;
		;
		;

		BITT	DOING_OVERLAYS
		JZ	FIRSTT1
		PUSHM	DI,AX
		;
		;REFERENCE EXTERN...
		;
		FIXDS
		LEA	SI,OVR_EXTRN_TABLE
		CALL	DO_OVR_EXTRN_SYMBOL
		MOV	OVR_INIT_ADDR.OFFS,BX
		MOV	OVR_INIT_ADDR.SEGM,AX
		MOV	CX,OVR_EXTRN_COUNT-1
;		CMP	CACHE_BYTE,'Y'
;		JZ	FIRSTT0
;		DEC	CX
FIRSTT0:
		CALL	DO_OVR_EXTRN_SYMBOL
		LOOP	FIRSTT0

		POPM	AX,DI
FIRSTT1:

		JMP	FIRSTT_RET

FIRSTT		ENDP

endif


MODEND_RETURN	PROC

NO_FIXUPPS	LABEL	PROC
		;
		;OK, END OF MODULE, FIRST WE SCAN LIST OF EXTERNALS AND PROCESS THEM
		;
		GETT	DL,ANY_LNAMES
		XOR	EAX,EAX

		TEST	DL,DL
		JNZ	MR_1

		CMP	MOD_FIRST_PUBLIC_GINDEX,EAX
		JZ	MR_99
MR_1:
		MOV	ESI,CURNMOD_GINDEX
		RESS	LAST_DATA_COMDAT,AL

if	any_overlays
		MOV	BX,LAST_MODULE_GINDEX_EXT
		OR	BX,BX
		JZ	FIRSTT
FIRSTT_RET:
endif
		MOV	LAST_MODULE_GINDEX_EXT,ESI		;BECAUSE PROCESS EXTERNALS MESSES UP CURNMOD_GINDEX
		CONVERT	ESI,ESI,MODULE_GARRAY
		ASSUME	ESI:PTR MODULE_STRUCT

		MOV	EAX,MOD_FIRST_PUBLIC_GINDEX
		MOV	ECX,MOD_FIRST_SRC_GINDEX

		MOV	[ESI]._M_FIRST_PUB_GINDEX,EAX
		MOV	AL,[ESI]._M_FLAGS

		XOR	DL,DL
		TEST	ECX,ECX

		JZ	MR_8

		OR	AL,MASK M_SRCS_PRESENT
MR_8:
		BITT	DEBUGGING_THIS,DL
		JZ	MR_9

		OR	AL,MASK M_DEBUGGING_THIS
MR_9:
		BITT	PCODE_OMIT_PUBLICS,DL
		JZ	MR_91

		OR	AL,MASK M_OMIT_$$PUBLICS
		RESS	PCODE_OMIT_PUBLICS,DL
MR_91:
		BITT	PCH_HERE,DL
		JZ	MR_92

		OR	AL,MASK M_PRECOMPILED_CV
		RESS	PCH_HERE,DL
MR_92:
		MOV	[ESI]._M_FLAGS,AL

if	fg_td
		BITT	TD_FLAG
		JZ	MR_93
		XOR	AX,AX
		XCHG	AX,MOD_TD_COMP_PARAMS
		MOV	[SI]._M_TD_COMP_PARAMS,AX
MR_93:
endif

MR_99:
		RESS	REC_TYPE_VALID,DL

if	fg_td
		CALL	PROCESS_MODEND_TD		;HANDLE TURBO DEBUGGER MODEND STUFF...
endif
;		MOV	EAX,OFF FLUSHING_COMDATS
;		CALL	SAY_OMF_VERBOSE

		CALL	FLUSH_COMDATS

;		MOV	EAX,OFF PROCESSING_EXTERNALS
;		CALL	SAY_OMF_VERBOSE

		CALL	PROCESS_EXTERNALS
if	fg_td
		FIXDS					;SO DS IS VALID AFTER
		LEA	SI,TD_LSRC_PARRAY		;RELEASE
		CALL	RELEASE_PARALLEL_ARRAY

endif

;		MOV	EAX,OFF RELEASING_LOCAL_STORAGE
;		CALL	SAY_OMF_VERBOSE

		CALL	RELEASE_LOCAL_STORAGE

		;
		;ANY REASON TO DO MDB RECORD?
		;
		BITT	NEED_MDB_RECORD
		JZ	MR_10

;		MOV	EAX,OFF PROCESSING_MDB
;		CALL	SAY_OMF_VERBOSE

		CALL	PROCESS_MDB
MR_10:
		XOR	EAX,EAX

		MOV	DEFAULT_SIZE,EAX
		MOV	MOD_FIRST_PUBLIC_GINDEX,EAX

		MOV	MOD_FIRST_SRC_GINDEX,EAX
		MOV	MOD_LAST_SRC_GINDEX,EAX

;		MOV	MOD_SRC_COUNT,EAX
		MOV	MOD_FIRST_CSEGMOD_GINDEX,EAX
		MOV	MOD_CSEG_COUNT,EAX

		MOV	EBX,OBJ_DEVICE
		ASSUME	EBX:PTR MYI_STRUCT
		MOV	CURNMOD_GINDEX,EAX

		BITT	LIB_OR_NOT,AL
		JNZ	MODEND_DONE
		;
		;NORMAL OBJ, ANYTHING LEFT IN THE BUFFER?
		;
CHECK_MORE_RET:
		MOV	ECX,[EBX].MYI_COUNT
		MOV	ESI,[EBX].MYI_PTRA

		TEST	ECX,ECX			;SOMETHING LEFT IN BUFFER, CHECK IT
		JNZ	CHECK_MORE_NOW

		SUB	ESI,[EBX].MYI_BLOCK
		MOV	EAX,EBX

		CMP	ESI,PAGE_SIZE		;PAGE BOUNDARY, TRY ANOTHER READ
		JZ	CHECK_MORE

		RET



CHECK_MORE_NOW:
		CMP	BPTR [ESI],80H	;IS IT A THEADR RECORD?
		JZ	OBJ_MOD1
MODEND_DONE:
		RET

CHECK_MORE:
		push	EAX
		CALL	[EBX].MYI_FILLBUF
		add	ESP,4

		MOV	ECX,[EBX].MYI_COUNT

		TEST	ECX,ECX
		JNZ	CHECK_MORE_RET

		RET

OBJ_MOD1:
		JMP	OBJ_MOD

MODEND_RETURN	ENDP


PROCESS_MDB	PROC	NEAR
		;
		;
		;
		MOV	EAX,MDB_STRUCT_SIZE
		MOV	ESI,LAST_MODULE_GINDEX_EXT

		MOV	ECX,EAX
		TILLP2_POOL_ALLOC

		MOV	EBX,EAX
		ASSUME	EBX:PTR MDB_STRUCT

		INSTALL_POINTER_GINDEX	MDB_GARRAY

		MOV	EDX,LAST_MDB_GINDEX
		MOV	EDI,EBX

		TEST	EDX,EDX
		JZ	DO_FIRST

		CONVERT	EDX,EDX,MDB_GARRAY
		ASSUME	EDX:PTR MDB_STRUCT

		MOV	[EDX]._MD_NEXT_MDB_GINDEX,EAX
DF_9:
		MOV	LAST_MDB_GINDEX,EAX

		SHR	ECX,2
		XOR	EAX,EAX

		REP	STOSD

		RESS	NEED_MDB_RECORD,CL

		MOV	EAX,N_MDB_STRUCTS
		MOV	ECX,ESI

		CONVERT	ESI,ESI,MODULE_GARRAY
		ASSUME	ESI:PTR MODULE_STRUCT

		INC	EAX
		MOV	EDX,LAST_MDB_GINDEX

		MOV	N_MDB_STRUCTS,EAX
		MOV	[ESI]._M_MDB_GINDEX,EDX

		MOV	EAX,MOD_FIRST_SRC_GINDEX
		XOR	EDX,EDX

		MOV	[EBX]._MD_FIRST_SRC_GINDEX,EAX

		TEST	EAX,EAX
		JZ	L2$

		CONVERT	EAX,EAX,SRC_GARRAY
		ASSUME	EAX:PTR SRC_STRUCT

		MOV	EAX,[EAX]._SRC_NUMBER
		MOV	EDX,SRC_COUNT

		SUB	EDX,EAX

		INC	EDX

L2$:
		MOV	[EBX]._MD_SRC_COUNT,EDX

		MOV	EAX,MOD_FIRST_CSEGMOD_GINDEX
		MOV	EDX,MOD_CSEG_COUNT

		MOV	[EBX]._MD_FIRST_CSEGMOD_GINDEX,EAX
		MOV	[EBX]._MD_CSEG_COUNT,EDX
if	fg_cv
		GETT	AL,CODEVIEW_FLAG
		MOV	ECX,MOD_CV_TYPES_SEGMOD

		OR	AL,AL
		JZ	L5$

		MOV	EDX,MOD_CV_SYMBOLS_SEGMOD
		MOV	[EBX]._MD_CV_TYPES_GINDEX,ECX

		XOR	EAX,EAX
		MOV	[EBX]._MD_CV_SYMBOLS_GINDEX,EDX

		MOV	MOD_CV_TYPES_SEGMOD,EAX
		MOV	MOD_CV_SYMBOLS_SEGMOD,EAX
L5$:
endif

if	fg_td
		BITT	TD_FLAG
		JZ	9$
		MOV	[SI]._MD_TD_MOTHER_GINDEX,CX
		MOV	AX,MOD_TD_OPTFLAGS.LW
		MOV	BX,MOD_TD_OPTFLAGS.HW
		MOV	[SI]._MD_TD_OPTFLAGS.LW,AX
		MOV	[SI]._MD_TD_OPTFLAGS.HW,BX
		OR	AX,BX
		OR	AX,TD_OPTIMIZATIONS_FLAG
		MOV	TD_OPTIMIZATIONS_FLAG,AX

		MOV	AX,MOD_TD_LOCALS_INDEX32.LW
		MOV	BX,MOD_TD_LOCALS_INDEX32.HW
		MOV	[SI]._MD_TD_LOCALS_INDEX32.LW,AX
		MOV	[SI]._MD_TD_LOCALS_INDEX32.HW,BX

		MOV	AX,MOD_TD_LOCALS_COUNT
		MOV	[SI]._MD_TD_LOCALS_COUNT,AX

		XOR	AX,AX
		MOV	MOD_TD_OPTFLAGS.LW,AX
		MOV	MOD_TD_OPTFLAGS.HW,AX
		MOV	MOD_TD_LOCALS_INDEX32.LW,AX
		MOV	MOD_TD_LOCALS_INDEX32.HW,AX
		MOV	MOD_TD_LOCALS_COUNT,AX
endif
L9$:
		RET

DO_FIRST:
		MOV	FIRST_MDB_GINDEX,EAX
		JMP	DF_9

PROCESS_MDB	ENDP


FLUSH_COMDATS	PROC	NEAR
		;
		;THIS GUY SCANS LIST OF MYCOMDATS MAKING SURE THEY ARE FLUSHED
		;
		MOV	EAX,LAST_MYCOMDAT_LINDEX

		TEST	EAX,EAX
		JZ	L9$

		PUSHM	EDI,ESI,EBX
		MOV	EBX,EAX
L1$:
		MOV	EAX,EBX
		CONVERT_MYCOMDAT_EAX_ECX
		ASSUME	ECX:PTR MYCOMDAT_STRUCT

		MOV	EDX,[ECX]._MCD_SYMBOL_GINDEX	;CEXTDEF WITH NO DEFINITION?
		MOV	EBX,[ECX]._MCD_NEXT_MCD_LINDEX

		OR	EDX,EDX
		JZ	L5$

		CALL	FLUSH_COMDAT			;EAX IS LINDEX, ECX IS COMDAT PHYSICAL
L6$:
L8$:
		TEST	EBX,EBX
		JNZ	L1$
		;
		;ZERO OUT MCD HASH TABLE
		;
		MOV	EDI,VIRDEF_MCD_HASH_TABLE_PTR
		MOV	ECX,VIRDEF_MCD_HASH_SIZE

		XOR	EAX,EAX
		POP	EBX

		OPTI_STOSD

		POPM	ESI,EDI
L9$:
		RET

L5$:
		MOV	AL,CEXTDEF_ERR
		push	EAX
		call	_err_abort
		JMP	L6$

FLUSH_COMDATS	ENDP


IGNORES		PROC

LOCSYM::

		RET

LOCSYM32::

		RET

TYPDEF::
		MOV	TYPDEF_ANDER,0
	 	RET

BLKDEF:: 	RET

BLKEND:: 	RET

DEBSYM1::	RET

OVLDEF:: 	RET

ENDREC:: 	RET

LIBHED:: 	RET

LIBNAM:: 	RET

LIBLOC:: 	RET

LIBDIC:: 	RET

AC_WHAT::
REGINT:: 	RET

IGNORE_RECORD::
REGINT32::	RET

IGNORES		ENDP

if	debug

SAY_OMF_VERBOSE	PROC

		BITT	VERBOSE_OMF
		JZ	L9$

		CALL	SAY_VERBOSE

L9$:
		RET

SAY_OMF_VERBOSE	ENDP

SAY_OMF_TYPE	PROC

		BITT	VERBOSE_OMF
		JZ	L9$

		PUSH	EDI
		MOV	EAX,RECORD_TYPE

		MOV	EDI,OFF OMF_TYPE_HEX
		CALL	HEXWOUT

		POP	EDI

		MOV	EAX,OFF SAY_OMF_TYP_MSG
		CALL	SAY_VERBOSE

L9$:
		RET

SAY_OMF_TYPE	ENDP
endif

		.CONST


		ALIGN	4

REC_TABLE	DCA	RHEADR			;6E
		DCA	RHEADR			;6F
		DCA	REGINT			;70
		DCA	REGINT32		;71
		DCA	REDATA			;72
		DCA	REDATA32		;73
		DCA	RIDATA			;74
		DCA	RIDATA32		;75
		DCA	OVLDEF			;76
		DCA	BAD_RECORD		;77
		DCA	ENDREC			;78
		DCA	BAD_RECORD		;79
		DCA	BLKDEF			;7A
		DCA	BLKDEF			;7B
		DCA	BLKEND			;7C
		DCA	BAD_RECORD		;7D
		DCA	DEBSYM1 		;7E
		DCA	BAD_RECORD		;7F
		DCA	THEADR			;80
		DCA	BAD_RECORD
		DCA	THEADR			;82 LHEADR
		DCA	THEADR			;83 LHEADR...
;		DCA	PEDATA			;84
;		DCA	PEDATA32		;85
;		DCA	PIDATA			;86
;		DCA	PIDATA32		;87
		DCA	BAD_RECORD		;84
		DCA	BAD_RECORD		;85
		DCA	BAD_RECORD		;86
		DCA	BAD_RECORD		;87
		DCA	COMENT			;88
		DCA	BAD_RECORD		;89
		DCA	MODEND			;8A
		DCA	MODEND32		;8B
		DCA	EXTDEF			;8C
		DCA	EXTDEF			;8D
		DCA	TYPDEF			;8E
		DCA	BAD_RECORD		;8F
		DCA	PUBDEF			;90
		DCA	PUBDEF32		;91
		DCA	LOCSYM			;92
		DCA	LOCSYM32		;93
		DCA	LINNUM			;94
		DCA	LINNUM32		;95
		DCA	LNAMES			;96
		DCA	BAD_RECORD		;97
		DCA	SEGDEF			;98
		DCA	SEGDEF32		;99
		DCA	GRPDEF			;9A
		DCA	BAD_RECORD		;9B
		DCA	FIXUPP			;9C
		DCA	FIXUPP32		;9D
		DCA	2 DUP(BAD_RECORD)
		DCA	LEDATA			;A0
		DCA	LEDATA32		;A1
		DCA	LIDATA			;A2
		DCA	LIDATA32		;A3
		DCA	LIBHED			;A4
		DCA	BAD_RECORD		;A5
		DCA	LIBNAM			;A6
		DCA	BAD_RECORD		;A7
		DCA	LIBLOC			;A8
		DCA	BAD_RECORD		;A9
		DCA	LIBDIC			;AA
		DCA	BAD_RECORD		;AB
		DCA	AC_WHAT 		;AC IGNORE FOR MICROFOCUS
		DCA	3 DUP(BAD_RECORD)
		DCA	COMDEF			;B0
		DCA	BAD_RECORD
		DCA	FORREF			;B2 FORREF
		DCA	FORREF32		;B3
		DCA	LEXTDF			;B4
		DCA	LEXTDF			;B5
		DCA	LPUBDF			;B6
		DCA	LPUBDF32		;B7
		DCA	LCOMDF			;B8
		DCA	BAD_RECORD
		DCA	BAD_RECORD		;BA
		DCA	BAD_RECORD		;BB
		DCA	CEXTDEF			;BC	COMDAT EXTERNAL NAMES
		DCA	BAD_RECORD		;BD
		DCA	BAD_RECORD		;BE
		DCA	BAD_RECORD		;BF
		DCA	BAD_RECORD		;C0
		DCA	BAD_RECORD		;C1
		DCA	COMDAT			;C2
		DCA	COMDAT32		;C3
		DCA	LINSYM			;C4
		DCA	LINSYM32		;C5
		DCA	ALIASS			;C6
		DCA	BAD_RECORD		;C7
		DCA	NBKPAT			;C8
		DCA	NBKPAT32		;C9
		DCA	LLNAMES			;CA
		DCA	BAD_RECORD		;CB
		DCA	IGNORE_RECORD		;CC	VERNUM
		DCA	BAD_RECORD		;CD
		DCA	BAD_RECORD		;CE
		DCA	BAD_RECORD		;CF
		DCA	BAD_RECORD		;D0


READINGMOD_MSG	DB	SIZEOF READINGMOD_MSG-1,'Loading '
FROMFILE_MSG	DB	SIZEOF FROMFILE_MSG-1,' from '

if	debug
SAY_OMF_RET_MSG	DB	SIZEOF SAY_OMF_RET_MSG-1,' Returned',0DH,0AH
FLUSHING_COMDATS	DB	SIZEOF FLUSHING_COMDATS-1,'Flushing COMDATs',0DH,0AH
PROCESSING_EXTERNALS	DB	SIZEOF PROCESSING_EXTERNALS-1,'Processing Externals',0DH,0AH
PROCESSING_MDB		DB	SIZEOF PROCESSING_MDB-1,'Processing MDB',0DH,0AH
RELEASING_LOCAL_STORAGE	DB	SIZEOF RELEASING_LOCAL_STORAGE-1,'Releasing Local Storage',0DH,0AH
endif

		.DATA
if	debug
SAY_OMF_TYP_MSG	DB	SIZEOF SAY_OMF_TYP_MSG-1+4,'Calling RecTyp '
OMF_TYPE_HEX	DB	'XXXX'
endif

		END

