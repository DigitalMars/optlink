		TITLE	PASS1 - Copyright (C) 1994 SLR Systems

		INCLUDE	MACROS
		INCLUDE	IO_STRUC
		INCLUDE	RELEASE
if	fgh_win32
		INCLUDE	WIN32DEF
endif
		INCLUDE	EXES

		PUBLIC	PASS1_STUFF


		.DATA

		EXTERNDEF	MODULE_NAME:BYTE,FILE_PLTYPE:BYTE,FILE_PLINK_FLAGS:BYTE,EXETYPE_FLAG:BYTE

		EXTERNDEF	OBJ_DEVICE:DWORD,IND_DEVICE:DWORD,LIB_THREAD_LOCALS:DWORD,THREAD_LOCALS:DWORD,FILE_FLAGS:DWORD
		EXTERNDEF	FIRST_CLASS_GINDEX:DWORD,CURNMOD_GINDEX:DWORD,CURN_FILE_LIST_GINDEX:DWORD,LOC_11_FIX:DWORD

		EXTERNDEF	OBJ_LIST:FILE_LISTS,OBJPATH_LIST:FILE_LISTS,STUBPATH_LIST:FILE_LISTS,LIBPATH_LIST:FILE_LISTS
		EXTERNDEF	OLD_LIST:FILE_LISTS,STUB_LIST:FILE_LISTS,RC_LIST:FILE_LISTS,LOD_LIST:FILE_LISTS

		EXTERNDEF	SEGMOD_LARRAY:LARRAY_STRUCT,SYMBOL_LARRAY:LARRAY_STRUCT,GROUP_LARRAY:LARRAY_STRUCT
		EXTERNDEF	LNAME_LARRAY:LARRAY_STRUCT

		EXTERNDEF	_FILE_LIST_GARRAY:STD_PTR_S,WINPACK_OBJ_DEVICE:MYI_STRUCT,FILNAM:NFN_STRUCT,MYI_STUFF:MYI_STRUCT
		EXTERNDEF	LIB_REQUEST_ORDER_SEM:GLOBALSEM_STRUCT,GLOBALALLOC_SEM:GLOBALSEM_STRUCT

XSEG		SEGMENT	AT 0

X		MYI_STRUCT	<>

XSEG		ENDS


		.CODE	PASS1_TEXT

		EXTERNDEF	_release_eax:proc
		EXTERNDEF	_release_eax_bump:proc
		EXTERNDEF	SAY_VERBOSE:PROC,OBJ_MOD:PROC,_read_16k_threaded:proc,WARN_NFN_RET:PROC,ERR_NFN_ABORT:PROC
		EXTERNDEF	MOVE_INTERNAL_DI:PROC,SET_LOC_11_RET:PROC,RELEASE_BLOCK:PROC,PROCESS_LIBRARIES:PROC
		EXTERNDEF	_end_of_indirect:proc,CLOSE_LIB_FILES:PROC,DECLARE_OVERLAY_SEGMENTS:PROC
		EXTERNDEF	COM_FLUSH_SEGMOD:PROC,_open_reading:proc,STICK_IN_THREAD_LIST:PROC,CAPTURE_ESBX:PROC
		EXTERNDEF	SET_LOC_11_R:PROC,FORCE_RELEASE_SEGMENT:PROC,RELEASE_EAX:PROC,TIME_ERROR:PROC,SLRLOAD_ENTRY:PROC
		EXTERNDEF	SLRLOAD_BOX_ENTRY:PROC,LOC_11_R:PROC,LOC_11_DONE:PROC,_release_4k_segment:proc,_close_handle:proc
		EXTERNDEF	FORCE_SIGNON:PROC

		EXTERNDEF	EXE_OUT_TABLE:DWORD

		EXTERNDEF	FILE_NOT_FOUND_ERR:ABS


PASS1_STUFF	PROC
		;
		;
		;
		BITT	INFORMATION_FLAG
		JZ	L0$

		CALL	FORCE_SIGNON
L0$:

if	0;fgh_anythreads

		BITT	_HOST_THREADED
		JZ	L1$

		MOV	EAX,OFF MULTITHREAD_MSG
		CALL	SAY_VERBOSE

L1$:
endif

		MOV	EAX,OFF DOING_OBJS_MSG
		CALL	SAY_VERBOSE

if	fg_norm_exe OR fg_segm
		;
		;FIGURE OUT IF WE NEED SPECIAL FARCALL XLATE SUPPORT
		;
		;THIS IS USED TO ESTIMATE DOS OUTPUT HEADER SIZE
		;AND ALSO TO DETERMINE IF PENTS ARE REALLY ACCESSED
		;
		CALL	SET_LOC_11_RET		;ASSUME NOT
		BITT	NOFARCALLTRANSLATION_FLAG;NEVER NEEDED IF NO FARCALLTRANSLATION
		JNZ	L95$
		BITT	FARCALLTRANSLATION_FLAG ;NEVER NEEDED IF NO FARCALLTRANSLATION
		JZ	L95$
		SETT	CHECK_RELOCATIONS	;FORCE RELOCATION-CHECK
if	fg_segm
		BITT	ENTRIES_POSSIBLE	;IF ENTRIES POSSIBLE, WE NEED THIS FOR SURE
		JNZ	L94$
		BITT	OUTPUT_SEGMENTED	;IF SEGMENTED, NEED THIS only IF ENTRIES POSSIBLE
		JNZ	L95$
endif
		BITT	EXEPACK_SELECTED	;REAL MODE, DON'T NEED IF EXEPACKED
		JNZ	L95$
		BITT	EXEPACK_DOSAPP
		JNZ	L95$
if	fg_slrpack
		BITT	SLRPACK_FLAG		;OR IF COMPRESSED
		JNZ	L95$
endif
L94$:
		CALL	SET_LOC_11_R
L95$:

endif
if	fg_winpack
		BITT	WINPACK_SELECTED	;LOADING INTERNAL APPLOADER?
		JZ	L96$
		BITT	WINPACK_LICENSED
		JNZ	L955$
		CALL	SLRLOAD_BOX_ENTRY
		JMP	L956$

L955$:
		CALL	SLRLOAD_ENTRY		;RETURNS EAX IS START OF OBJ, ECX IS LENGTH
L956$:
		MOV	EDX,OFF WINPACK_OBJ_DEVICE
		ASSUME	EDX:PTR MYI_STRUCT

		MOV	OBJ_DEVICE,EDX
		SETT	LIB_OR_NOT
		MOV	[EDX].MYI_PTRA,EAX
		MOV	[EDX].MYI_COUNT,ECX
		CALL	OBJ_MOD
		XOR	EAX,EAX
		RESS	LIB_OR_NOT,AL
		MOV	WINPACK_OBJ_DEVICE.MYI_PTRA,EAX
L96$:
endif
		MOV	EAX,OBJ_LIST.FILE_FIRST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		ASSUME	EAX:PTR FILE_LIST_STRUCT
		MOV	EAX,[EAX].FILE_LIST_NEXT_GINDEX
		ASSUME	EAX:NOTHING
		TEST	EAX,EAX
		JZ	END_OF_OBJS		;NO OBJ FILES...
OBJ_LOOP:
		CONVERT	ESI,EAX,_FILE_LIST_GARRAY
		ASSUME	ESI:PTR FILE_LIST_STRUCT

if	any_overlays
		MOV	AX,[SI].FILE_LIST_SECTION.OFFS
		MOV	FILE_SECTION.OFFS,AX
		MOV	AX,[SI].FILE_LIST_SECTION.SEGM
		MOV	FILE_SECTION.SEGM,AX
		MOV	AL,[SI].FILE_LIST_PLINK_FLAGS
		MOV	FILE_PLINK_FLAGS,AL
		MOV	AL,[SI].FILE_LIST_PLTYPE
		MOV	FILE_PLTYPE,AL
		PUSHM	DS,SI
		LDS	SI,FILE_SECTION
		SYM_CONV_DS
		MOV	AX,WPTR [SI]._SECT_FLAGS
		MOV	FILE_FLAGS,AX			;ALL THIS FOR AUTO_SECTION
		POPM	SI,DS
endif
		;
		;OK, SET UP FOR READING
		;
		MOV	ECX,[ESI].FILE_LIST_NEXT_GINDEX
		PUSH	ECX
		push	EAX
		call	_open_reading		;GO FILL BUFFER
		add	ESP,4
		SETT	DURING_OBJ
		CALL	OBJ_MOD 		;PROCESS FILE

		ASSUME	ESI:NOTHING
if	fgh_inthreads

		BITT	_HOST_THREADED
		JZ	OS_3			;SKIP IF WIN32S
		;
		;need to free up last obj buffer ( and any extra...)
		;
		MOV	EBX,OBJ_DEVICE
		ASSUME	EBX:PTR MYI_STRUCT
OS_15:		
		DEC	[EBX].MYI_BUFCNT
		JZ	OS_2

		MOV	EAX,EBX

		push	EAX
		call	_read_16k_threaded
		add	ESP,4

		JMP	OS_15

OS_2:
		;
		;ok, need to free up open_file entry
		;
		XOR	ECX,ECX
		MOV	EAX,[EBX].MYI_BLOCK

		MOV	[EBX].MYI_BLOCK,ECX
		MOV	[EBX].MYI_PTRA,ECX

		TEST	EAX,EAX
		JZ	L01$

		CALL	RELEASE_BLOCK
L01$:
		MOV	EAX,[EBX].MYI_LOCALS

		ADD	EAX,MYI2_STRUCT.OPENFILE_AVAIL_SEM
		CALL	RELEASE_EAX		;LET HIM OPEN ANOTHER FILE...
OS_3:
endif
		;
		;TRY NEXT...
		;
		POP	EAX
		RESS	DURING_OBJ
		TEST	EAX,EAX
		JNZ	OBJ_LOOP
END_OF_OBJS:
if	fgh_inthreads
		BITT	_HOST_THREADED
		JNZ	OS_4
endif
		;
		;RELEASE INPUT BUFFER
		;
		MOV	EAX,OBJ_DEVICE
		MOV	IND_DEVICE,EAX
		CALL	_end_of_indirect 	;SAME BUFFER & STUFF...
OS_4:

if	any_overlays
		BITT	DOING_OVERLAYS
		JZ	1$
		CALL	DECLARE_OVERLAY_SEGMENTS;SETS UP SEGMENTS FOR VECTORS,
						;SECTIONS, FILENAMES
1$:
endif
		SETT	LIB_OR_NOT		;FOR SEVERAL REASONS...
		MOV	EAX,OFF DOING_LIBS_MSG
		CALL	SAY_VERBOSE
		CALL	PROCESS_LIBRARIES	;READ IN LIBRARY FILES

		RESS	LIB_OR_NOT
LIB_DONE:
		XOR	EAX,EAX

		MOV	CURNMOD_GINDEX,EAX
		MOV	CURN_FILE_LIST_GINDEX,EAX

		SETT	LIBS_DONE		;NO MORE LIBRARY FILE PROCESSING

if	fgh_inthreads
		;
		;FIRST, TERMINATE ANY LIBRARY READER THREADS
		;
TERM_LIB_THREADS	PROC
		;
		;
		;
		PUSH	EBX

		SETT	LIBS_DONE

		BITT	_HOST_THREADED
		JZ	L199$

		MOV	ESI,OFF LIB_THREAD_LOCALS
		MOV	ECX,N_R_THREADS
L1$:
		MOV	EBX,[ESI]
		ADD	ESI,4
		ASSUME	EBX:PTR MYL2_STRUCT

		TEST	EBX,EBX
		JZ	L19$
		;
		;DO WHATEVER IS NEEDED TO BUMP THIS THREAD TO CHECK LIBS_DONE FLAG
		;
		LEA	EAX,[EBX].MYL2_LIB_BLOCK_SEM
		CALL	RELEASE_EAX

		RELEASE	LIB_REQUEST_ORDER_SEM

L19$:
		DEC	ECX
		JNZ	L1$
L199$:
		CALL	CLOSE_LIB_FILES

		BITT	_HOST_THREADED
		JZ	L6$
if	fg_dosx
		CMP	EXETYPE_FLAG,DOSX_EXE_TYPE
		JZ	L25$
endif
if	fg_segm OR fg_pe
		GETT	AL,OUTPUT_SEGMENTED
		GETT	CL,OUTPUT_PE

		OR	AL,CL
		JZ	L4$
		;
		;ADD OLD, STUB, AND RES FILES TO READER LISTS...
		;
		MOV	EAX,OLD_LIST.FILE_FIRST_GINDEX
		CALL	STICK_IN_THREAD_LIST

		MOV	EAX,STUB_LIST.FILE_FIRST_GINDEX
		CALL	STICK_IN_THREAD_LIST

		MOV	EAX,RC_LIST.FILE_FIRST_GINDEX
		CALL	STICK_IN_THREAD_LIST

		JMP	L5$

L4$:
endif
		CALL	TERMINATE_OPREADS
		JMP	L5$
if	fg_dosx
L25$:
		MOV	EAX,LOD_LIST.FILE_FIRST_GINDEX
		CALL	STICK_IN_THREAD_LIST
endif
L5$:
		;
		;WAIT ON LIB_THREAD 'FINISHED' SEMAPHORES
		;
		MOV	ESI,OFF LIB_THREAD_LOCALS
		MOV	EBX,N_R_THREADS
L2$:
		LODSD

		TEST	EAX,EAX
		JZ	L29$

		MOV	EAX,[EAX].MYL2_STRUCT.MYL2_LIBREAD_THREAD_HANDLE

		PUSH	EAX		;XTRA HANDLE
		PUSH	-1		;FOREVER

		PUSH	EAX
		CALL	WaitForSingleObject

		POP	EAX

		push	EAX
		call	_close_handle
		add	ESP,4
L29$:
		DEC	EBX
		JNZ	L2$
		;
		;FINALLY, RELEASE THEIR STACKS...
		;
		MOV	ESI,OFF LIB_THREAD_LOCALS
		MOV	EBX,N_R_THREADS
L3$:
		XOR	ECX,ECX
		MOV	EDI,[ESI]

		MOV	[ESI],ECX
		ADD	ESI,4

		TEST	EDI,EDI
		JZ	L39$

		ASSUME	EDI:PTR MYL2_STRUCT
		MOV	EAX,[EDI].MYL2_LIB_BLOCK_SEM._SEM_ITSELF

		TEST	EAX,EAX
		JZ	L32$

		push	EAX
		call	_close_handle
		add	ESP,4
L32$:
		MOV	EAX,[EDI].MYL2_BLOCK_READ_SEM._SEM_ITSELF

		TEST	EAX,EAX
		JZ	L33$

		push	EAX
		call	_close_handle
		add	ESP,4
L33$:
		MOV	EAX,EDI

		push	EDX
		push	ECX
		push	EAX
		call	_release_4k_segment
		add	ESP,4
		pop	ECX
		pop	EDX

		ASSUME	EDI:NOTHING
L39$:
		DEC	EBX
		JNZ	L3$
L6$:
		POP	EBX

TERM_LIB_THREADS	ENDP

		;
		;THAT SHOULD HAVE CAUSED SELF-DESTRUCT
		;
else
		CALL	CLOSE_LIB_FILES		;CLOSE HANDLES, RELEASE MEMORY
endif

		RET

PASS1_STUFF	ENDP

if	fgh_inthreads

		PUBLIC	TERMINATE_OPREADS

TERMINATE_OPREADS	PROC
		;
		;TERMINATE ALL OPREAD THREADS
		;
		PUSHM	ESI,EBX

		MOV	ESI,OFF THREAD_LOCALS
		MOV	ECX,N_R_THREADS

		SETT	OPREADS_DONE
L1$:
		LODSD

		TEST	EAX,EAX
		JZ	L19$
		;
		;DO WHATEVER IS NEEDED TO BUMP THIS THREAD TO CHECK LIBS_DONE FLAG
		;
		MOV	EBX,EAX
		ASSUME	EBX:PTR MYI2_STRUCT
		ADD	EAX,MYI2_STRUCT.MYI2_FILENAME_LIST_SEM	;LET HIM GO

		CALL	RELEASE_EAX

		LEA	EAX,[EBX].OPENFILE_AVAIL_SEM
		CALL	RELEASE_EAX

		LEA	EAX,[EBX].INS_AVAIL_SEM
		CALL	RELEASE_EAX

		BITT	_FINAL_ABORTING
		JZ	L19$

		RELEASE	GLOBALALLOC_SEM		;JUST IN CASE

L19$:
		DEC	ECX
		JNZ	L1$
		;
		;NOW WAIT FOR TERMINATION & RELEASE LOCALS
		;
		MOV	ESI,OFF THREAD_LOCALS
		MOV	ECX,N_R_THREADS
L2$:
		LODSD

		TEST	EAX,EAX
		JZ	L29$

		PUSH	ECX
		XOR	EDX,EDX

		MOV	EBX,EAX			;SAVE COPY TO RELEASE
		MOV	[ESI-4],EDX
		ASSUME	EBX:PTR MYI2_STRUCT

		MOV	EAX,[EAX].MYI2_STRUCT.MYI2_OPREAD_THREAD_HANDLE
		PUSH	-1

		PUSH	EAX
		CALL	WaitForSingleObject
		;
		;FOR .DLLs, CLOSE ALL SEMAPHORE HANDLES...
		;
		XOR	ECX,ECX
		MOV	EAX,[EBX].MYI2_OPREAD_THREAD_HANDLE

		MOV	[EBX].MYI2_OPREAD_THREAD_HANDLE,ECX

		push	EAX
		call	_close_handle
		add	ESP,4

		PUSH	EBX
		LEA	EBX,[EBX].FIRST_MYI2_SEMAPHORE

		MOV	ECX,N_MYI2_SEMAPHORES

		ASSUME	EBX:PTR GLOBALSEM_STRUCT

L24$:
		XOR	EDX,EDX
		MOV	EAX,[EBX]._SEM_ITSELF

		TEST	EAX,EAX
		JZ	L25$

		PUSH	ECX
		MOV	[EBX]._SEM_ITSELF,EDX

		push	EAX
		call	_close_handle
		add	ESP,4

		POP	ECX
L25$:
		ADD	EBX,SIZE GLOBALSEM_STRUCT

		DEC	ECX
		JNZ	L24$

		POP	EBX

		MOV	EAX,EBX

		push	EDX
		push	ECX
		push	EAX
		call	_release_4k_segment
		add	ESP,4
		pop	ECX
		pop	EDX

		POP	ECX
L29$:
		DEC	ECX
		JNZ	L2$

		POPM	EBX,ESI

		RET

TERMINATE_OPREADS	ENDP

endif


SET_LOC_11_R	PROC

		MOV	LOC_11_FIX,OFF LOC_11_R
		RET

SET_LOC_11_R	ENDP


SET_LOC_11_RET	PROC

		MOV	LOC_11_FIX,OFF LOC_11_DONE
		RET

SET_LOC_11_RET	ENDP


		.CONST

if	fg_plink
DOING_OBJS_MSG	DB	SIZEOF DOING_OBJS_MSG-1,'Reading FILE files',0DH,0AH
DOING_LIBS_MSG	DB	SIZEOF DOING_LIBS_MSG-1,'Searching LIBRARY and SEARCH files',0DH,0AH
else
DOING_OBJS_MSG	DB	SIZEOF DOING_OBJS_MSG-1,'Reading OBJ files',0DH,0AH
DOING_LIBS_MSG	DB	SIZEOF DOING_LIBS_MSG-1,'Searching LIBRARY files',0DH,0AH
endif

;MULTITHREAD_MSG	DB	SIZEOF MULTITHREAD_MSG-1,'HOST is MultiThread Enabled',0DH,0AH


		END

