		TITLE	C32MOVES - Copyright (c) SLR Systems, Inc 1994

		INCLUDE MACROS

if	fg_dospack OR fg_winpack

		INCLUDE	SECTS
		INCLUDE	SLR32

		PUBLIC	MOVE_EAX_TO_COMPRESS_OUTPUT,?_KEEP_QUIK_COMPRESSED


		.DATA

		EXTERNDEF	OVL_PANIC_PARAS:DWORD,OVL_DELTA_PARAS:DWORD,OVL_LIMIT:DWORD,NEXT_AVAIL_2:DWORD
		EXTERNDEF	NEXT_AVAIL:DWORD,RELOC_COUNT:DWORD,CURN_OUTFILE_BASE_ADDRESS:DWORD,CURN_SECTION_FILE_ADDRESS:DWORD
		EXTERNDEF	NEW_REPT_ADDR:DWORD,FINAL_HIGH_WATER:DWORD

		EXTERNDEF	EXETABLE:SEQ_STRUCT

SLR_NEXT_BLOCK	EQU	NEXT_AVAIL
SLR_LAST_DI	EQU	NEXT_AVAIL_2

PANIC_LIMIT	EQU	256-16


		.CODE	PASS2_TEXT

		EXTERNDEF	FLUSH_PUTSTUFF:PROC,PUT_0:PROC,PUT_1:PROC,PUTSTUFF_QUIK32:PROC,PUTSTUFF_SMALL_QUIK32:PROC
		EXTERNDEF	STORE_EAXECX_EDX_SEQ:PROC,MOVE_EAX_TO_FINAL_HIGH_WATER:PROC,CONVERT_SUBBX_TO_EAX:PROC
		EXTERNDEF	RELEASE_SEGMENT:PROC,FINAL_HIGH_PARA:PROC,RELEASE_BLOCK:PROC,ZERO_EAX_FINAL_HIGH_WATER:PROC


MOVE_EAX_TO_COMPRESS_OUTPUT	PROC
		;
		;MOVE EAX FOR ECX BYTES TO TEMP COMPRESS OUTPUT STORAGE...
		;
if	fg_dospack AND fg_winpack
		BITT	OUTPUT_SEGMENTED
		JNZ	L3$
endif
if	fg_dospack
		BITT	DOING_FIRST_SECTION
		JNZ	L1$
endif
L3$:
		MOV	EDX,OFF EXETABLE		;STRUCTURE TO USE
		JMP	STORE_EAXECX_EDX_SEQ

if	fg_dospack
L1$:
		JMP	MOVE_EAX_TO_FINAL_HIGH_WATER
endif

MOVE_EAX_TO_COMPRESS_OUTPUT	ENDP


?_KEEP_QUIK_COMPRESSED	PROC	NEAR
		;
		;
		;
if	fg_winpack
		BITT	OUTPUT_SEGMENTED
		JNZ	HANDLE_PANIC_SUPPORT
endif
if	fg_dospack
		BITT	DOING_FIRST_SECTION
		JNZ	9$
0$:
		;
		;1.  See if compressed version is at least a paragraph boundary smaller (2 if >panic_limit bytes)
		;
		MOV	CX,EXETABLE._SEQ_PTR.LW	;NEW SIZE
		MOV	DX,EXETABLE._SEQ_PTR.HW
		ADD	CX,1FH
		ADC	DX,0
		JNZ	1$
		CMP	CX,PANIC_LIMIT
		JBE	2$
1$:
		ADD	CX,16
		ADC	DX,0
2$:
		AND	CL,0F0H
		;
		;DX:CX IS COMPRESSED SIZE PLUS 1 OR 2 PARAGRAPHS, HOW BIG WAS IT ORIGINALLY?
		;
		MOV	BX,NEW_REPT_ADDR.HW
		MOV	AX,NEW_REPT_ADDR.LW	;OLD SIZE
		ADD	AX,0FH
		ADC	BX,0
		AND	AL,0F0H
		;
		;2.  If not smaller, decompress it now and flush it as non-compressed
		;
		SUB	AX,CX
		SBB	BX,DX
		JC	5$			;NEW SIZE LARGER, GO DECOMPRESS IT BACK OUT...
		;
		;3.  If smaller, flush compressed, with panic-para support.
		;
7$:
		JMP	HANDLE_PANIC_SUPPORT

5$:
		JMP	DECOMPRESS_TO_FINAL

endif

L9$:
		RET

?_KEEP_QUIK_COMPRESSED	ENDP


HANDLE_PANIC_SUPPORT	PROC	NEAR
		;
		;COMPRESSED VERSION IS SMALLER, SEE IF WE NEED PANIC SUPPORT
		;
if	fg_dospack AND any_overlays

		MOV	CX,EXETABLE._SEQ_PTR.LW
		MOV	DX,EXETABLE._SEQ_PTR.HW
		ADD	CX,0FH
		ADC	DX,0
		AND	CX,0FFF0H		;DX:CX IS COMPRESSED LENGTH ROUNDED TO PARA
		OR	DX,DX
		JNZ	1$
		CMP	CX,PANIC_LIMIT
		JA	1$
		;
		;256 BYTES OR LESS, ISSUE ONLY PANIC PARAS...
		;
		LEA	BX,EXETABLE._SEQ_TABLE
		CALL	CONVERT_SUBBX_TO_DS
		PUSH	CX
		XOR	SI,SI
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		POP	AX
		MOV	CL,4
		SHR	AX,CL
		MOV	OVL_PANIC_PARAS,AX
		XOR	AX,AX
		MOV	EXETABLE._SEQ_PTR.LW,AX
		XCHG	EXETABLE._SEQ_TABLE,AX
		CALL	RELEASE_BLOCK
		RET

1$:
		;
		;COMPRESSED DATA >256 BYTES SO IT WON'T ALL FIT IN PANIC BUFFER
		;IS ACTUAL DECOMPRESSED SIZE 256 BYTES SMALLER THAN SPACE ALLOWED ?
		;  (THIS IS TYPICALLY THE CASE WITH DATA AREA WITH UNINITIALIZED AT END)
		;
		LDS	SI,CURN_SECTION
		SYM_CONV_DS
		MOV	CX,[SI]._SECT_MAX_ADDRESS.LW	;THESE ALREADY PARA ALIGNED
		MOV	DX,[SI]._SECT_MAX_ADDRESS.HW
		SUB	CX,[SI]._SECT_BASE_ADDRESS.LW
		SBB	DX,[SI]._SECT_BASE_ADDRESS.HW	;SPACE ALLOCATED

		MOV	BX,NEW_REPT_ADDR.HW		;SIZE INITIALIZED
		MOV	AX,NEW_REPT_ADDR.LW
		ADD	AX,0FH
		ADC	BX,0
		AND	AL,0F0H

		SUB	CX,AX
		SBB	DX,BX
		JNZ	2$				;UNINITIALIZED SPACE >=256 SO
		CMP	CX,PANIC_LIMIT			;NO PANIC NEEDED
		JB	3$				;YES, PANIC NEEDED...
2$:
		;
		;OK, JUST PUMP OUT DATA, CALCULATE DELTA
		;
		ADD	CX,AX
		ADC	DX,BX				;DX:CX IS SPACE ALLOCATED

		MOV	AX,EXETABLE._SEQ_PTR.LW
		MOV	BX,EXETABLE._SEQ_PTR.HW
		ADD	AX,0FH
		ADC	BX,0
		AND	AL,0F0H				;SIZE OF COMPRESSED
		SUB	CX,AX
		SBB	DX,BX
		XCHG	AX,CX
		CALL	SHR_DXAX_4			;AX IS NOW # OF PARAS
		MOV	OVL_DELTA_PARAS,AX
endif
		;
		;NOW MOVE DATA
		;
L22$:
if	fg_winpack
		MOV	EDX,EXETABLE._SEQ_PTR
		MOV	EAX,OFF RELOC_COUNT

		ADD	EDX,2
		MOV	ECX,2

		MOV	NEW_REPT_ADDR,EDX
		CALL	MOVE_EAX_TO_FINAL_HIGH_WATER
endif
		SETT	KEEPING_COMPRESSED

		MOV	SLR_NEXT_BLOCK,OFF EXETABLE._SEQ_TABLE

		PUSH	EBX
L23$:
		MOV	ECX,PAGE_SIZE
L3$:
		SUB	EXETABLE._SEQ_PTR,ECX
		JC	L5$

		TEST	ECX,ECX
		JZ	L6$
L2$:
		MOV	EBX,SLR_NEXT_BLOCK
		CALL	CONVERT_SUBBX_TO_EAX

		CALL	MOVE_EAX_TO_FINAL_HIGH_WATER

		XOR	ECX,ECX
		MOV	EAX,[EBX]

		MOV	[EBX],ECX
		ADD	EBX,4

		MOV	SLR_NEXT_BLOCK,EBX
		CALL	RELEASE_SEGMENT

		JMP	L23$

L6$:
		POP	EBX

		RET

L5$:
		ADD	EXETABLE._SEQ_PTR,ECX

		MOV	ECX,EXETABLE._SEQ_PTR
		JMP	L3$


if	fg_dospack AND any_overlays

3$:
		;
		;OK, THIS IS THE MEAT OF THE COMPRESSION FIX
		;SCAN COMPRESSED DATA TILL <=256 BYTES FROM THE END
		;
		;USE SLR_PREV_SEG FOR SOURCE DATA, SLR_NEXT_SEG FOR TARGET DATA
		;
		MOV	DS,SLR_PREV_SEG
		MOV	ES,SLR_NEXT_SEG
		XOR	SI,SI
		MOV	SLR_NEXT_BLOCK,OFF EXETABLE._SEQ_TABLE
		CALL	FILL_OVL_INBUF
		MOV	DI,SLR_LAST_DI
		SUB	DI,PANIC_LIMIT-5
		CALL	OVL_INSERT_PANIC
		RET

endif

HANDLE_PANIC_SUPPORT	ENDP

if	fg_dospack

DECOMPRESS_TO_FINAL	PROC	NEAR
		;
		;DECOMPRESS THIS SECTION TO FINAL, CLEAR 'COMPRESSED' BIT
		;
;		LDS	SI,CURN_SECTION
;		SYM_CONV_DS
;		AND	[SI]._SECT_FLAGS,NOT MASK SECT_SLRPACK
		;
		;USE SLR_PREV_SEG FOR SOURCE DATA, SLR_NEXT_SEG FOR TARGET DATA
		;
		MOV	DS,SLR_PREV_SEG
		MOV	ES,SLR_NEXT_SEG
		XOR	SI,SI
		MOV	SLR_NEXT_BLOCK,OFF EXETABLE._SEQ_TABLE
		CALL	FILL_OVL_INBUF
		XOR	DI,DI
		CALL	OVL_UNQUIK		;PROCESS IT PLEASE

		RET

DECOMPRESS_TO_FINAL	ENDP

endif

if	any_overlays AND fg_dospack

		ASSUME	DS:NOTHING

OVL_INSERT_PANIC	PROC	NEAR
		;
		;SCAN TILL <=254 BYTES FROM END
		;
		PUSH	BP
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DX,0010H		;16 BITS LEFT TO ROTATE
		JMP	1$

25$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	251$

26$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	261$

51$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	511$

52$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	521$

TERM_REAL1:	JMP	TERM_REAL

15$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JNC	2$
0$:
RANGE_DONE:
		;
		;STRAIGHT BYTE
		;
		INC	SI
1$:
		CMP	DI,SI			;TIME TO INSERT PANIC YET ?
		JBE	TERM_REAL1		;GO INSERT PANIC SHIFT
		ADD	BP,BP
		DEC	DX
		JZ	15$
		JC	0$
2$:
		;
		;0
		;
		XOR	CX,CX
		ADD	BP,BP
		DEC	DX
		JZ	25$
251$:
		JC	3$
		;
		;00x	2 OR 3, THESE ARE MOST LIKELY
		;
		XOR	BH,BH
252$:
		INC	CX		;CX = 1
		ADD	BP,BP
		DEC	DX
		JZ	26$
261$:
		ADC	CX,CX		;CX = 2 OR 3
		CMP	CX,2
		JZ	0$
5$:
		;
		;GET HIGH BYTE OF OFFSET
		;
		ADD	BP,BP
		DEC	DX
		JZ	51$
511$:
		JC	6$
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	52$
521$:
		JNC	0$
		;
		;01
		;
		ADD	BP,BP
		DEC	DX
		JZ	56$
561$:
		JNC	RANGE_DONE		;010 IS 1
		;
		;011X  IS 2 OR 3
		;
		MOV	CX,201H
GET_RANGE_CX:
58$:
		ADD	BP,BP
		DEC	DX
		JZ	59$
591$:
		DEC	CL
		JNZ	58$
		JMP	RANGE_DONE

56$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	561$

59$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	591$


3$:
		;
		;1
		;
		INC	CX			;1
		ADD	BP,BP
		DEC	DX
		JZ	31$
311$:
		JNC	252$
		;
		;11
		;
		INC	CX			;2
		ADD	BP,BP
		DEC	DX
		JZ	32$
321$:
		JNC	252$
		;
		;111
		;
		CALL	GET_BIT
		MOV	BX,802H
		JNC	GET_BX			;1110XX	IS 8-11
4$:
		;
		;1111
		;
		CALL	GET_BIT
		MOV	BX,0C03H
		JNC	GET_BX			;11110XXX IS 12-19
		;
		;11111
		;
		LODSB
		MOV	AH,0
		CMP	AL,81H
		XCHG	AX,CX
		JB	5$
;		JNZ	9$
		CALL	TRY_FIX_DOT
		JMP	1$

6$:
		;
		;1
		;
		CALL	GET_BIT
		JC	7$
		;
		;10
		;
		CALL	GET_BIT
		MOV	CX,402H
		JNC	GET_RANGE_CX	;100XX	IS 4-7
		;
		;101XXX IS 8-F
		;
		MOV	CX,803H
		JMP	GET_RANGE_CX

31$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		JMP	311$

7$:
		;
		;11
		;
		CALL	GET_BIT
		MOV	CX,1004H
		JNC	GET_RANGE_CX	;110XXXX IS 10H-1FH
		;
		;111
		;
		CALL	GET_BIT
		MOV	CX,2004H
		JNC	GET_RANGE_CX	;1110XXXX IS 20H-2FH
		;
		;1111
		;
		CALL	GET_BIT
		MOV	CX,3004H
		JNC	GET_RANGE_CX1
		MOV	CX,4006H
GET_RANGE_CX1:
		JMP	GET_RANGE_CX

32$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,10H
		JMP	321$

GET_BX:
		;
		;
		;
8$:
		ADD	BP,BP
		DEC	DX
		JZ	81$
811$:
		DEC	BL
		JNZ	8$
		JMP	5$

81$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,10H
		JMP	811$


TRY_FIX_DOT:
		;
		;MAKE SURE INPUT POINTER AND LIMIT ARE VALID
		;
		SETT	KEEPING_COMPRESSED
		CALL	OVL_INFIX	;UPDATE INPUT BUFFER IF NEEDED
		RESS	KEEPING_COMPRESSED
		;
		;VERIFY LIMIT
		;
		MOV	DI,SLR_LAST_DI
		SUB	DI,PANIC_LIMIT-5
		RET

TERM_REAL:
		;
		;WRITE UP TO HERE TO FILE
		;
		MOV	CX,OVL_LIMIT
		DEC	CX
		DEC	CX
		CMP	CX,SI
		JC	61$
		AND	CX,16K-1	;IF INFIX HAPPENED IN BETWEEN...
61$:
		;
		;WRITE CX BYTES TO FILE
		;
		PUSHM	SI,BP,DX,CX,SI,DS
		XOR	SI,SI
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		;
		;MOVE REST OF DATA TO HUF_MINI_BUFFER
		;
		POPM	DS,CX,SI
		MOV	ES,SLR_DATA
		MOV	DI,HUF_MINI_BUFFER
		MOV	SLR_CPOS,DI
		SUB	CX,SI
		OPTI_MOVSB
		MOV	SLR_TMP_PTR.OFFS,DI
		;
		;SET SLR_MASK, SLR_WORD
		;
		POP	CX		;# OF BITS STILL TO BE READ FROM (OR STORED INTO...)
		PUSH	CX
		XOR	BX,BX
		MOV	SLR_WORD,BX
		MOV	SLR_MASK,8000H
		DEC	BX
		SHL	BX,CL
		JZ	62$		;16 BITS LEFT, DON'T NEED ANY OF THESE...
		MOV	AX,WPTR ES:HUF_MINI_BUFFER
		AND	AX,BX
		MOV	SLR_WORD,AX
		SUB	CL,16
		NEG	CL
		SHR	SLR_MASK,CL
62$:
		;
		;INSERT PANIC SWITCH, THEN GENERATE REST.
		;
		MOV	AX,83H-THRESHOLD
		CALL	PUTSTUFF_QUIK32
		CALL	FLUSH_PUTSTUFF
		;
		;WRITE STUFF FROM HUF_MINI_BUFFER TO FINAL
		;
		LEA	CX,-2[DI]
		MOV	SI,HUF_MINI_BUFFER
		SUB	CX,SI
		PUSH	ES
		POP	DS
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		CALL	FINAL_HIGH_PARA	;
		;
		;CALCULATE OVL_DELTA
		;
		LDS	SI,CURN_SECTION
		SYM_CONV_DS
		MOV	CX,[SI]._SECT_MAX_ADDRESS.LW	;THESE ALREADY PARA ALIGNED
		MOV	DX,[SI]._SECT_MAX_ADDRESS.HW
		SUB	CX,[SI]._SECT_BASE_ADDRESS.LW
		SBB	DX,[SI]._SECT_BASE_ADDRESS.HW	;SPACE ALLOCATED

		MOV	BX,FINAL_HIGH_WATER.HW		;SIZE WRITTEN
		MOV	AX,FINAL_HIGH_WATER.LW
		SUB	AX,CURN_SECTION_FILE_ADDRESS.LW
		SBB	BX,CURN_SECTION_FILE_ADDRESS.HW
		ADD	AX,CURN_OUTFILE_BASE_ADDRESS.LW
		ADC	BX,CURN_OUTFILE_BASE_ADDRESS.HW
		ADD	AX,0FH
		ADC	BX,0
		AND	AL,0F0H

		SUB	CX,AX
		SBB	DX,BX
		XCHG	AX,CX
		CALL	SHR_DXAX_4
		INC	AX				;DON'T COUNT HEADER PARA
		MOV	OVL_DELTA_PARAS,AX
		;
		;
		;
		;SET UP STUFF FOR NORMAL QUIK-OUTPUT OF PANIC_SWITCH AND REST OF STUFF
		;
		MOV	DS,SLR_PREV_SEG
		MOV	ES,SLR_DATA
		MOV	SLR_TMP_PTR.OFFS,HUF_MINI_BUFFER+2
		MOV	SLR_CPOS,HUF_MINI_BUFFER
		POPM	DX,BP,SI
		JMP	FINISH_PANIC

OVL_INSERT_PANIC	ENDP

GET_BIT		PROC	NEAR
		;
		;
		;
		ADD	BP,BP
		DEC	DX
		JZ	1$
		RET

1$:
		LODSW
		XCHG	AX,BP
		MOV	OVL_LIMIT,SI
		MOV	DL,16
		RET

GET_BIT		ENDP

FINISH_PANIC	PROC	NEAR
		;
		;FLUSH FINAL APPROX 256 BYTES
		;
		JMP	1$

25$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	251$

26$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	261$

51$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	511$

52$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	521$

15$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JNC	2$
0$:
		;
		;STRAIGHT BYTE
		;
		LODSB
		CALL	PANIC_PUTSTUFF_SMALL_QUIK32
1$:
		XOR	CX,CX
		ADD	BP,BP
		DEC	DX
		JZ	15$
		JC	0$
2$:
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	25$
251$:
		JC	3$
		;
		;00x	2 or 3, these are most likely
		;
		XOR	BH,BH
252$:
		INC	CX		;CX = 1
		ADD	BP,BP
		DEC	DX
		JZ	26$
261$:
		ADC	CX,CX		;CX = 2 OR 3
		CMP	CX,2
		JZ	27$
5$:
		;
		;GET HIGH BYTE OF OFFSET
		;
		XOR	BH,BH
		PUSH	CX
		ADD	BP,BP
		DEC	DX
		JZ	51$
511$:
		JC	6$
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	52$
521$:
		JC	55$
		;
		;00 IS 0
		;
#RANGE_DONE:
		POP	CX
27$:
		LODSB				;LOW BYTE OF RANGE
		MOV	BL,AL
;		NOT	BX
		MOV	AX,CX
		ADD	AX,256-THRESHOLD
		CALL	PANIC_PUTSTUFF_QUIK32
		JMP	1$

56$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	561$

55$:
		;
		;01
		;
		INC	BH
		ADD	BP,BP
		DEC	DX
		JZ	56$
561$:
		JNC	#RANGE_DONE		;010 IS 1
		;
		;011X  IS 2 OR 3
		;
		MOV	CX,201H
#GET_RANGE_CX:
		XOR	BH,BH
58$:
		ADD	BP,BP
		DEC	DX
		JZ	59$
591$:
		ADC	BH,BH
		DEC	CL
		JNZ	58$
		ADD	BH,CH
		JMP	#RANGE_DONE

59$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	591$

3$:
		;
		;1
		;
		INC	CX			;1
		ADD	BP,BP
		DEC	DX
		JZ	31$
311$:
		JNC	252$
		;
		;11
		;
		INC	CX			;2
		ADD	BP,BP
		DEC	DX
		JZ	32$
321$:
		JNC	252$
		;
		;111
		;
		CALL	#GET_BIT
		MOV	BX,802H
		JNC	#GET_BX			;1110XX	IS 8-11
4$:
		;
		;1111
		;
		CALL	#GET_BIT
		MOV	BX,0C03H
		JNC	#GET_BX			;11110XXX IS 12-19
		;
		;11111
		;
		LODSB
		MOV	AH,0
		CMP	AL,81H
		XCHG	AX,CX
		JB	5$
		JNZ	9$
		;
		;FIX POINTERS
		;
		PUSHM	DX
		MOV	AX,81H-THRESHOLD
		CALL	PUTSTUFF_QUIK32
		POPM	DX
		XOR	CX,CX
		JMP	1$

6$:
		;
		;1
		;
		CALL	#GET_BIT
		JC	7$
		;
		;10
		;
		CALL	#GET_BIT
		MOV	CX,402H
		JNC	#GET_RANGE_CX	;100XX	IS 4-7
		;
		;101XXX IS 8-F
		;
		MOV	CX,803H
		JMP	#GET_RANGE_CX

31$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	311$

7$:
		;
		;11
		;
		CALL	#GET_BIT
		MOV	CX,1004H
		JNC	#GET_RANGE_CX	;110XXXX IS 10H-1FH
		;
		;111
		;
		CALL	#GET_BIT
		MOV	CX,2004H
		JNC	#GET_RANGE_CX	;1110XXXX IS 20H-2FH
		;
		;1111
		;
		CALL	#GET_BIT
		MOV	CX,3004H
		JNC	#GET_RANGE_CX1
		MOV	CX,4006H
#GET_RANGE_CX1:
		JMP	#GET_RANGE_CX

32$:
		LODSW
		XCHG	AX,BP
		MOV	DL,10H
		JMP	321$

#GET_BX:
		;
		;
		;
		XOR	CX,CX
8$:
		ADD	BP,BP
		DEC	DX
		JZ	81$
811$:
		ADC	CX,CX
		DEC	BL
		JNZ	8$
		ADD	CL,BH
		JMP	5$

81$:
		LODSW
		XCHG	AX,BP
		MOV	DL,10H
		JMP	811$

9$:
		;
		;TA DA...  FLUSH DI BYTES TO FINAL
		;
		MOV	AX,82H-THRESHOLD
		CALL	PUTSTUFF_QUIK32
		;
		;NOW FLUSH LZ_WORD BY WRITING 15 ZEROS
		;
		CALL	FLUSH_PUTSTUFF
		PUSH	ES
		POP	DS
		LEA	CX,-2[DI]
		MOV	SI,HUF_MINI_BUFFER
		SUB	CX,SI
		PUSH	CX
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		POP	AX
		ADD	AX,0FH
		MOV	CL,4
		SHR	AX,CL
		POP	BP
		MOV	OVL_PANIC_PARAS,AX
		RET

#GET_BIT:
		;
		;
		;
		ADD	BP,BP
		DEC	DX
		JZ	#GB1
		RET

#GB1:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		RET

FINISH_PANIC	ENDP

PANIC_PUTSTUFF_SMALL_QUIK32	PROC	NEAR
		;
		;
		;
		CALL	PUTSTUFF_SMALL_QUIK32
		RET

PANIC_PUTSTUFF_SMALL_QUIK32	ENDP

PANIC_PUTSTUFF_QUIK32	PROC	NEAR
		;
		;
		;
		PUSHM	DX
		CALL	PUTSTUFF_QUIK32
		POPM	DX
		RET

PANIC_PUTSTUFF_QUIK32	ENDP

endif

if	fg_dospack

OVL_UNQUIK	PROC	NEAR
		;
		;UNDO COMPRESSED STUFF COMPLETELY
		;
		PUSH	BP
		LODSW
		XCHG	AX,BP
		XOR	CX,CX
		MOV	DX,0010H		;16 BITS LEFT TO ROTATE
		JMP	1$

25$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	251$

26$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	261$

51$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	511$

52$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	521$

15$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JNC	2$
0$:
		;
		;STRAIGHT BYTE
		;
		MOVSB
1$:
		ADD	BP,BP
		DEC	DX
		JZ	15$
		JC	0$
2$:
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	25$
251$:
		JC	3$
		;
		;00x	2 or 3, these are most likely
		;
		XOR	BH,BH
252$:
		INC	CX		;CX = 1
		ADD	BP,BP
		DEC	DX
		JZ	26$
261$:
		ADC	CX,CX		;CX = 2 OR 3
		CMP	CX,2
		JZ	27$
5$:
		;
		;GET HIGH BYTE OF OFFSET
		;
		XOR	BH,BH
		PUSH	CX
		ADD	BP,BP
		DEC	DX
		JZ	51$
511$:
		JC	6$
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	52$
521$:
		JC	55$
		;
		;00 IS 0
		;
531$:
		POP	CX
27$:
		LODSB				;LOW BYTE OF RANGE
		MOV	BL,AL
		NOT	BX
		XCHG	AX,SI			;02
		LEA	SI,[BX+DI]		;03
		CLI				;02
		REP MOVS [DI],ES:BPTR [SI]	;05+04 PER
		STI				;02
		XCHG	SI,AX			;02 =
		JMP	1$

56$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	561$

55$:
		;
		;01
		;
		INC	BH
		ADD	BP,BP
		DEC	DX
		JZ	56$
561$:
		JNC	531$		;010 IS 1
		;
		;011X  IS 2 OR 3
		;
		MOV	CX,201H
#GET_RANGE_CX:
		XOR	BH,BH
58$:
		ADD	BP,BP
		DEC	DX
		JZ	59$
591$:
		ADC	BH,BH
		DEC	CL
		JNZ	58$
		ADD	BH,CH
		JMP	531$

59$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	591$

3$:
		;
		;1
		;
		INC	CX			;1
		ADD	BP,BP
		DEC	DX
		JZ	31$
311$:
		JNC	252$
		;
		;11
		;
		INC	CX			;2
		ADD	BP,BP
		DEC	DX
		JZ	32$
321$:
		JNC	252$
		;
		;111
		;
		CALL	#GET_BIT
		MOV	BX,802H
		JNC	#GET_BX			;1110XX	IS 8-11
4$:
		;
		;1111
		;
		CALL	#GET_BIT
		MOV	BX,0C03H
		JNC	#GET_BX			;11110XXX IS 12-19
		;
		;11111
		;
		LODSB
		MOV	AH,0
		CMP	AL,81H
		XCHG	AX,CX
		JB	5$
		JNZ	9$
		CALL	OVL_FIX_DOT
		XOR	CX,CX
		JMP	1$

6$:
		;
		;1
		;
		CALL	#GET_BIT
		JC	7$
		;
		;10
		;
		CALL	#GET_BIT
		MOV	CX,402H
		JNC	#GET_RANGE_CX	;100XX	IS 4-7
		;
		;101XXX IS 8-F
		;
		MOV	CX,803H
		JMP	#GET_RANGE_CX

31$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	311$

7$:
		;
		;11
		;
		CALL	#GET_BIT
		MOV	CX,1004H
		JNC	#GET_RANGE_CX	;110XXXX IS 10H-1FH
		;
		;111
		;
		CALL	#GET_BIT
		MOV	CX,2004H
		JNC	#GET_RANGE_CX	;1110XXXX IS 20H-2FH
		;
		;1111
		;
		CALL	#GET_BIT
		MOV	CX,3004H
		JNC	#GET_RANGE_CX
		MOV	CX,4006H
		JMP	#GET_RANGE_CX

32$:
		LODSW
		XCHG	AX,BP
		MOV	DL,10H
		JMP	321$

#GET_BX:
		;
		;
		;
		XOR	CX,CX
8$:
		ADD	BP,BP
		DEC	DX
		JZ	81$
811$:
		ADC	CX,CX
		DEC	BL
		JNZ	8$
		ADD	CL,BH
		JMP	5$

81$:
		LODSW
		XCHG	AX,BP
		MOV	DL,10H
		JMP	811$

9$:
		;
		;TA DA...  FLUSH DI BYTES TO FINAL
		;
		PUSH	ES
		POP	DS
		MOV	CX,DI
		XOR	SI,SI
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		POP	BP
		RET

#GET_BIT:
		;
		;
		;
		ADD	BP,BP
		DEC	DX
		JZ	#GB1
		RET

#GB1:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		RET

OVL_UNQUIK	ENDP

OVL_FIX_DOT	PROC	NEAR
		;
		;FIX INPUT AND OUTPUT BUFFERS
		;
		CALL	OVL_INFIX
		CALL	OVL_OUTFIX
		RET

OVL_FIX_DOT	ENDP

OVL_OUTFIX	PROC	NEAR
		;
		;FLUSH TO FINAL IF DI>32K
		;
		CMP	DI,48K
		JB	9$
		PUSHM	DS,SI,ES,DX,CX,BX
		PUSH	ES
		POP	DS
		PUSH	DI
		XOR	SI,SI
		MOV	CX,16K
		PUSH	DS
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		POPM	DS,CX
		XOR	DI,DI
		MOV	SI,16K
		SUB	CX,SI
		OPTI_MOVSB
		POPM	BX,CX,DX,ES,SI,DS
9$:
		RET

OVL_OUTFIX	ENDP

OVL_INFIX	PROC	NEAR
		;
		;
		;
		CMP	SI,32K+32
		JC	9$
		PUSH	BX
		MOV	BX,SLR_NEXT_BLOCK
		CMP	WPTR DGROUP:[BX],0
		POP	BX
		JZ	9$
		CALL	FILL_OVL_INBUF
9$:
		RET

OVL_INFIX	ENDP


FILL_OVL_INBUF	PROC	NEAR	PRIVATE
		;
		;
		;
		PUSHM	ES,DS,DI,DX,CX,BX
		PUSH	DS
		POP	ES
		MOV	DI,SI
		CMP	SI,32K
		JB	1$
		AND	DI,16K-1
		AND	SI,NOT (16K-1)
		BITT	KEEPING_COMPRESSED
		JZ	0$
		PUSHM	DS,SI,ES,DI
		MOV	CX,SI
		XOR	SI,SI
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		POPM	DI,ES,SI,DS
0$:
		PUSH	DI
		XOR	DI,DI
		XOR	CX,CX
		SUB	CX,SI
		OPTI_MOVSB
		POP	SI
L1$:
		PUSH	ESI
L11$:
		;
		;MOVE PAGE_SIZE AT A TIME TILL NO MORE BLOCKS LEFT OR NO BYTES LEFT
		;
		MOV	ECX,PAGE_SIZE
L3$:
		SUB	EXETABLE._SEQ_PTR,ECX
		JC	L5$

		TEST	ECX,ECX
		JZ	L6$
L2$:
		MOV	EBX,SLR_NEXT_BLOCK
		CALL	CONVERT_SUBBX_TO_EAX

		MOV	ESI,EAX
		OPTI_MOVSB

		MOV	[EBX],ECX
		CALL	RELEASE_SEGMENT

		ADD	EBX,4
		OR	DI,DI

		MOV	SLR_NEXT_BLOCK,EBX
		JNZ	11$
6$:
		POP	SI
		MOV	SLR_LAST_DI,DI
		POPM	BX,CX,DX,DI,DS,ES
		RET

L5$:
		ADD	EXETABLE,ECX

		MOV	ECX,EXETABLE
		JMP	L3$

FILL_OVL_INBUF	ENDP

endif

endif

		END

