		TITLE	NEWSECT - Copyright (c) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	SEGMENTS
		INCLUDE	IO_STRUC
		INCLUDE	SECTS
		INCLUDE	SECTIONS
		INCLUDE	EXES
		INCLUDE	WIN32DEF
		INCLUDE	WINMACS

		PUBLIC	EXE_OUT_NEW_SECTION,INIT_NEW_SECTION,SETUP_OUTFILE,HANDLE_PAUSE


		.DATA

		EXTERNDEF	OUTBUF:BYTE,INBUF:BYTE,EXETYPE_FLAG:BYTE,MEMORY_MODEL:BYTE

		EXTERNDEF	_EXE_DEVICE:DWORD,RELOC_CHUNK_COUNT:DWORD,OLD_HIGH_WATER:DWORD,HIGH_WATER:DWORD,EXEHDR_ADDR:DWORD
		EXTERNDEF	OPTI_RELOC_CLEAR:DWORD,OPTI_STOSD_SIZE:DWORD,CURN_OUTFILE_GINDEX:DWORD,EXEPACK_DANGLE_LEN:DWORD
		EXTERNDEF	SEG_PAGE_SIZE_M1:DWORD,DONT_PACK:DWORD,R_DONT_PACK:DWORD,CURN_SECTION_GINDEX:DWORD,FLAG_0C:DWORD
		EXTERNDEF	OBJ_DEVICE:DWORD,CURN_OUTFILE_BASE_ADDRESS:DWORD,FINAL_HIGH_WATER:DWORD,EXE_OUT_POSITION:DWORD
		EXTERNDEF	CURN_SECTION_FILE_ADDRESS:DWORD,DOSX_HDR_SIZE:DWORD,FIXUPP_COUNT:DWORD,FIX2_EXEPACK_BASE:DWORD
		EXTERNDEF	FIRST_SECTION_GINDEX:DWORD

		EXTERNDEF	OUTFILE_GARRAY:STD_PTR_S,SECTION_GARRAY:STD_PTR_S,_FILE_LIST_GARRAY:STD_PTR_S,LOD_LIST:FILE_LISTS
		EXTERNDEF	NEXEHEADER:NEXE,EXEHEADER:EXE


		.CODE	PASS2_TEXT

		EXTERNDEF	MOVE_ESI_EDI_STG:PROC,HEXDWOUTSH:PROC,_move_file_list_gindex_path_prim_ext:proc,FLUSH_OUTBUF:PROC
		EXTERNDEF	_open_output:proc,SET_OUTFILE:PROC,DO_EXE_INIT:PROC,FLUSH_OUTFILE:PROC,CODEVIEW_HERE:PROC
		EXTERNDEF	MESOUT:PROC,_err_abort:proc,SEGM_OUT_INIT:PROC,BUILD_FLUSH_ENTRIES:PROC,INIT_FINAL_RANGES:PROC
		EXTERNDEF	DO_OS2_PAGE_ALIGN:PROC,DO_OS2_PAGE_ALIGN_NO_16:PROC,REOPEN_OUTPUT:PROC,TD_HERE:PROC
		EXTERNDEF	PROCESS_OLD:PROC,PE_OUTPUT_EXPORTS:PROC,PE_INIT_DEBUG:PROC,_open_reading:proc,WARN_RET:PROC
		EXTERNDEF	MOVE_EAX_TO_FINAL_HIGH_WATER:PROC,_get_stdin:PROC,TERMINATE_OPREADS:PROC

		EXTERNDEF	LOD_MISSING_ERR:ABS,BAD_STUB_ERR:ABS,PE_16_ERR:ABS,SEGM_32_ERR:ABS


VERBOSE_SECTIONNAME	PROC	NEAR
		;
		;OUTPUT SECTION NUMBER, NAME, AND WHERE IT IS HEADED
		;
		BITT	INFORMATION_FLAG
		JZ	L9$

		MOV	EDI,OFF OUTBUF
		MOV	ESI,OFF WRITINGSECTION_MSG

		CALL	MOVE_ESI_EDI_STG		;STRING IS IN DATA OR CODE...

		MOV	EAX,CURN_SECTION_GINDEX
		CONVERT	EAX,EAX,SECTION_GARRAY
		ASSUME	EAX:PTR SECTION_STRUCT
if	fg_cv OR fg_td

		TEST	[EAX]._SECT_FLAGS,MASK SECT_CODEVIEW
		JZ	L1$
if	fg_cv
		MOV	ECX,'VC'
		BITT	CODEVIEW_FLAG
		JNZ	L15$
endif
if	fg_td
		MOV	ECX,'DT'
		BITT	TD_FLAG
		JNZ	L15$
endif

L9$:
		RET


L15$:
		MOV	[EDI],ECX
		ADD	EDI,2
		JMP	L2$

L1$:
endif
		MOV	EAX,[EAX]._SECT_NUMBER
		CALL	HEXDWOUTSH
L2$:
		MOV	ESI,OFF INTOFILE_MSG
		CALL	MOVE_ESI_EDI_STG

		MOV	ECX,CURN_OUTFILE_GINDEX
		CONVERT	ECX,ECX,OUTFILE_GARRAY
		ASSUME	ECX:PTR OUTFILE_STRUCT
		MOV	EAX,EDI

		MOV	ECX,[ECX]._OF_FILE_LIST_GINDEX

		push	ECX
		push	EAX
		call	_move_file_list_gindex_path_prim_ext
		add	ESP,8

		JMP	FLUSH_OUTBUF

VERBOSE_SECTIONNAME	ENDP


if	fg_pe
		PUBLIC	PE_OUT_NEW_SECTION

PE_OUT_NEW_SECTION	PROC
		;
		;SOME STARTUP STUFF ALREADY DONE...
		;
;		ALLMSG	'NEW SECTION'

		CALL	INIT_NEW_SECTION
		ASSUME	EAX:PTR SECTION_STRUCT

		CMP	[EAX]._SECT_NUMBER,1
		JZ	L1$
if	fg_cv OR fg_td
		TEST	[EAX]._SECT_FLAGS,MASK SECT_CODEVIEW
		JNZ	L0$
endif
		MOV	AL,0
		push	EAX
		call	_err_abort

if	fg_cv OR fg_td
L0$:
		CALL	PE_INIT_DEBUG
		JMP	INIT_CODEVIEW_SECTION
endif

L1$:
;		ALLMSG	'OUTPUT SECTION 1'

		GETT	CL,ANY_USE32
		MOV	AL,MEMORY_MODEL

		OR	CL,CL
		JZ	L6$

		CMP	AL,MODEL_FLATNT
		JZ	L61$

		OR	AL,AL
		JZ	L61$
L6$:
		MOV	AL,PE_16_ERR
		CALL	WARN_RET

		SETT	MODEL_CONFLICT
L61$:
		;
		;ELSE, LETS GO!
		;
		RET

PE_OUT_NEW_SECTION	ENDP

endif


if	fg_segm
		PUBLIC	SEGM_OUT_NEW_SECTION

SEGM_OUT_NEW_SECTION	PROC
		;
		;NEW SECTION, SEGMENTED OUTPUT
		;
		CALL	HANDLE_PAUSE		;IF FIRST SECTION, MAYBE PAUSE

		;
		;'OLD' PROCESSING?
		;
		MOV	EAX,CURN_SECTION_GINDEX
		MOV	ECX,FIRST_SECTION_GINDEX

		CMP	EAX,ECX
		JNZ	L2$

		BITT	OLD_SUPPLIED		;MUST PROCESS 'OLD' FIRST
		JZ	L2$			;IN CASE IT'S SAME AS NEW .EXE
		CALL	PROCESS_OLD
L2$:
		CALL	SETUP_OUTFILE		;

		CALL	INIT_NEW_SECTION	;
		ASSUME	EAX:PTR SECTION_STRUCT

		CMP	[EAX]._SECT_NUMBER,1
		JZ	L4$
if	fg_cv OR fg_td
		TEST	[EAX]._SECT_FLAGS,MASK SECT_CODEVIEW
		JNZ	L5$
endif
		MOV	AL,0
		push	EAX
		call	_err_abort

L4$:
		JMP	INIT_SEGM_ROOT

if	fg_cv OR fg_td
L5$:
		JMP	INIT_CODEVIEW_SECTION
endif

SEGM_OUT_NEW_SECTION	ENDP


INIT_SEGM_ROOT	PROC
		;
		;
		;
		GETT	CL,ANY_USE32
		MOV	AL,MEMORY_MODEL

		OR	CL,CL
		JNZ	L6$

		CMP	AL,MODEL_FLATNT
		JZ	L6$

		CMP	AL,MODEL_DOSX
		JNZ	L61$
L6$:
		MOV	AL,SEGM_32_ERR
		CALL	WARN_RET

		SETT	MODEL_CONFLICT
L61$:
		CALL	SEGM_OUT_INIT

		CALL	BUILD_FLUSH_ENTRIES

		SETT	EXEPACK_BODY
		BITT	EXEPACK_SELECTED
		JNZ	L4$
		RESS	EXEPACK_BODY
L4$:
if	fg_winpack
		BITT	SEGPACK_SELECTED
		JZ	L5$
		BITT	WINPACK_SELECTED
		JNZ	L5$
		SETT	SEGPACK_SEGMENT		;COMPRESSING WITHOUT APPLOADER
L5$:
endif

		BITT	RC_REORDER
		JZ	L9$
		SETT	RC_PRELOADS
		CALL	DO_OS2_PAGE_ALIGN_NO_16
		RESS	OS2_PAGE_ALIGN_DONE
		MOV	NEXEHEADER._NEXE_GANGSTART,AX
		OR	NEXEHEADER._NEXE_LONGNAMES_FLAG,8
L9$:
		RET

INIT_SEGM_ROOT	ENDP

endif


EXE_OUT_NEW_SECTION	PROC
		;
		;HERE COMES A NEW SECTION.  DETERMINE CORRECT OUTPUT FILE, MAKE SURE POINTERS ARE SET UP
		;
		CALL	HANDLE_PAUSE

		CALL	SETUP_OUTFILE

		;
		;INITIALIZE SOME STUFF
		;
		CALL	INIT_NEW_SECTION
		ASSUME	EAX:PTR SECTION_STRUCT
		;
		;NOW, IT DEPENDS ON IF THIS IS ROOT, OVERLAYS, OR CODEVIEW...
		;
		CMP	[EAX]._SECT_NUMBER,1
		JZ	L4$
if	fg_cv OR fg_td
		TEST	[EAX]._SECT_FLAGS,MASK SECT_CODEVIEW
		JNZ	L5$
endif
if	any_overlays
		JMP	INIT_OVERLAY_SECTION
else
		MOV	AL,0
		push	EAX
		call	_err_abort
endif

if	fg_cv OR fg_td
L5$:
		JMP	INIT_CODEVIEW_SECTION
endif

L4$:
		JMP	INIT_ROOT_SECTION

EXE_OUT_NEW_SECTION	ENDP


INIT_ROOT_SECTION	PROC
		;
		;EXE_OUT_POSITION
		;
		XOR	EAX,EAX
		BITT	OUTPUT_COM_SYS
		JNZ	L50$
		SETT	EXEPACK_BODY
		SETT	CHAINING_RELOCS
		BITT	EXEPACK_SELECTED
		JNZ	L5$

		MOV	EAX,FIXUPP_COUNT
		SHL	EAX,2

		RESS	EXEPACK_BODY
		RESS	CHAINING_RELOCS
L5$:
		ADD	EAX,EXE._EXE_FIRST_RELOC

		MOV	EBX,15
		BITT	ALIGNMENT_SPECIFIED
		JZ	L51$
		MOV	EBX,SEG_PAGE_SIZE_M1	;ALIGNMENT MINUS 1
L51$:
		ADD	EAX,EBX
		NOT	EBX
		AND	EAX,EBX
if	fg_slrpack
		RESS	SLRPACK_FLAG
		BITT	SLRPACK_SELECTED
		JZ	L50$
		SETT	SLRPACK_FLAG
		BITT	EXEPACK_SELECTED	;IF NOT /EXE, PACK RELOCS
		JNZ	L50$
		SETT	PACKING_RELOCS
endif
L50$:
		;
		;OUTPUT DOSX HEADER?
		;
if	fg_dosx
		CMP	EXETYPE_FLAG,DOSX_EXE_TYPE
		JNZ	L55$

		PUSH	EAX
		CALL	OUTPUT_DOSX_STUB	;ADJUSTS DX:AX BY SIZE OF .LOD FILE
if	fgh_inthreads
		CALL	TERMINATE_OPREADS
endif
		POP	EAX
L55$:

endif

		PUSH	EAX
		CALL	DO_EXE_INIT

		POP	EAX

		SHR	EAX,4

		MOV	EXEHEADER._EXE_HDR_SIZE,AX

		BITT	OUTPUT_COM_SYS
		JNZ	L6$

		MOV	EAX,DOSX_HDR_SIZE
		ADD	EAX,EXE._EXE_FIRST_RELOC
		MOV	EXEHDR_ADDR,EAX

L6$:
		MOV	EAX,DONT_PACK
		MOV	R_DONT_PACK,EAX
		RET

INIT_ROOT_SECTION	ENDP


if	any_overlays

INIT_OVERLAY_SECTION	PROC
		;
		;NOT FIRST SECTION.
                ;
		SETT	CHAINING_RELOCS
		RESS	SLRPACK_FLAG
		RESS	PACKING_RELOCS
		BITT	SLRPACK_SELECTED
		JZ	7$
		TEST	[SI]._SECT_FLAGS,MASK SECT_SLRPACK
		JZ	7$
		SETT	SLRPACK_FLAG
		SETT	QUIKPACK_FLAG
;		SETT	PACKING_RELOCS
;		RESS	CHAINING_RELOCS
7$:
		MOV	AX,[SI]._SECT_BASE_ADDRESS.LW	;DON'T ALLOCATE HEADER SPACE IF SECTION EMPTY
		MOV	DX,[SI]._SECT_BASE_ADDRESS.HW
		SUB	AX,[SI]._SECT_MAX_ADDRESS.LW
		SBB	DX,[SI]._SECT_MAX_ADDRESS.HW
		OR	AX,DX
		JZ	6$
		MOV	AX,FINAL_HIGH_WATER.LW
		MOV	DX,FINAL_HIGH_WATER.HW
		MOV	EXEHDR_ADDR.LW,AX
		MOV	EXEHDR_ADDR.HW,DX
		ADD	AX,10H
		ADC	DX,0
		MOV	EXE_OUT_POSITION.LW,AX
		MOV	EXE_OUT_POSITION.HW,DX
		MOV	FINAL_HIGH_WATER.LW,AX
		MOV	FINAL_HIGH_WATER.HW,DX
6$:
		MOV	AX,DONT_PACK
		MOV	R_DONT_PACK,AX
		RET

INIT_OVERLAY_SECTION	ENDP

endif

if	fg_cv OR fg_td

INIT_CODEVIEW_SECTION	PROC
		;
		;HERE COMES CODEVIEW INFORMATION
		;
;		ALLMSG	'CODEVIEW SECTION'
if	fg_cv
		BITT	CODEVIEW_FLAG
		JZ	L1$
		CALL	CODEVIEW_HERE
L1$:
endif
if	fg_td
		BITT	TD_FLAG
		JZ	L2$
		CALL	TD_HERE
L2$:
endif
		RET

INIT_CODEVIEW_SECTION	ENDP

endif

HANDLE_PAUSE	PROC
		;
		;
		;
		MOV	EAX,CURN_SECTION_GINDEX
		MOV	ECX,FIRST_SECTION_GINDEX

		CMP	EAX,ECX
		JNZ	L09$

		BITT	PAUSE_FLAG
		JZ	L09$

		MOV	EAX,OFF PAUSE_MSG
		CALL	MESOUT

if	fgh_win32

		CALL	_get_stdin

		PUSH	EAX			;ALLOCATE PLACE TO STORE RESULT
		MOV	EDX,OFF INBUF

		MOV	ECX,ESP
		PUSH	EDX

		PUSH	0			;OVERLAPPED
		PUSH	ECX			;PLACE TO STORE RESULT

		PUSH	MAX_RECORD_LEN		;# OF CHARS TO READ
		PUSH	EDX			;READ BUFFER

		PUSH	EAX			;HANDLE
		CALL	ReadFile

		POP	ECX
		POP	EAX
else

		MOV	EDX,OFF INBUF
		MOV	INBUF,128
		MOV	AH,0AH
		INT21

		MOV	AH,2
		MOV	DL,0AH
		INT21

endif

L09$:
		RET

HANDLE_PAUSE	ENDP


SETUP_OUTFILE	PROC
		;
		;
		;
		MOV	EAX,CURN_SECTION_GINDEX
		CONVERT	EAX,EAX,SECTION_GARRAY
		ASSUME	EAX:PTR SECTION_STRUCT

		CMP	[EAX]._SECT_OUTFILE_GINDEX,0
		JZ	L11$			;OOPS, ASSIGN OUTPUT FILE
L12$:
		MOV	EAX,[EAX]._SECT_OUTFILE_GINDEX
		CMP	CURN_OUTFILE_GINDEX,EAX
		JZ	L3$
		;
		;OK, SET UP NEW OUTFILE...
		;
		CALL	FLUSH_OUTFILE		;FIRST, FLUSH CURRENTLY SELECTED OUTFILE

		MOV	EAX,CURN_SECTION_GINDEX
		CONVERT	EAX,EAX,SECTION_GARRAY
		ASSUME	EAX:PTR SECTION_STRUCT

		MOV	EAX,[EAX]._SECT_OUTFILE_GINDEX
		MOV	CURN_OUTFILE_GINDEX,EAX
		;
		;IF A NEW FILE, CREATE OUTPUT FILE
		;CLEAR OUT FINAL_RANGES
		;IF FIRST SECTION, SUPPORT PAUSE MODE
		;
		CONVERT	EAX,EAX,OUTFILE_GARRAY
		ASSUME	EAX:PTR OUTFILE_STRUCT

		MOV	ECX,[EAX]._OF_FINAL_HIGH_WATER	;NEW BASE ADDRESS FOR MOVE_TO_FINAL
		MOV	CURN_OUTFILE_BASE_ADDRESS,ECX
		TEST	[EAX]._OF_FLAGS,MASK OF_CREATED	;ALREADY CREATED?
		JNZ	L15$
		OR	[EAX]._OF_FLAGS,MASK OF_CREATED
		MOV	EAX,[EAX]._OF_FILE_LIST_GINDEX
		push	EAX
		CALL	_open_output
		add	ESP,4
		JMP	L16$

L11$:
		CALL	SET_OUTFILE
		JMP	L12$

L15$:
		MOV	EAX,_EXE_DEVICE
if	fgh_outhreads
		BITT	_HOST_THREADED
		JNZ	L16$
endif
		CALL	REOPEN_OUTPUT		;OPEN IF NEEDED
L16$:
		MOV	_EXE_DEVICE,EAX
		;
		;SET UP FINAL_RANGES, ETC BASED ON MAX ADDRESS FOR THAT FILE
		;
		CALL	INIT_FINAL_RANGES
		XOR	EAX,EAX
		MOV	FINAL_HIGH_WATER,EAX
L3$:
		RET

SETUP_OUTFILE	ENDP


INIT_NEW_SECTION	PROC
		;
		;RETURNS EAX == SECTION STRUCT
		;
		CALL	VERBOSE_SECTIONNAME	;TELL THEM ITS HAPPENING...

		MOV	ECX,CURN_SECTION_GINDEX
		CONVERT	ECX,ECX,SECTION_GARRAY
		ASSUME	ECX:PTR SECTION_STRUCT

		MOV	EAX,[ECX]._SECT_RELOCS
		XOR	EDX,EDX

		MOV	FIXUPP_COUNT,EAX
		MOV	EAX,[ECX]._SECT_BASE_ADDRESS

		MOV	RELOC_CHUNK_COUNT,EDX
		MOV	FIX2_EXEPACK_BASE,EAX	 	;USED IN RELOCATION OFFSETS

		MOV	OLD_HIGH_WATER,EAX
		MOV	HIGH_WATER,EAX

		MOV	EAX,CURN_OUTFILE_BASE_ADDRESS
		MOV	EDX,FINAL_HIGH_WATER

		ADD	EAX,EDX
		MOV	EDX,PAGE_SIZE/4

		MOV	CURN_SECTION_FILE_ADDRESS,EAX
		MOV	[ECX]._SECT_FILE_ADDRESS,EAX

		MOV	EAX,64K / 8 / 4
		MOV	OPTI_STOSD_SIZE,EDX		;ASSUME CLEARING 16K BLOCK

		MOV	OPTI_RELOC_CLEAR,EAX		;ASSUME 64K OF RELOC BITS
		MOV	EAX,ECX

		MOV	EXEPACK_DANGLE_LEN,4

		RET

INIT_NEW_SECTION	ENDP


if	fg_dosx

OUTPUT_DOSX_STUB	PROC	NEAR
		;
		;OK, NEED TO COPY A SPECIFIC STUB TO OUTPUT STREAM
		;
		BITT	LOD_SUPPLIED
		JNZ	L1$

		MOV	AL,LOD_MISSING_ERR
		push	EAX
		call	_err_abort

		RET

L11$:
		MOV	AL,BAD_STUB_ERR
		push	EAX
		call	_err_abort
L14$:
		POP	EBX
		RET

L1$:
		MOV	EAX,LOD_LIST.FILE_FIRST_GINDEX
		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		ASSUME	EAX:PTR FILE_LIST_STRUCT

		MOV	EAX,[EAX].FILE_LIST_NEXT_GINDEX
		push	EAX
		call	_open_reading		;GET OPEN STUB FILE...
		add	ESP,4

		PUSH	EBX
		test	EAX,EAX
		stc
		jz	L14$			;NOT FOUND...

		;
		;NOW GET FIRST BLOCK OF DATA...
		;
		ASSUME	EAX:PTR MYI_STRUCT

		MOV	EBX,EAX

		push	EAX
		CALL	[EAX].MYI_FILLBUF
		add	ESP,4

		ASSUME	EBX:PTR MYI_STRUCT

		MOV	ECX,[EBX].MYI_PTRA
		ASSUME	ECX:PTR EXE
		XOR	EAX,EAX
		;
		;DS:SI IS EXEHEADER...
		;
		CMP	[ECX]._EXE_SIGN,'ZM'
		JNZ	L11$		;NOT VALID EXE...
		;
		;SAVE A COPY OF OLD HEADER
		;
		MOV	AX,[ECX]._EXE_LEN_PAGE_512	;CONVERT SIZE INTO FLAT 32-BIT #

		SHL	EAX,9

		CMP	[ECX]._EXE_LEN_MOD_512,0
		JZ	L2$

		SUB	EAX,512
		ADD	AX,[ECX]._EXE_LEN_MOD_512
L2$:
		MOV	DOSX_HDR_SIZE,EAX
		;
		;EAX IS # OF BYTES TO WRITE OUT
		;
		MOV	EDX,ECX
		MOV	ECX,[EBX].MYI_COUNT
		CALL	MOVE_BUNCH
		POP	EBX
		RET

OUTPUT_DOSX_STUB	ENDP


MOVE_BUNCH	PROC	NEAR	PRIVATE
		;
		;EDX IS DATA SOURCE, ECX IS BYTES LEFT THIS BLOCK
		;EAX IS # OF BYTES TO MOVE
		;
		PUSHM	EDI,EBX

		MOV	EBX,EAX
		MOV	EAX,EDX

		JMP	MB_2

MB_1:
		MOV	EAX,OBJ_DEVICE

		push	EAX
		CALL	[EAX].MYI_FILLBUF
		add	ESP,4

		MOV	ECX,[EAX].MYI_COUNT
		MOV	EAX,[EAX].MYI_PTRA

MB_2:
		MOV	EDI,ECX
		CALL	MOVE_EAX_TO_FINAL_HIGH_WATER

		SUB	EBX,EDI
		JNZ	MB_1

		POPM	EBX,EDI
		RET

MOVE_BUNCH	ENDP

endif


		.CONST

WRITINGSECTION_MSG	DB	SIZEOF WRITINGSECTION_MSG-1,'Writing Section '
INTOFILE_MSG	DB	SIZEOF INTOFILE_MSG-1,' Into '
PAUSE_MSG	DB	SIZEOF PAUSE_MSG-1,'About to write output file, change diskette and press ENTER'


		END

