if	fg_rom

HEX_OUT_INIT	PROC
		;
		;
		;
		CALL	COMMON_OUT_INIT ;POSSIBLE PAUSE...
		CALL	BINOUT_INIT
		MOV	_EXE_DEVICE,BX
		RET

HEX_OUT_INIT	ENDP

OMF_OUT_INIT	PROC
		;
		;
		;
		CALL	HEX_OUT_INIT	;JUST LIKE HEX OUTPUT...
		;
		;NEED TO OUTPUT LHEADR RECORD
		;
		;OK, FIRST THING TO SEND IS PROGRAM NAME
		;
		MOV	AL,82H
		CALL	INIT_OMF
		LDS	SI,OMF_NAME
		MOV	CX,DS
		XOR	AL,AL
		STOSB
		JCXZ	5$
		DEC	DI
		SYM_CONV_DS
		LEA	SI,_LNAME_LEN[SI];IN ASCII, FIRST BYTE IS SIZE
		LODSB
		STOSB			;SAVE IT
		XCHG	AX,CX
		INC	SI
		XOR	CH,CH
		REP	MOVSB		;MOVE STRING
5$:
		JMP	FLUSH_OMF

OMF_OUT_INIT	ENDP

INIT_OMF	PROC
		;
		;AL IS OBJ RECORD TYPE
		;
		FIXES
		LEA	DI,OMF_BUFFER	;1024+16
		STOSW			;DOES INC DI TWICE
		INC	DI		;SKIP RECORD LENGTH
		RET

INIT_OMF	ENDP

FLUSH_OMF_LINNUM	PROC
		;
		;FLUSH IF LINNUM RECORD CONTAINS ANYTHING...
		;
		CMP	DI,OFF OMF_BUFFER+7
		JZ	9$
		CALL	FLUSH_OMF
		LEA	DI,OMF_BUFFER+7
9$:
		RET

FLUSH_OMF_LINNUM	ENDP

FLUSH_OMF	PROC
		;
		;
		;
		PUSHM	DS,SI,DX,CX,BX
		FIXDS
		LEA	SI,OMF_BUFFER+2
		MOV	CX,DI
		SUB	CX,SI
		DEC	SI
		MOV	[SI],CX
		DEC	SI
		INC	CX
		INC	CX
		PUSH	CX
		CALL	CHECKSUM
		MOV	[SI],DL
		POP	AX
		SUB	SI,AX
		INC	AX
		CALL	BIN_OUT 	;OUTPUT AX CHARS TO OBJ BUF FM DS:SI
		POPM	BX,CX,DX,SI,DS
		RET

FLUSH_OMF	ENDP

		ASSUME	DS:NOTHING

HEX_OUT_NEW_SEGMENT	PROC
		;
		;WE NEED TO DETERMINE THINGS LIKE IS THIS NOW A DEBUG
		;RECORD?  IS THIS A BUNCH OF 'COMMON' SEGMODS?
		;
		TEST	FIX2_SEG_TYPE,MASK SEG_CV_TYPES+MASK SEG_CV_SYMBOLS
		JNZ	1$
		SETT	HEX_NEW_SEGMENT
		CMP	FIX2_SEG_COMBINE,SC_COMMON
		JNZ	4$

		MOV	AX,FIX2_SEG_LEN.LW
		MOV	BX,FIX2_SEG_LEN.HW
		CALL	NEW_SEGMOD_RELOC

;		MOV	AX,FIX2_SEG_BASE.LW
;		MOV	BX,FIX2_SEG_BASE.HW
;		ADD	AX,FIX2_PHASE_ADDR.LW	;USUALLY ZERO
;		ADC	BX,FIX2_PHASE_ADDR.HW
;		MOV	SEGMOD_DELTA.LW,AX
;		MOV	HIGH_WATER.LW,AX
;		MOV	SEGMOD_DELTA.HW,BX
;		MOV	HIGH_WATER.HW,BX

4$:
		MOV	AX,FIX2_SEG_BASE.LW
		AND	AL,0F0H
		MOV	FIX2_EXEPACK_BASE.LW,AX
		MOV	AX,FIX2_SEG_BASE.HW
		MOV	FIX2_EXEPACK_BASE.HW,AX
		;
		;CHECK FOR OMIT FLAG
		;
		TEST	FIX2_SEG_ORDER_FLAG,MASK DEF_OMITTED
		JNZ	7$
		PUSHM	DS,SI
		LDS	SI,FIX2_SEG_CLASS
		SYM_CONV_DS
		TEST	[SI]._C_ORDER_FLAG,MASK DEF_OMITTED
		POPM	SI,DS
		JNZ	7$
		RET

7$:
		SETT	OMITTING_SEGMENT
		RET
1$:
		CALL	OUT_FLUSH_EXE
if	fg_cv
		SETT	DOING_DEBUG
endif
		MOV	OPTI_STOSD_SIZE,1
		RET

HEX_OUT_NEW_SEGMENT	ENDP

HEX_OUT_NEW_SEGMOD	PROC
		;
		;
		;
		CMP	FIX2_SEG_COMBINE,SC_COMMON
		JZ	9$
		JMP	NEW_SEGMOD_REAL
9$:
		RET

HEX_OUT_NEW_SEGMOD	ENDP

HEX_OUT_SEGMENT_FINISH	PROC
		;
		;IF COMMON, DO WHAT SHOULD HAVE HAPPENED AT SEGMOD_FINISH
		;
		RESS	OMITTING_SEGMENT
		JMP	EXE_OUT_SEGMENT_FINISH

HEX_OUT_SEGMENT_FINISH	ENDP

HEX_OUT_FLUSH_EXE	PROC
		;
		;
		;
		CALL	FLUSH_ERROR_LINENUMBERS
		SETT	OUT_FLUSHED
;		CALL	OUT_FLUSH_SEGMENT

		FIXES
		CMP	MODEND_OWNER.SEGM,0
		LEA	BX,HEXTBL
		JZ	1$
		LEA	DI,HEX_OUTBUF
		MOV	AL,':'
		STOSB
		MOV	AX,'40'
		STOSW
		MOV	AH,'0'
		STOSW
		STOSW
		MOV	AH,'3'
		STOSW
		MOV	DL,7
		MOV	AX,EXEHEADER._EXE_REG_CS
		ADD	DL,AL
		ADD	DL,AH
		CALL	HEXWOUT
		MOV	AX,EXEHEADER._EXE_REG_IP
		ADD	DL,AL
		ADD	DL,AH
		CALL	HEXWOUT
		XCHG	AX,DX
		NEG	AL
		CALL	HEXOUT
		CALL	HLINOUT
1$:
		FIXDS
		LEA	SI,EOF_RECORD
		LEA	DI,HEX_OUTBUF
		MOV	CX,11
		REP	MOVSB
		CALL	HLINOUT
		MOV	BX,_EXE_DEVICE
		CALL	FLUSH_TRUNC_CLOSE
HEX_OUT_FLUSH_FINI:
		;
		;SELECT EXE OUTPUT TYPES...
		;
if	fg_cv
		BITT	CODEVIEW_FLAG
		JZ	9$
		LEA	SI,EXE_OUT_TABLE
		CALL	SELECT_OUTPUT
;		MOV	AX,FIX2_SEG_BASE.LW
;		MOV	HIGH_WATER.LW,AX
;		MOV	HIGH_PC.LW,AX
;		MOV	AX,FIX2_SEG_BASE.HW
;		MOV	HIGH_WATER.HW,AX
;		MOV	HIGH_PC.HW,AX
		JMP	CODEVIEW_SEPARATE_HERE
endif
9$:
		RET

HEX_OUT_FLUSH_EXE	ENDP

		ASSUME	DS:NOTHING

OMF_OUT_FLUSH_EXE	PROC
		;
		;
		;
		CALL	FLUSH_ERROR_LINENUMBERS
		SETT	OUT_FLUSHED
;		CALL	OUT_FLUSH_SEGMENT
		FIXDS
		FIXES
		LEA	SI,FIX2_SEGMENT_STUFF
		LEA	DI,INBUF		;TEMP STORAGE?
		MOV	CX,(SIZE FIX2_TEMPS-REUSABLE_BP)/2
		REP	MOVSW
		BITT	OMF_LINES
		JZ	0$
		CALL	OMF_LINNUMS
0$:
		BITT	OMF_PUBLICS
		JZ	01$
		CALL	OMF_PUBDEFS
01$:
		FIXDS
		FIXES
		LEA	DI,FIX2_SEGMENT_STUFF
		LEA	SI,INBUF		;TEMP STORAGE?
		MOV	CX,(SIZE FIX2_TEMPS-REUSABLE_BP)/2
		REP	MOVSW
		MOV	AL,8AH
		CALL	INIT_OMF
		CMP	MODEND_OWNER.SEGM,0
		JZ	1$
		MOV	AL,0C0H
		STOSB
		MOV	AX,EXEHEADER._EXE_REG_CS
		STOSW
		MOV	AX,EXEHEADER._EXE_REG_IP
		STOSW
2$:
		CALL	FLUSH_OMF
		MOV	BX,_EXE_DEVICE
		CALL	FLUSH_TRUNC_CLOSE
		JMP	HEX_OUT_FLUSH_FINI

1$:
		MOV	AL,0
		STOSB
		JMP	2$

OMF_OUT_FLUSH_EXE	ENDP

HEX_FLUSH_SEGMOD	PROC
		;
		;FLUSH STUFF FROM THIS SEGMOD
		;
		;
		;FIRST SEE IF ANY DATA APPEARED IN THE SEGMOD
		;
		MOV	DI,HIGH_WATER.LW
		MOV	DX,HIGH_WATER.HW
		SUB	DI,FIX2_SM_START.LW
		SBB	DX,FIX2_SM_START.HW
		JC	9$
		MOV	AX,DI
		OR	AX,DX
		JZ	9$			;IT'S AN EMPTY SEGMENT

		CALL	HEX_DATA_FLUSH

9$:
		;
		;EMPTY SEGMOD
		;
		RET

HEX_FLUSH_SEGMOD	ENDP

		ASSUME	DS:NOTHING
HEX_DATA_FLUSH	PROC
		;
		;DS:SI POINTS TO BLOCK OF DATA TO SEND TO EXE FILE
		;CX IS BYTE COUNT
		;RELEASE BLOCK UPON COMPLETION
		;
		PUSHM	DI,DX		;# OF BYTES TO FLUSH
		FIXES
		LEA	BX,HEXTBL
		BITT	HEX_NEW_SEGMENT
		JZ	1$
		RESS	HEX_NEW_SEGMENT
		LEA	DI,HEX_OUTBUF
		MOV	AL,':'
		STOSB
		MOV	AX,'20'
		STOSW
		MOV	AH,'0'
		STOSW
		STOSW
		MOV	AH,'2'
		STOSW
		MOV	DX,FIX2_SEG_BASE.HW
		MOV	AX,FIX2_SEG_BASE.LW
		ADD	AX,FIX2_PHASE_ADDR.LW
		ADC	DX,FIX2_PHASE_ADDR.HW
		CALL	SHR_DXAX_4
		MOV	DL,4
		ADD	DL,AL
		ADD	DL,AH
		CALL	HEXWOUT
		XCHG	AX,DX
		NEG	AL
		CALL	HEXOUT
		CALL	HLINOUT
1$:
		POPM	DX,CX
		XOR	SI,SI
		LEA	BX,EXETABLE
2$:
		CALL	CONVERT_SUBBX_TO_DS
		LEA	DI,HEX_OUTBUF
		MOV	AL,':'
		STOSB
		;
		;USE SMALLER OF DX:CX AND 32
		;
		MOV	AX,32
		OR	DX,DX
		JNZ	3$
		CMP	CX,AX
		JA	3$
		MOV	AX,CX
3$:
		PUSHM	DX,CX,AX,BX
		MOV	CX,AX
		MOV	DL,AL			;START CHECKSUM
		LEA	BX,HEXTBL
		CALL	HEXOUT
		;
		;FIGURE OUT ADDRESS...
		;
		POP	AX			;EXETABLE
		PUSH	AX
		SUB	AX,OFF EXETABLE
		RORI	AX,PAGE_SHIFT+1

		ADD	AX,FIX2_SM_START.LW
		SUB	AX,FIX2_EXEPACK_BASE.LW ;PARAGRAPH BASED
		ADD	AX,SI

		ADD	DL,AL			;CHECKSUM
		ADD	DL,AH
		CALL	HEXWOUT
		MOV	AX,'00'         ;STANDARD DATA RECORD
		STOSW
		;
		;NOW DO CX BYTES
		;
5$:
		LODSB
		ADD	DL,AL
		MOV	AH,AL
		AND	AL,0FH
		XLAT	SS:[BX]
		XCHG	AL,AH
		SHRI	AL,4
		XLAT	SS:[BX]
		STOSW
		LOOP	5$
		;
		;NOW DO CHECKSUM
		;
		XCHG	AX,DX
		NEG	AL
		CALL	HEXOUT
		CALL	HLINOUT

		POPM	BX,AX,CX,DX
		SUB	CX,AX
		SBB	DX,0
		MOV	AX,CX
		OR	AX,DX
		JZ	8$
		CMP	SI,PAGE_SIZE
		JNZ	2$
		XOR	AX,AX
		MOV	SI,AX
		XCHG	AX,SS:[BX]
		CALL	RELEASE_BLOCK
		INC	BX
		INC	BX
		JMP	2$

8$:
		MOV	HIGH_WATER.LW,AX
		MOV	HIGH_WATER.HW,AX
		XCHG	AX,SS:[BX]
		JMP	RELEASE_BLOCK

HEX_DATA_FLUSH	ENDP

OMF_FLUSH_SEGMOD	PROC
		;
		;FLUSH STUFF FROM THIS SEGMOD
		;
		;
		;FIRST SEE IF ANY DATA APPEARED IN THE SEGMOD
		;
		MOV	DI,HIGH_WATER.LW
		MOV	DX,HIGH_WATER.HW
		SUB	DI,FIX2_SM_START.LW
		SBB	DX,FIX2_SM_START.HW
		JC	9$
		MOV	AX,DI
		OR	AX,DX
		JZ	9$			;IT'S AN EMPTY SEGMENT

		CALL	OMF_DATA_FLUSH

9$:
		;
		;EMPTY SEGMOD
		;
		RET

OMF_FLUSH_SEGMOD	ENDP

		ASSUME	DS:NOTHING
OMF_DATA_FLUSH	PROC
		;
		;DS:SI POINTS TO BLOCK OF DATA TO SEND TO EXE FILE
		;CX IS BYTE COUNT
		;RELEASE BLOCK UPON COMPLETION
		;
		MOV	CX,DI
		XOR	SI,SI
		LEA	BX,EXETABLE
1$:
		CALL	CONVERT_SUBBX_TO_DS
		;
		;USE SMALLER OF DX:CX AND 1K
		;
		MOV	AX,1K
		OR	DX,DX
		JNZ	3$
		CMP	CX,AX
		JA	3$
		MOV	AX,CX
3$:
		PUSHM	DX,CX,AX,BX
		MOV	CX,AX

		MOV	AL,84H
		CALL	INIT_OMF
		;
		;FIGURE OUT ADDRESS...
		;
		POP	AX			;EXETABLE
		PUSH	AX
		SUB	AX,OFF EXETABLE
		RORI	AX,PAGE_SHIFT+1
		XOR	DX,DX
		ADD	AX,FIX2_SM_START.LW
		ADC	DX,FIX2_SM_START.HW
		ADD	AX,FIX2_PHASE_ADDR.LW
		ADC	DX,FIX2_PHASE_ADDR.HW
		ADD	AX,SI
		ADC	DX,0

		PUSH	AX
		CALL	SHR_DXAX_4
		STOSW				;FRAME
		POP	AX
		AND	AL,0FH
		STOSB				;OFFSET
		;
		;NOW DO CX BYTES
		;
		OPTI_MOVSB

		CALL	FLUSH_OMF

		POPM	BX,AX,CX,DX
		SUB	CX,AX
		SBB	DX,0
		MOV	AX,CX
		OR	AX,DX
		JZ	8$
		CMP	SI,PAGE_SIZE
		JNZ	1$
		XOR	AX,AX
		MOV	SI,AX
		XCHG	AX,SS:[BX]
		CALL	RELEASE_BLOCK
		INC	BX
		INC	BX
		JMP	1$

8$:
		MOV	HIGH_WATER.LW,AX
		MOV	HIGH_WATER.HW,AX
		XCHG	AX,SS:[BX]
		JMP	RELEASE_BLOCK

OMF_DATA_FLUSH	ENDP

HLINOUT 	PROC
		;
		;
		;
		;ALWAYS RETURNS WITH CARRY CLEAR
		;
		PUSHM	DS,SI,BX
		FIXDS
		MOV	AX,0A0DH
		STOSW
		XCHG	AX,DI
		LEA	SI,HEX_OUTBUF
		SUB	AX,SI
		CALL	BOUTALL 	;OUTPUT THIS...
		POPM	BX,SI,DS
		CLC
		RET

		ASSUME	DS:NOTHING

HLINOUT 	ENDP

endif

if	fg_rom

OMF_LINNUMS	PROC
		;
		;
		;
		ASSUME	DS:NOTHING
		LDS	SI,FIRST_MODULE
		JMP	#TEST_LMOD

#LLIN_LOOP:
		CALL	OMF_LINE_START	;WRITE INDEX, INIT RECORD BUFFER,
					;DX = OFFSET TO ADD, CX = # OF ITEMS,
					;BX = 2 IF 32-BIT, ELSE 0
		JMP	#LINE_LOOP

#LINE_FIX:
		CALL	FLUSH_OMF_LINNUM
		JMP	#LINE_FIX_RET

		EVEN
#LINE_LOOP:
		MOVSW			;LINE #
		LODSW
		ADD	AX,DX
		STOSW			;OFFSET
		ADD	SI,BX		;SKIP HIGH WORD?
		DEC	CX
		JZ	#LINE_DONE
		MOVSW			;LINE #
		LODSW
		ADD	AX,DX
		STOSW			;OFFSET
		ADD	SI,BX		;SKIP HIGH WORD?
		CMP	DI,OFF OMF_BUFFER+1K+7
		JAE	#LINE_FIX
#LINE_FIX_RET:
		LOOP	#LINE_LOOP
#LINE_DONE:

#NEXT_LINE:
		MOV	DS,CV_LIN_PHYS
		DEC	WPTR DS:0
		JNZ	#NY_1
		MOV	AX,DS
		CALL	RELEASE_SEGMENT
#NY_1:
		LDS	SI,CV_LN_NEXT_LINNUM	;
		MOV	AX,DS
		OR	AX,AX
		JNZ	#LLIN_LOOP
		CALL	FLUSH_OMF_LINNUM
#NEXT_LMOD:
		LDS	SI,CV_M_NEXT_MOD
#TEST_LMOD:
		MOV	CX,DS
		JCXZ	#LINES_DONE
		MOV	CURNMOD.OFFS,SI 		;FOR ERROR HANDLING
		MOV	CURNMOD.SEGM,CX
		SYM_CONV_DS
		LEA	DI,CV_MOD_STUFF
		MOV	CX,SIZE MODULE_S/2
		REP	MOVSW
		;
		;NOW, SEE IF ANY LINE NUMBERS THIS MODULE
		;
		CMP	CV_M_FIRST_LIN.SEGM,0
		JZ	#NEXT_LMOD
		TEST	CV_M_FLAGS,MASK M_DEBUGGING_THIS
		JZ	#NEXT_LMOD
		LDS	SI,CV_M_FIRST_LIN
		MOV	CURN_THEADR.SEGM,0		;FORCE 1ST FILE NAME
		LEA	DI,OMF_BUFFER+7 		;EMPTY...
		JMP	#LLIN_LOOP

#LINES_DONE:
		RET

OMF_LINNUMS	ENDP

OMF_LINE_START	PROC
		;
		;DS:SI IS LOGICAL ADDRESS
		;
		;INIT RECORD BUFFER,
		;
		;RETURNS:
		;DX = OFFSET TO ADD, CX = # OF ITEMS,
		;BX = 2 IF 32-BIT, ELSE 0

		PUSH	DI
		CONV_DS
		MOV	CV_LIN_PHYS,DS
		LEA	DI,CV_LN_NEXT_LINNUM
		MOV	CX,SIZE LINNUM_HEADER_TYPE/2
		REP	MOVSW		;NEXT LINE # RECORD...
		;
		;CHECK FOR OVERLAPPED RECORD
		;
		CMP	CV_LN_SECOND_BLK,0
		JZ	2$
		;
		;SPECIAL...
		;
		LEA	DI,CV_TEMP_RECORD
		MOV	CX,PAGE_SIZE
		SUB	CX,SI
		MOV	DX,CX
		OPTI_MOVSB
		DEC	DS:WPTR 0
		JNZ	1$
		MOV	AX,DS
		CALL	RELEASE_SEGMENT
1$:
		MOV	DS,CV_LN_SECOND_BLK
		CONV_DS
		MOV	CV_LIN_PHYS,DS
		MOV	SI,2
		MOV	CX,CV_LN_LENGTH
		SUB	CX,DX
		OPTI_MOVSB
		LEA	SI,CV_TEMP_RECORD
		FIXDS
2$:
		ASSUME	DS:NOTHING
		;
		;CALCULATE # OF LINE #'S IN THIS RECORD
		;
		MOV	AX,CV_LN_LENGTH
		MOV	BX,CV_LN_TYPE		;0 = 16-BIT
		AND	BX,MASK BIT_32
		MOV	CX,4
		JZ	3$
		MOV	BL,2			;MARK 32-BIT TYPE
		MOV	CL,6			;DIVIDE BY 6
3$:
		CWD
		DIV	CX
		XCHG	AX,CX			;CX IS # OF LINE #'S
		POP	DI
		PUSHM	DS,SI
		;
		;SEE IF FILENAME MATCHES PREVIOUS RECORD
		;
		LDS	SI,CV_LN_FILENAME
		ASSUME	DS:NOTHING
		CMP	CURN_THEADR.OFFS,SI	;NEW FILE NAME?
		JNZ	OMF_NEW_THEADR
		MOV	AX,DS
		CMP	CURN_THEADR.SEGM,AX
		JNZ	OMF_NEW_THEADR
		;
		;SAME FILENAME, IS IT SAME SEGMENT AND GROUP?
		;
		PUSH	DI
		CALL	MOVE_CHECK_SINDEX
		POP	DI
		BITT	OMF_NEW_SEGGRP
		JZ	9$
		;
		;WELL, NEED NEW STUFF ANYWAY...
		;
		CALL	FLUSH_OMF_LINNUM
		JMP	#LS_CONT

9$:
		POPM	SI,DS
		MOV	DX,CV_LN_FACTOR ;AMOUNT TO ADD TO EACH OFFSET...
		CMP	AL,AL		;Z SET
		RET

		RET

OMF_NEW_THEADR:
		CALL	FLUSH_OMF_LINNUM	;IF ANY THERE...
		ASSUME	DS:NOTHING
		MOV	CURN_THEADR.OFFS,SI
		MOV	CURN_THEADR.SEGM,DS
		MOV	AL,80H		;THEADR
		CALL	INIT_OMF
		SYM_CONV_DS
		MOV	DX,CX
		LEA	SI,[SI]._LNAME_TEXT
		CALL	MOVE_TEXT_TO_OMF
		CALL	FLUSH_OMF
		MOV	CX,DX
		CALL	MOVE_CHECK_SINDEX
#LS_CONT:
		;
		;NEED TO SET UP STARTING STUFF...
		;
		MOV	AL,94H
		CALL	INIT_OMF
		POPM	SI,DS
		XOR	AX,AX
		STOSW			;GRPINDEX=0, SEGINDEX=0
		MOV	AX,CV_FRAME
		STOSW
		MOV	DX,CV_LN_FACTOR ;AMOUNT TO ADD TO EACH OFFSET...
		CMP	AL,AL		;Z SET
		RET

OMF_LINE_START	ENDP

MOVE_CHECK_SINDEX	PROC
		;
		;
		;
		PUSHM	DX,CX,BX
		RESS	OMF_NEW_SEGGRP
		MOV	AX,CV_LN_GROUP.OFFS
		XCHG	AX,CV_LAST_GROUP.OFFS
		MOV	BX,CV_LN_GROUP.SEGM
		XCHG	BX,CV_LAST_GROUP.SEGM
		CMP	CV_LAST_GROUP.OFFS,AX
		JNZ	1$
		CMP	CV_LAST_GROUP.SEGM,BX
		JZ	2$
1$:
		SETT	OMF_NEW_SEGGRP
2$:
		MOV	AX,CV_LN_SEGMOD.OFFS
		XCHG	AX,CV_LAST_SEGMOD.OFFS
		MOV	BX,CV_LN_SEGMOD.SEGM
		XCHG	BX,CV_LAST_SEGMOD.SEGM
		CMP	CV_LAST_GROUP.SEGM,0
		JNZ	4$		;GROUPED, DON'T CARE IF SEG DIFF..
		CMP	CV_LAST_SEGMOD.OFFS,AX
		JNZ	3$
		CMP	CV_LAST_SEGMOD.SEGM,BX
		JZ	4$
3$:
		SETT	OMF_NEW_SEGGRP
4$:
		;
		;NOW SET CV_LN_FACTOR
		;
		LDS	SI,CV_LN_SEGMOD
		SYM_CONV_DS
		MOV	BX,[SI]._SM_START.LW
		MOV	CX,[SI]._SM_START.HW
		;NEED EITHER SEGMENT OR GROUP BASE
		LDS	SI,[SI]._SM_BASE_SEG
		SYM_CONV_DS
		CMP	CV_LN_GROUP.SEGM,0
		JNZ	#USE_GROUP
		MOV	AX,[SI]._SEG_BASE.LW
		MOV	DX,[SI]._SEG_BASE.HW
#RET:
		AND	AL,0F0H
		SUB	BX,AX
;		SBB	CX,DX
		MOV	CV_LN_FACTOR.LW,BX
;		MOV	WM_FRAME_FACTOR.HW,CX
		CALL	SHR_DXAX_4
		MOV	CV_FRAME,AX
		POPM	BX,CX,DX
		RET

#USE_GROUP:
		LDS	SI,CV_LN_GROUP
		SYM_CONV_DS
		MOV	AX,[SI]._G_FRAME.LW
		MOV	DX,[SI]._G_FRAME.HW
		JMP	#RET

MOVE_CHECK_SINDEX	ENDP

OMF_PUBDEFS	PROC
		ASSUME	DS:NOTHING
		FIXES
		LDS	SI,FIRST_MODULE
		;
		MOV	AL,8EH
		CALL	INIT_OMF
		XOR	AX,AX
		STOSW
		MOV	AL,7BH
		STOSW
		CALL	FLUSH_OMF
		MOV	AL,90H
		CALL	INIT_OMF
		XOR	AX,AX
		STOSW
		STOSW
		MOV	CV_FRAME,AX
		JMP	#TEST_PMOD

#PMOD_LOOP:
		SYM_CONV_DS
		PUSHM	[SI]._M_NEXT_MOD.OFFS,[SI]._M_NEXT_MOD.SEGM
		TEST	[SI]._M_FLAGS,MASK DEBUGGING_THIS
		JZ	#NEXT_MOD
		LDS	BX,[SI]._M_FIRST_PUB
		JMP	#TEST_PPUB

#PPUB_LOOP:
		SYM_CONV_DS
		PUSHM	[BX]._S_NEXT_SYM.OFFS,[BX]._S_NEXT_SYM.SEGM
		CMP	[BX]._S_TYPE,SYM_LOC_RELOCATABLE
		JZ	#NEXT_PPUB
		TEST	[BX]._S_REF_FLAGS,MASK S_SPACES
		JNZ	#NEXT_PPUB
		MOV	AX,[BX]._S_FRAME.LW
		MOV	DX,[BX]._S_FRAME.HW
		CALL	SHR_DXAX_4
		XCHG	AX,DX			;STORE SEGMENT
		CMP	CV_FRAME,DX
		JZ	1$
		CALL	FLUSH_OMF_LINNUM
		MOV	WPTR SS:OMF_BUFFER+5,DX 	;
		MOV	CV_FRAME,DX
1$:
		;
		;FIRST STORE SYMBOL TEXT
		;
		LEA	SI,[BX]._S_NAME_TEXT
		CALL	MOVE_TEXT_TO_OMF

		MOV	AX,[BX]._S_OFFSET.LW
		MOV	CX,[BX]._S_FRAME.LW
		AND	CL,0F0H
		SUB	AX,CX
		STOSW				;OFFSET
		MOV	AL,1			;NUL TYPDEF
		STOSB
		CMP	DI,OFF OMF_BUFFER+1K+7-131
		JNC	#PPUB_FLUSH
#NEXT_PPUB:
		POPM	DS,BX			;NEXT SYMBOL, MODULE ORDER
#TEST_PPUB:
		MOV	AX,DS
		OR	AX,AX
		JNZ	#PPUB_LOOP
#NEXT_MOD:
		POPM	DS,SI
#TEST_PMOD:
		MOV	AX,DS
		OR	AX,AX
		JNZ	#PMOD_LOOP
		CALL	FLUSH_OMF_LINNUM
		RET

#PPUB_FLUSH:
		CALL	FLUSH_OMF_LINNUM
		JMP	#NEXT_PPUB

OMF_PUBDEFS	ENDP

endif

if	fg_rom

		PUBLIC	OMF_TABLE,HEX_TABLE


OMF_TABLE	LABEL	WORD

		DW	OMF_OUT_INIT
		DW	HEX_OUT_NEW_SEGMENT
		DW	HEX_OUT_NEW_SEGMOD
		DW	EXE_OUT_SEGMOD_FINISH
		DW	HEX_OUT_SEGMENT_FINISH
		DW	EXE_OUT_END_OF_SEGMENTS
		DW	OMF_FLUSH_SEGMOD
		DW	EXE_FLUSH_SEGMENT
		DW	OMF_OUT_FLUSH_EXE


HEX_TABLE	LABEL	WORD

		DW	HEX_OUT_INIT
		DW	HEX_OUT_NEW_SEGMENT
		DW	HEX_OUT_NEW_SEGMOD
		DW	EXE_OUT_SEGMOD_FINISH
		DW	HEX_OUT_SEGMENT_FINISH
		DW	EXE_OUT_END_OF_SEGMENTS
		DW	HEX_FLUSH_SEGMOD
		DW	EXE_FLUSH_SEGMENT
		DW	HEX_OUT_FLUSH_EXE

DATA		SEGMENT

EOF_RECORD	DB	':00000001FF'

DATA		ENDS

endif


