		TITLE	HANDCOMP - Copyright (c) SLR Systems 1991

		INCLUDE	MACROS
		INCLUDE	SEGMENTS
		INCLUDE	FIX2TEMP
		INCLUDE	EXES

if	fg_dospack

		PUBLIC	HANDLE_SLRPACK,HANDLE_QUIKPACK,DO_COMPRESS,DOTS_FINISH

		.DATA

	SOFT	EXTW	DONT_PACK

	SOFT	EXTD	NEW_REPT_ADDR,EXEHEADER,FINAL_HIGH_WATER,EXE_OUT_POSITION,HIGH_PC

PACK_SLR	SEGMENT PARA PUBLIC 'UNPACK_DATA'

	SOFT	EXTW	SLR_SKIP_PARAS,SLRPACK_PARAS,FIX_INT21

	SOFT	EXTD	SLR_STACK_ADR,SLR_START_ADR

	SOFT	EXTA	SLR_PACK_LEN,EXP_STRUCT_SIZE

	SOFT	EXTN	SLRUNPACK

PACK_SLR	ENDS

PACK_QUIK	SEGMENT PARA PUBLIC 'UNPACK_DATA'

	SOFT	EXTW	QUIK_SKIP_PARAS,QUIKPACK_PARAS,QUIK_FIX_INT21

	SOFT	EXTD	QUIK_STACK_ADR,QUIK_START_ADR

	SOFT	EXTA	QUIK_PACK_LEN

	SOFT	EXTN	QUIK_UNPACK

PACK_QUIK	ENDS

		.CODE	PASS2_TEXT

	SOFT	EXTP	MOVE_DSSI_TO_FINAL_HIGH_WATER,SHR_DXAX_4,COMPRESS,CALC_EXE_LEN

		ASSUME	DS:NOTHING

HANDLE_SLRPACK	PROC
		;
		;
		;
		MOV	AX,PACK_SLR
		MOV	ES,AX
		ASSUME	ES:PACK_SLR
		FIXDS
		MOV	AX,DONT_PACK
		ADD	AX,0FH
		MOV	CL,4
		SHR	AX,CL
		MOV	SLR_SKIP_PARAS,AX
		MOV	BX,NEW_REPT_ADDR.LW
		MOV	CX,NEW_REPT_ADDR.HW
		MOV	AX,1K+SLR_PACK_LEN
		ADD	AX,EXP_STRUCT_SIZE	;MARGIN OF SAFETY...
		ADD	BX,AX
		ADC	CX,0
		CALL	HANDLE_SUB1		;CALCULATE STACK

		MOV	SLR_STACK_ADR.SEGM,AX
		MOV	SLR_STACK_ADR.OFFS,BX
		LEA	SI,EXEHEADER._EXE_REG_IP
		LEA	DI,SLR_START_ADR
		MOVSW
		MOVSW
		;
		;DO CHUNKS_64K AND CHUNK_PARTIAL
		;
		CALL	CALC_EXE_LEN
;		SUB	AX,DONT_PACK
;		SBB	DX,0
;		MOV	SLR_CHUNKS_64K,DX
;		SHR	AX,1
;		MOV	SLR_CHUNK_PARTIAL,AX
;		ADD	AX,AX
;		ADD	AX,DONT_PACK
;		ADC	DX,0
		MOV	EXEHEADER._EXE_REG_IP,OFF SLRUNPACK
		CALL	SHR_DXAX_4
		MOV	EXEHEADER._EXE_REG_CS,AX
		MOV	SI,DONT_PACK
		ADD	SI,0FH
		MOV	CL,4
		SHR	SI,CL
		SUB	AX,SI
		MOV	SLRPACK_PARAS,AX
		FIXES
		;
		;NOW MOVE PACK_SEGMENT TO FINAL_EXE
		;
		MOV	AX,PACK_SLR
		MOV	DS,AX
		ASSUME	DS:PACK_SLR
		XOR	SI,SI
		MOV	CX,SLR_PACK_LEN
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		ASSUME	DS:DGROUP
		;
		;FINALIZE STUFF IN EXEHEADER
		;
		;STACK GOES AT A PARAGRAPH AT NEW_REPT_ADDR + 256
		;STACK ITSELF IS OFFSET SLR_PACK_LEN+256+SIZE (LZW_??)
		;
		MOV	AX,NEW_REPT_ADDR.LW
		MOV	DX,NEW_REPT_ADDR.HW
		ADD	AX,2K			;MARGIN OF SAFETY...
		ADC	DX,0
		PUSHM	DX,AX
		CALL	SHR_DXAX_4
		MOV	EXEHEADER._EXE_REG_SS,AX
		MOV	CX,SLR_PACK_LEN+15
		AND	CX,0FFF0H
		ADD	CX,256+EXP_STRUCT_SIZE
		MOV	EXEHEADER._EXE_REG_SP,CX
		POPM	AX,DX
		RET

HANDLE_SLRPACK	ENDP

HANDLE_QUIKPACK PROC
		;
		;
		;
		MOV	AX,PACK_QUIK
		MOV	ES,AX
		ASSUME	ES:PACK_QUIK
		FIXDS
		MOV	AX,DONT_PACK
		ADD	AX,0FH
		MOV	CL,4
		SHR	AX,CL
		MOV	QUIK_SKIP_PARAS,AX
		MOV	BX,NEW_REPT_ADDR.LW
		MOV	CX,NEW_REPT_ADDR.HW
		MOV	AX,1K+QUIK_PACK_LEN
		ADD	BX,AX
		ADC	CX,0
		CALL	HANDLE_SUB1		;CALCULATE STACK

		MOV	QUIK_STACK_ADR.SEGM,AX
		MOV	QUIK_STACK_ADR.OFFS,BX
		LEA	SI,EXEHEADER._EXE_REG_IP
		LEA	DI,QUIK_START_ADR
		MOVSW
		MOVSW
		;
		;DO CHUNKS_64K AND CHUNK_PARTIAL
		;
		CALL	CALC_EXE_LEN
;		SUB	AX,DONT_PACK
;		SBB	DX,0
;		MOV	QUIK_CHUNKS_64K,DX
;		SHR	AX,1
;		MOV	QUIK_CHUNK_PARTIAL,AX
;		ADD	AX,AX
;		ADD	AX,DONT_PACK
;		ADC	DX,0
		MOV	EXEHEADER._EXE_REG_IP,OFF QUIK_UNPACK
		CALL	SHR_DXAX_4
		MOV	EXEHEADER._EXE_REG_CS,AX
		MOV	SI,DONT_PACK
		ADD	SI,0FH
		MOV	CL,4
		SHR	SI,CL
		SUB	AX,SI
		MOV	QUIKPACK_PARAS,AX
		FIXES
		;
		;NOW MOVE PACK_SEGMENT TO FINAL_EXE
		;
		MOV	AX,PACK_QUIK
		MOV	DS,AX
		ASSUME	DS:PACK_QUIK
		XOR	SI,SI
		MOV	CX,QUIK_PACK_LEN
		CALL	MOVE_DSSI_TO_FINAL_HIGH_WATER
		ASSUME	DS:DGROUP
		;
		;FINALIZE STUFF IN EXEHEADER
		;
		;STACK GOES AT A PARAGRAPH AT NEW_REPT_ADDR + 256
		;STACK ITSELF IS OFFSET SLR_PACK_LEN+256+SIZE (LZW_??)
		;
		MOV	AX,NEW_REPT_ADDR.LW
		MOV	DX,NEW_REPT_ADDR.HW
		ADD	AX,2K			;MARGIN OF SAFETY...
		ADC	DX,0
		PUSHM	DX,AX
		CALL	SHR_DXAX_4
		MOV	EXEHEADER._EXE_REG_SS,AX
		MOV	CX,QUIK_PACK_LEN+15
		AND	CX,0FFF0H
		INC	CH		;ADD	CX,256+EXP_STRUCT_SIZE
		MOV	EXEHEADER._EXE_REG_SP,CX
		POPM	AX,DX
		RET

HANDLE_QUIKPACK ENDP

		ASSUME	DS:DGROUP,ES:NOTHING

HANDLE_SUB1	PROC	NEAR
		;
		;USE LARGER OF STACKS TO PREVENT DESTRUCTION OF JUMP
		;
		PUSH	CX
		XOR	DX,DX
		MOV	AX,EXEHEADER._EXE_REG_SS
		MOV	CX,4
32$:
		ADD	AX,AX
		ADC	DX,DX
		LOOP	32$
		POP	CX
		ADD	AX,EXEHEADER._EXE_REG_SP
		ADC	DX,0
		CMP	CX,DX
		JB	325$		;DX:AX IS LARGER
		JA	324$		;CX:BX IS LARGER
		CMP	BX,AX
		JB	325$
324$:
		XCHG	AX,BX
		MOV	DX,CX
325$:
		MOV	BX,EXEHEADER._EXE_REG_SP
		SUB	AX,BX
		SBB	DX,0
		MOV	CX,4
326$:
		SHR	DX,1
		RCR	AX,1
		LOOP	326$
		RET

HANDLE_SUB1	ENDP

		ASSUME	DS:NOTHING

DO_COMPRESS	PROC

		PUSHM	FIX2_LDATA_SEGMENT.OFFS,FIX2_LDATA_SEGMENT.SEGM

;		BITT	QUIKPACK_FLAG
;		JNZ	271$
;		CALL	FLUSH_SLRPACK
;		JMP	272$
;271$:
;		CALL	FLUSH_QP32
;272$:
		CALL	COMPRESS
		POPM	DS,SI
		FIXES					;*****
		MOV	FIX2_LDATA_SEGMENT.OFFS,SI	;change this at
		MOV	FIX2_LDATA_SEGMENT.SEGM,DS	;quickpack also
		SYM_CONV_DS				;
		LEA	DI,FIX2_SEGMENT_STUFF		;*****
		MOV	CX,(SIZE SEGMENT_STRUCT+1)/2
		REP	MOVSW
		MOV	FIX2_LDATA_PTR.SEGM,CX
		RET

DO_COMPRESS	ENDP

		ASSUME	DS:NOTHING

DOTS_FINISH	PROC
		;
		;
		;
		BITT	DOTS_FLAG
		JNZ	9$
		BITT	SLRPACK_SELECTED
		JZ	9$
		PUSH	DS
		BITT	QUIKPACK_FLAG
		JNZ	5$
		MOV	AX,PACK_SLR
		MOV	DS,AX
		ASSUME	DS:PACK_SLR
		MOV	FIX_INT21,0C087H	;MAKE INT21 A XCHG AX,AX
		JMP	8$

5$:
		MOV	AX,PACK_QUIK		;NOT FOR QUICKPACK ANY MORE
		MOV	DS,AX
		ASSUME	DS:PACK_QUIK
		MOV	QUIK_FIX_INT21,0C087H
8$:
		POP	DS
		ASSUME	DS:DGROUP
9$:
		RET

DOTS_FINISH	ENDP

endif

		END

