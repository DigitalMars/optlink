		TITLE	OPTLOAD - Copyright (c) 1993 SLR Systems

		INCLUDE	MACROS

		INCLUDE	newexe.inc			;* Macros & constants

keep_read_only	EQU	0

		.286

		PUBLIC	__SLRLOAD

__SLRLOAD	=	9999h

;	SOFT	EXTF	GLOBALALLOC,GLOBALREALLOC,GLOBALFREE,PATCHCODEHANDLE,GLOBALDOSALLOC
;	SOFT	EXTF	GETPROCADDRESS,ALLOCCSTODSALIAS,FREESELECTOR,GETWINFLAGS,MESSAGEBOX
;	SOFT	EXTF	SELECTORACCESSRIGHTS,DOS3CALL,GLOBALLOCK,GLOBALDOSFREE

;	SOFT	EXTA	__AHINCR

	SOFT	EXTF	$$SLR$C2D$SLR$$,$$SLR$MB$SLR$$

	SOFT	EXTA	$$SLR$AH$SLR$$


INT3	MACRO

;	INT	3

	ENDM


LOADER___SLRLOAD	SEGMENT	PUBLIC PARA 'CODE'

		ASSUME	NOTHING,CS:LOADER___SLRLOAD

START:

if	compress_pass1

		PUBLIC	COMPRESS_SKIP,COMPRESS_SEED,BOOTAPP_END

		DB	'A','0'
		DW	0
		DD	0			;I SUPPLY THIS
		DD	0			;I SUPPLY THIS TOO
		DD	0			;ADDRESS OF GLOBALHEAP
MYALLOC		DD	0			;SUPPLIED BY KERNEL
GETENTRY	DD	0			;SUPPLIED BY KERNEL
		DD	0			;I SUPPLY THIS
		DD	0			;?
		DD	0			;?
SETOWNER	DD	0			;SUPPLIED BY KERNEL

MY_HANDLE_PTR	DW	0

else
		DB	'A','0'
		DW	0
		DD	BOOTAPP			;I SUPPLY THIS
		DD	LOADAPPSEG1		;I SUPPLY THIS TOO
		DD	0			;ADDRESS OF GLOBALHEAP
MYALLOC		DD	0			;SUPPLIED BY KERNEL
GETENTRY	DD	0			;SUPPLIED BY KERNEL
		DD	EXITAPP			;I SUPPLY THIS
		DD	0			;?
		DD	0			;?
SETOWNER	DD	0			;SUPPLIED BY KERNEL

MY_HANDLE_PTR	DW	MY_HANDLE


_DATA		SEGMENT WORD PUBLIC	'DATA'

MY_HANDLE	DW	-1

_DATA		ENDS

DGROUP		GROUP	_DATA

endif

;PCNT_SAVED	DB	'53'			;PERCENT COMPRESSED IN ASCII
		;
		;ALL RELOCATABLE REFERENCES MUST BE THROUGH A JUMP TABLE....
		;
_ALLOCCSTODSALIAS	LABEL	DWORD
		MD	$$SLR$C2D$SLR$$		;ALLOCCSTODSALIAS	KERNEL.170
if	BOX
;_MESSAGEBOX	LABEL	DWORD
		MD	$$SLR$MB$SLR$$		;MESSAGEBOX	USER.1
endif
___AHINCR	LABEL	WORD
		MW	$$SLR$AH$SLR$$		;__AHINCR	KERNEL.114

COMPRESSED_LENGTH	DW	C_LEN

COMPRESS_SKIP	EQU	$			;START FILLING COMPRESSION DICTIONARY HERE:

IS_DLL		DB	0

EXITAPP		PROC	FAR
		;
		;THIS NEVER GETS CALLED
		;
		RET

EXITAPP		ENDP


DPMI_UNQUIK	PROC	NEAR
		;
		;DECOMPRESS THIS SEGMENT PLEASE...
		;
		;DS:SI IS SOURCE DATA, ES:DI IS DESTINATION
		;
		;DECOMPRESSOR
		;
		LODSW
		XOR	CX,CX
		XCHG	AX,BP
		MOV	DX,0010H		;16 BITS LEFT TO ROTATE
		JMP	1$

		EVEN
25$:
		MOV	BP,[SI]
		MOV	DL,16
		LEA	SI,2[SI]
		JMP	251$

26$:
		MOV	BP,[SI]
		MOV	DL,16
		LEA	SI,2[SI]
		JMP	261$

51$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	511$

52$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	521$

		EVEN
15$:
;		LODSW
;		XCHG	AX,BP
		MOV	BP,[SI]
		MOV	DL,16
		LEA	SI,2[SI]
		JNC	2$
0$:
		;
		;STRAIGHT BYTE
		;
		MOVSB
1$:
		ADD	BP,BP
		DEC	DX
		JZ	15$
		JC	0$
2$:
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	25$
251$:
		JC	3$
		;
		;00x	2 or 3, these are most likely
		;
		XOR	BH,BH
252$:
		INC	CX		;CX = 1
		ADD	BP,BP
		DEC	DX
		JZ	26$
261$:
		ADC	CX,CX		;CX = 2 OR 3
		CMP	CX,2
		JZ	27$
5$:
		;
		;GET HIGH BYTE OF OFFSET
		;
		XOR	BH,BH
		PUSH	CX
		ADD	BP,BP
		DEC	DX
		JZ	51$
511$:
		JC	6$
		;
		;0
		;
		ADD	BP,BP
		DEC	DX
		JZ	52$
521$:
		JC	55$
		;
		;00 IS 0
		;
RANGE_DONE:
		POP	CX
27$:
		MOV	BL,[SI]
		INC	SI
		NOT	BX
		MOV	AX,SI
		LEA	SI,[BX+DI]		;03
;		CLI				;02
		REP MOVS [DI],ES:BYTE PTR [SI]	;05+04 PER
;		STI				;02
		MOV	SI,AX			;02 =
		JMP	1$

56$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	561$

59$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	591$

		EVEN
55$:
		;
		;01
		;
		INC	BH
		ADD	BP,BP
		DEC	DX
		JZ	56$
561$:
		JNC	RANGE_DONE		;010 IS 1
		;
		;011X  IS 2 OR 3
		;
		MOV	CX,201H
GET_RANGE_CX:
		XOR	BH,BH
58$:
		ADD	BP,BP
		DEC	DX
		JZ	59$
591$:
		ADC	BH,BH
		DEC	CL
		JNZ	58$
		ADD	BH,CH
		JMP	RANGE_DONE

3$:
		;
		;1
		;
		INC	CX			;1
		ADD	BP,BP
		DEC	DX
		JZ	31$
311$:
		JNC	252$
		;
		;11
		;
		INC	CX			;2
		ADD	BP,BP
		DEC	DX
		JZ	32$
321$:
		JNC	252$
		;
		;111
		;
		CALL	GET_BIT
		MOV	BX,802H
		JNC	GET_BX			;1110XX	IS 8-11
4$:
		;
		;1111
		;
		CALL	GET_BIT
		MOV	BX,0C03H
		JNC	GET_BX			;11110XXX IS 12-19
		;
		;11111
		;
		MOV	CL,[SI]
		INC	SI
		CMP	CL,81H
		MOV	CH,0
		JB	5$
		JNZ	9$
		MOV	CL,CH
		JMP	1$

9$:
		RET

6$:
		;
		;1
		;
		CALL	GET_BIT
		JC	7$
		;
		;10
		;
		CALL	GET_BIT
		MOV	CX,402H
		JNC	GET_RANGE_CX	;100XX	IS 4-7
		;
		;101XXX IS 8-F
		;
		MOV	CX,803H
		JMP	GET_RANGE_CX

31$:
		LODSW
		XCHG	AX,BP
		MOV	DL,16
		JMP	311$

7$:
		;
		;11
		;
		CALL	GET_BIT
		MOV	CX,1004H
		JNC	GET_RANGE_CX	;110XXXX IS 10H-1FH
		;
		;111
		;
		CALL	GET_BIT
		MOV	CX,2004H
		JNC	GET_RANGE_CX	;1110XXXX IS 20H-2FH
		;
		;1111
		;
		CALL	GET_BIT
		MOV	CX,3004H
		JNC	GET_RANGE_CX
		MOV	CX,4006H
		JMP	GET_RANGE_CX

32$:
		LODSW
		XCHG	AX,BP
		MOV	DL,10H
		JMP	321$


		EVEN

GET_BX:
		;
		;
		;
		XOR	CX,CX
8$:
		ADD	BP,BP
		DEC	DX
		JZ	81$
811$:
		ADC	CX,CX
		DEC	BL
		JNZ	8$
		ADD	CL,BH
		JMP	5$

81$:
;		LODSW
;		XCHG	AX,BP
		MOV	BP,[SI]
		MOV	DL,10H
		LEA	SI,2[SI]
		JMP	811$

DPMI_UNQUIK	ENDP

		EVEN

GET_BIT		PROC	NEAR
		;
		;
		;
		ADD	BP,BP
		DEC	DX
		JZ	1$
		RET

1$:
;		LODSW
;		XCHG	AX,BP
		MOV	BP,[SI]
		MOV	DL,16
		LEA	SI,2[SI]
		RET

GET_BIT		ENDP

GET_CSALIAS_AX	PROC	NEAR
		;
		;
		;
		PUSH	CS
		CALL	_ALLOCCSTODSALIAS	;RETURNS IN AX
		RET

GET_CSALIAS_AX	ENDP

BOOTAPP		PROC	FAR			;PASSES HANDLE TO EXEHEADER AND OPEN FILE HANDLE
		;
		;PASCAL CALLING CONVENTIONS
		;
		;PARAM1 == SELECTOR CONTAINING EXEHEADER
		;PARAM2 == FILE HANDLE
		;
		;RETURN 0==ERROR, !0== SUCCESS
		;
		INT3
		PUSH	BP
		MOV	BP,SP
		PUSHM	DS,SI,DI

EXE_SELECTOR	EQU	<(WPTR [BP+8])>
FILE_HANDLE	EQU	<(WPTR [BP+6])>

;		INT3
;		DEBMSG	'BOOTAPP - EXE Selector',EXE_SELECTOR
;		DEBMSG	'BOOTAPP - FILE Handle',FILE_HANDLE

		MOV	AX,___AHINCR		;DETECT ILLEGAL REAL-MODE
		CMP	AX,1000H
		JNZ	1$
0$:
		POPM	DI,SI,DS,BP
		RET	4

COPYRGHT	DB	'OPTLOADER - Copyright (C) 1993-2004 Digital Mars',0AH
		db	'All Rights Reserved'
if	BOX
		DB	0AH,'For evaluation purposes Only'
endif
		DB	0

if	DEBUG
BOOTAPP_MSG	DB	'BOOTAPP Here',0
endif

1$:
		;
		;NEED R/W ALIAS FOR INITIALIZATION
		;
		CALL	GET_CSALIAS_AX
		OR	AX,AX
		JZ	0$

		MOV	DS,AX			;DS IS R/W CS

if	compress_apploader

		;
		;MOVE COMPRESSED CODE UP IN MEMORY
		;
		MOV	ES,AX			;FOR STORING DECOMPRESSED CODE
		LEA	SI,LOADAPPSEG1-1
		LEA	DI,BOOTAPP_END+15
		MOV	CX,COMPRESSED_LENGTH
		ADD	SI,CX
		STD
		REP	MOVSB
		CLD
		;
		;DECOMPRESS IT BACK WHERE IT BELONGS
		;
		LEA	SI,1[DI]
		LEA	DI,LOADAPPSEG1
		PUSH	BP
		CALL	DPMI_UNQUIK
		POP	BP
		;
		;CONTINUE AS YOU WERE...
		;
		JMP	BOOTAPP_CONTINUE

COMPRESS_SEED	EQU	$
endif
if	compress_pass2
LOADAPPSEG1:

BOOTAPP_CONTINUE	EQU	LOADAPPSEG1+3

		INCLUDE	COMPRESS.DAT		;THANKS MIKE

		ORG	START+B_C_LEN

BOOTAPP		ENDP

BOOTAPP_END	LABEL	BYTE

		DB	16 DUP(0)

endif
if	compress_pass1 OR (NOT compress_apploader)
		;
		;PASS1 WE BUILD IT COMPLETE
		;
LOADAPPSEG1:
		JMP	LOADAPPSEGS


BOOTAPP_CONTINUE:

		ASSUME DS:LOADER___SLRLOAD

		MOV	AX,EXE_SELECTOR

		PUSH	AX
		CALL	INIT_SYSCALLS		;VALIDATE SYSTEM CALLS

		XOR	DI,DI			;DI IS ZERO THROUGHOUT
		MOV	ME_ASCIZ.SEGM,CS

		MOV	AX,OFF ME_ASCIZ_TEXT
		PUSHM	DS,AX
		PUSH	260
		MOV	ME_ASCIZ.OFFS,AX

		CALL	_GETMODULEFILENAME

		;
		;LOOK FOR 80X87
		;

;		DEBMSG	'Checking for 80X87'

		CALL	_GETWINFLAGS
		TEST	AX,WF_80X87
		JZ	2$

;		DEBMSG	'Found 80X87'

		MOV	RELOC_OSTYPE_TBL,OFF OSTYPE_ABORT	;STOP AT THESE
2$:
		;
		;CALCULATE LARGEST SEGMENT PIECE
		;
		MOV	ES,EXE_SELECTOR		;SET UP DS FOR RETURN

		MOV	AX,ES:[DI].NEW_EXE.NE_AUTODATA
		MOV	CX,ES:[DI].NEW_EXE.NE_CSEG		;# OF SEGMENTS
		MOV	DGROUP_SEGNO,AX
		MOV	SI,ES:[DI].NEW_EXE.NE_SEGTAB	;BEGINNING OF SEGMENT TABLE

21$:
		MOV	AX,ES:[SI].NEW_SEG.NS_CBSEG
		ADD	SI,SIZE NEW_SEG1
		CMP	MAX_SEGSZ_FILE,AX
		JA	22$
		MOV	MAX_SEGSZ_FILE,AX
22$:
		DEC	CX
		JNZ	21$

;		DEBMSG	'MAX_SEGSZ_FILE',MAX_SEGSZ_FILE

		ADD	MAX_SEGSZ_FILE,511+511
		JNC	23$
		MOV	MAX_SEGSZ_FILE,0
23$:
;		DEBMSG	'MAX_SEGSZ_FILE',MAX_SEGSZ_FILE

		TEST	ES:[DI].NEW_EXE.NE_FLAGS,8000H
		JZ	29$

		DEC	IS_DLL
29$:
		MOV	AX,DS
		PUSH	ES
		POP	DS
		ASSUME	DS:NOTHING		;EXE_HEADER
		CALL	FREE_CSALIAS_AX

if	DEBUG
		PUSHM	0,CS,OFF BOOTAPP_MSG,ME_ASCIZ.SEGM,ME_ASCIZ.OFFS,MB_OK+MB_SYSTEMMODAL
		CALL	_MESSAGEBOX
endif
		CALL	GET_MASTER_TEMP
		JZ	ERR_BOOT

		MOV	DS,EXE_SELECTOR
		XOR	DI,DI
		;
		;ALLOCATE MEMORY HANDLES
		;
		CALL	ALLOCATE_HANDLES	;ALLOCATES ALL BUT DGROUP
		OR	AX,AX
		JZ	ERR_BOOT
;		DEBMSG	'Handles Successfully Allocated'
		;
		;LOAD DGROUP FIRST TO FORCE ITS MEMORY TO BE ALLOCATED
		;(SINCE OTHER SEGMENTS MAY REFER TO IT LEGALLY IN SINGLE-INSTANCE CASES)
		;
		MOV	AX,[DI].NEW_EXE.NE_AUTODATA	;LOAD DGROUP IF THERE
		OR	AX,AX
		JZ	4$			;SOME DLL'S MAY NOT HAVE A DGROUP
;		DEBMSG	'Load DGROUP'
		PUSHM	DS,FILE_HANDLE,AX	;EXE_SELECTOR, FILE_HANDLE, SEGMENT #
		CALL	LOADAPPSEG
		OR	AX,AX
		JNZ	4$
ERR_BOOT:
	 	PUSHM	0,CS,OFF LOADERRMSG,ME_ASCIZ.SEGM,ME_ASCIZ.OFFS,MB_OK+MB_ICONHAND+MB_SYSTEMMODAL
		CALL	_MESSAGEBOX
		XOR	AX,AX
		JMP	END_BOOT

4$:
		;
		;NOW LOAD ALL DATA SEGMENTS SINCE THEIR SELECTORS ARE 'PRESENT'
		;
;		DEBMSG	'Loading DATA Segs and PRELOAD Segs'
		MOV	CX,1			;START WITH SEGMENT 1
		MOV	SI,[DI].NEW_EXE.NE_SEGTAB
41$:
		CMP	[DI].NEW_EXE.NE_CSEG,CX	;STOP IF END OF TABLE
		JB	49$
		MOV	AX,[SI].NEW_SEG.NS_FLAGS
		TEST	AL,NSLOADED		;SKIP IF LOADED (DGROUP)
		JNZ	48$
;		TEST	AL,NSPRELOAD		;LOAD IF PRELOAD
;		JNZ	43$
;		TEST	AL,NSMOVE
;		JZ	43$			;LOAD IF IT WAS FIXED
		CMP	[DI].NEW_EXE.NE_CSIP.SEGM,CX	;PRELOAD START ADDRESS SEGMENT
		JZ	43$
		TEST	AL,NSDATA		;SKIP IF NOT DATA
		JZ	48$
		CMP	[SI].NEW_SEG.NS_MINALLOC,DI	;PRELOAD ONLY IF 64K...
		JZ	43$
		CMP	CX,1
		JZ	48$
		CMP	[SI-SIZE NEW_SEG1].NEW_SEG.NS_MINALLOC,DI
		JNZ	48$
		TEST	[SI-SIZE NEW_SEG1].NEW_SEG.NS_FLAGS,NSDATA
		JZ	48$
		DEBMSG	'LOADING TILED SEGMENT'
43$:
		PUSH	CX			;SAVE CX
		PUSHM	DS,FILE_HANDLE,CX	;EXE_SELECTOR, FILE_HANDLE, SEGMENT #
		CALL	LOADAPPSEG
		POP	CX
		OR	AX,AX
		JZ	ERR_BOOT
48$:
		ADD	SI,SIZE NEW_SEG1
		INC	CX
		JMP	41$

49$:
;		DEBMSG	'Copyright (C) 1993 SLR Systems'
if	BOX or DEBUG
		PUSHM	0,CS,OFF COPYRGHT,ME_ASCIZ.SEGM,ME_ASCIZ.OFFS,MB_OK+MB_SYSTEMMODAL
		CALL	_MESSAGEBOX
endif

		MOV	AX,SP
END_BOOT:
		PUSH	AX			;SAVE ERROR FLAG

		CALL	FREE_MASTER_TEMP

		POP	AX			;ERROR FLAG

;		DEBMSG	'MAX_SEGSZ_FILE',MAX_SEGSZ_FILE

		POPM	DI,SI,DS,BP
		RET	4

BOOTAPP		ENDP


		ASSUME	DS:NOTHING

GET_MASTER_TEMP	PROC	NEAR
		;
		;ALLOCATE MEMORY TO BE USED FOR LOADING DATA SEGMENTS
		;
		XOR	CX,CX
		MOV	AX,MAX_SEGSZ_FILE	;MAX FILE_IMAGE
		OR	AX,AX
		JNZ	31$
		INC	CX
31$:
		PUSHM	GMEM_MOVEABLE,CX,AX
		PUSHM	CX,AX			;TRY FOR 64K OF DOS MEMORY
		CALL	_GLOBALDOSALLOC		;RETURN SELECTOR IN AX
		OR	AX,AX
		MOV	DX,AX
		JNZ	32$

		CALL	_GLOBALALLOC		;NOPE, USE EXTENDED MEMORY
		OR	AX,AX
		JZ	9$
		PUSHM	AX,AX
		CALL	_GLOBALLOCK
		POP	AX
		JMP	33$

32$:
		XOR	AX,AX
		ADD	SP,6
33$:
		PUSHM	DX,AX
		CALL	GET_CSALIAS_AX
		MOV	DS,AX
		POPM	AX,DX
		ASSUME	DS:LOADER___SLRLOAD
		MOV	MASTER_TEMP_HANDLE,AX
		MOV	MASTER_TEMP_SEGMENT,DX
		XOR	AX,AX
		PUSH	DS
		MOV	DS,AX
		POP	AX
		ASSUME	DS:NOTHING
		CALL	FREE_CSALIAS_AX
		OR	AL,-1
9$:
		RET

GET_MASTER_TEMP	ENDP


FREE_MASTER_TEMP	PROC	NEAR

		MOV	AX,MASTER_TEMP_HANDLE
		OR	AX,AX
		JNZ	75$
		MOV	AX,MASTER_TEMP_SEGMENT
		OR	AX,AX
		JZ	76$
		PUSH	AX
		CALL	_GLOBALDOSFREE
		JMP	76$

75$:
		PUSH	AX
		CALL	_GLOBALFREE
76$:
		CALL	GET_CSALIAS_AX
		MOV	DS,AX
		ASSUME	DS:LOADER___SLRLOAD

		MOV	MASTER_TEMP_SEGMENT,0

		MOV	AX,DS
		PUSH	SS
		POP	DS
		ASSUME	DS:NOTHING
		;
		;DONE WITH R/W ALIAS
		;
		CALL	FREE_CSALIAS_AX
		RET

FREE_MASTER_TEMP	ENDP


;APP_START	PROC
;
;		PUSHM	ES,DX,CX,BX,AX
;		PUSHM	0,CS,OFF COPYRGHT,CS,OFF PROGRESS_MSG,MB_OK	;+MB_SYSTEMMODAL
;		CALL	_MESSAGEBOX
;		POPM	AX,BX,CX,DX,ES
;		JMP	START_ADDR
;
;APP_START	ENDP


ALLOCATE_HANDLES	PROC	NEAR
		;
		;DS == EXE Header
		;DI == 0
		;
		;ALLOCATE HANDLES FOR ALL SEGMENTS NOT ALREADY ALLOCATED
		;
		;RETURN AX!=0 FOR SUCCESS
		;
		;CODE SEGMENTS WILL BE ALLOCATED 0 BYTES NOW TO GET SELECTORS ASSIGNED
		;WILL BE REALLOCATED WHEN LOADED
		;
		;DATA SEGMENTS WILL BE ALLOCATED TO FULL SIZE????  >64K SIZES HANDLED CORRECTLY
		;
		;DGROUP WILL BE ALLOCATED LATER BY LOADAPPSEG, SINCE IT IS NEEDED FOR MULTIPLE INSTANCES
		;
;		DEBMSG	'Allocate Handles'

		MOV	CX,[DI].NEW_EXE.NE_CSEG		;# OF SEGMENTS
		MOV	SI,[DI].NEW_EXE.NE_SEGTAB	;BEGINNING OF SEGMENT TABLE
		;
		;THERE IS AT LEAST ONE SEGMENT, ME...
		;
1$:
;		AND	[SI].NEW_SEG.NS_FLAGS,NOT NSERONLY	;IGNORE EXECUTE-ONLY READ-ONLY BIT
		CMP	[SI].NEW_SEG1.NS_HANDLE,DI	;HANDLE ALREADY THERE?
		JNZ	8$				;LIKE FROM HUGE ALLOC?
		CMP	[DI].NEW_EXE1.NE_PAUTODATA,SI	;SKIP ALLOC FOR DGROUP
		JZ	8$

		MOV	BX,[SI].NEW_SEG.NS_FLAGS	;LOAD FLAGS
		PUSH	CX
iff	keep_read_only
		AND	BX,NOT NSERONLY			;IGNORE EXECUTE-ONLY AND READ-ONLY BIT
endif
		TEST	BL,NSDATA
		JNZ	FALLOC_DATA

;		DEBMSG	'Alloc CODE Segment'

		OR	BH,NSWINCODE/256		;ASSUME A CODE SEGMENT
2$:
		OR	BL,10H				;FORCE MOVEABLE
		PUSHM	BX,DI,DI			;FLAGS, 0, 0	ALLOCATES SELECTORS, NO MEMORY
		CALL	MYALLOC
		MOV	AX,DX
5$:
		OR	AX,AX				;ZERO MEANS ALLOC FAILED
		JZ	7$

		OR	BPTR [SI].NEW_SEG.NS_FLAGS,NSALLOCED	;HANDLE ALLOCATED
		MOV	[SI].NEW_SEG1.NS_HANDLE,AX	;SAVE IT

		PUSHM	AX,DS
		CALL	SETOWNER			;TELL THEM WHO REALLY OWNS THIS TURKEY
		POP	CX
8$:
		ADD	SI,SIZE NEW_SEG1
		DEC	CX
		JNZ	1$
9$:
		MOV	AX,SP				;AX NON-ZERO MEANS SUCCESS
		RET

FALLOC_DATA:
		CMP	[SI].NEW_SEG.NS_MINALLOC,DI	;IS IT 64K?
		JNZ	2$
		JZ	FALLOC_HDATA			;YES, ASSUME HUGE

;		DEBMSG	'Alloc DATA Segment'

		PUSHM	GMEM_MOVEABLE, 0,[SI].NEW_SEG.NS_MINALLOC
		CALL	_GLOBALALLOC			;RETURNS HANDLE
		JMP	5$

7$:
		POP	CX
		XOR	AX,AX		;SIGNAL FAILURE
		RET

FALLOC_HDATA:
		;
		;HOW LARGE IS THIS HUGE SEGMENT?
		;

;		DEBMSG	'Alloc HUGE DATA Segment'

		PUSHM	SI,CX
		XOR	DX,DX
3$:
		;
		;SCAN COUNTING CONTIGUOUS SEGMENTS
		;
		INC	DX				;COUNT # OF 64K SEGMENTS
		ADD	SI,SIZE NEW_SEG1
		DEC	CX				;STOP IF NO MORE SEGMENTS
		JZ	33$
		CMP	[DI].NEW_EXE1.NE_PAUTODATA,SI	;STOP IF NEXT IS DGROUP
		JZ	33$
		CMP	[SI].NEW_SEG.NS_MINALLOC,DI	;CONTINUE IF THIS GUY 64K
		JZ	3$
		JMP	35$

33$:
		SUB	SI,SIZE NEW_SEG1
35$:
		PUSH	DX

		PUSHM	GMEM_MOVEABLE,DX,[SI].NEW_SEG.NS_MINALLOC
		CALL	_GLOBALALLOC
		POPM	DX,CX,SI
		OR	AX,AX
		JZ	7$

		PUSHM	SI,AX
4$:
		ADD	SI,SIZE NEW_SEG1
		ADD	AX,___AHINCR
		DEC	CX
		JZ	45$				;SKIP IF THAT WAS LAST SEGMENT
		CMP	[DI].NEW_EXE1.NE_PAUTODATA,SI	;STOP IF NEXT IS DGROUP
		JZ	45$

		OR	[SI].NEW_SEG.NS_FLAGS,NSALLOCED OR NSTILED
		MOV	[SI].NEW_SEG1.NS_HANDLE,AX
		DEC	DX
		JNZ	4$
45$:
		POPM	AX,SI
		JMP	5$

ALLOCATE_HANDLES	ENDP


		ASSUME	DS:NOTHING,ES:NOTHING

LOADAPPSEGS	PROC	FAR
		;
		;
		;
		INT3
		PUSH	BP
		MOV	BP,SP
		SUB	SP,4

EXE_SELECTOR	EQU	<(WPTR [BP+10])>
LA_FILE_HANDLE	EQU	<(WPTR [BP+8])>
SEGNO		EQU	<(WPTR [BP+6])>

LA1_AX		EQU	<(WPTR [BP-2])>
LA1_DX		EQU	<(WPTR [BP-4])>

		MOV	AX,LA_FILE_HANDLE
		MOV	CX,SEGNO

		CMP	AX,-1
		JNZ	1$

		CMP	DGROUP_SEGNO,CX
		JZ	921$

		CALL	GET_MY_HANDLE

		CMP	AX,-1
		JNZ	1$

		DEBMSG	'NULL HANDLE'
921$:
		JMP	92$

1$:
		MOV	LA_FILE_HANDLE,AX

		CMP	PRELOADS_DONE,0		;HAVE I DONE PRELOADS YET?
		JZ	4$			;NOPE, GO DO THEM
2$:
		PUSHM	EXE_SELECTOR,LA_FILE_HANDLE,SEGNO
		CALL	LOADAPPSEG		;YES, JUST LOAD REQUEST SEGMENT

8$:
9$:
		MOV	SP,BP
		POP	BP
		RET	6

4$:
		DEBMSG	'DEMAND LOAD FORCED PRELOADS',SEGNO

		PUSHM	DS,SI,DI
		XOR	DI,DI
		MOV	LA1_AX,DI
		MOV	LA1_DX,DI

		CALL	GET_CSALIAS_AX
		MOV	DS,AX
		ASSUME	DS:LOADER___SLRLOAD
		MOV	PRELOADS_DONE,-1
		XOR	AX,AX
		PUSH	DS
		MOV	DS,AX
		POP	AX
		ASSUME	DS:NOTHING
		CALL	FREE_CSALIAS_AX

		CALL	GET_MASTER_TEMP		;SET UP MEMORY TO USE FOR LOAD
		;
		;NEED TO DO PRELOADS, THEN DO THE REQUESTED SEGMENT IF NOT ALREADY...
		;
		;
		;NOW LOAD ALL DATA SEGMENTS SINCE THEIR SELECTORS ARE 'PRESENT'
		;
;		DEBMSG	'Loading DATA Segs and PRELOAD Segs'
		MOV	DS,EXE_SELECTOR
		MOV	CX,1			;START WITH SEGMENT 1
		MOV	SI,[DI].NEW_EXE.NE_SEGTAB
41$:
		CMP	[DI].NEW_EXE.NE_CSEG,CX	;STOP IF END OF TABLE
		JB	49$
		MOV	AX,[SI].NEW_SEG.NS_FLAGS
		TEST	AL,NSLOADED		;SKIP IF LOADED (DGROUP)
		JNZ	48$
		TEST	AL,NSDATA
		JNZ	43$
		TEST	AL,NSPRELOAD		;LOAD IF PRELOAD
		JNZ	43$
		TEST	AL,NSMOVE
		JZ	43$			;LOAD IF IT WAS FIXED
		CMP	[DI].NEW_EXE.NE_CSIP.SEGM,CX	;PRELOAD START ADDRESS SEGMENT
		JNZ	48$
43$:
;		JMP	48$

		PUSH	CX			;SAVE CX
		PUSHM	DS,LA_FILE_HANDLE,CX	;EXE_SELECTOR, FILE_HANDLE, SEGMENT #
		CALL	LOADAPPSEG
		POP	CX
		OR	AX,AX
		JZ	91$
		CMP	SEGNO,CX
		JNZ	48$
		MOV	LA1_AX,AX
		MOV	LA1_DX,DX
48$:
		ADD	SI,SIZE NEW_SEG1
		INC	CX
		JMP	41$

49$:
		CALL	FREE_MASTER_TEMP

		MOV	AX,LA1_AX
		MOV	DX,LA1_DX

		POPM	DI,SI,DS
		OR	AX,AX

		JNZ	81$

		JMP	2$

81$:
		JMP	8$

91$:
		DEBMSG	'PRELOAD FAILED ON',CX

		CALL	FREE_MASTER_TEMP

		POPM	DI,SI,DS
92$:
		XOR	AX,AX
		XOR	DX,DX
		JMP	8$

LOADAPPSEGS	ENDP


GET_MY_HANDLE	PROC	NEAR
		;
		;GET A FILE HANDLE FOR THIS GUY
		;
		PUSH	SI
		MOV	CX,-1

		CMP	IS_DLL,CL		;.DLLS CURRENTLY FAIL
		JZ	L9$

		MOV	SI,MY_HANDLE_PTR

		MOV	AX,SS:[SI]

		CMP	AX,CX
		JNZ	L9$

		PUSHM	ES,DS,BX,CS

		POP	DS
		MOV	DX,OFF ME_ASCIZ_TEXT
		MOV	AX,3D00H		;READONLY

		CALL	_DOS3CALL

		JNC	L4$

		MOV	DX,OFF ME_ASCIZ_TEXT
		MOV	AX,3D00H + 20H		;READONLY, DENY WRITE

		CALL	_DOS3CALL

		JC	L8$
L4$:
		MOV	SS:[SI],AX
L41$:
		POPM	BX,DS,ES
L9$:
		POP	SI
		RET

L8$:
		DEBMSG	'Cannot Open',AX

		PUSHM	0,CS,OFF CANTOPEN_MSG,ME_ASCIZ.SEGM,ME_ASCIZ.OFFS,MB_OK+MB_SYSTEMMODAL
		CALL	_MESSAGEBOX

		MOV	AX,-1
		JMP	L41$

GET_MY_HANDLE	ENDP


LOADAPPSEG	PROC	FAR
		;
		;PARAM1 == EXE_SELECTOR
		;PARAM2 == FILE_HANDLE
		;PARAM3 == SEGMENT # TO LOAD
		;
		;RETURN WITH
		;	AX == SELECTOR OF SEGMENT   OR    0 ON ERROR
		;	DX == HANDLE OF SEGENT
		;
		PUSH	BP
		MOV	BP,SP
		SUB	SP,24				;LOCAL STORAGE
		PUSHM	DS,SI,DI

EXE_SELECTOR	EQU	<(WPTR [BP+10])>
LA_FILE_HANDLE	EQU	<(WPTR [BP+8])>
SEGNO		EQU	<(WPTR [BP+6])>

SEG_HANDLE	EQU	<(WPTR [BP-2])>
SEG_SELECTOR	EQU	<(WPTR [BP-4])>
RETRIES_LEFT	EQU	<(WPTR [BP-6])>
TEMP_SEGMENT	EQU	<(WPTR [BP-8])>
TEMP_HANDLE	EQU	<(WPTR [BP-10])>
TARG_RTN	EQU	<(WPTR [BP-12])>
RELOC_STACK	EQU	<(WPTR [BP-14])>
TEMP_DOS_SEGMENT EQU	<(WPTR [BP-16])>
PRE_DELTA	EQU	<(WPTR [BP-18])>
POST_DELTA	EQU	<(WPTR [BP-20])>
MODULE_NUMBER	EQU	<(WPTR [BP-22])>

		DEBMSG	'LOADAPPSEG',SEGNO

		XOR	DI,DI
		MOV	TEMP_HANDLE,DI
		MOV	TEMP_DOS_SEGMENT,DI
		MOV	PRE_DELTA,DI
		MOV	POST_DELTA,DI

		MOV	SI,SEGNO			;SEG # I MUST LOAD
		MOV	DS,EXE_SELECTOR			;POINT TO EXEHEADER
		DEC	SI				;ZERO-BASE IT, THEN TIMES 10
		SHL	SI,1
		MOV	BX,SI
		SHL	SI,2
		ADD	SI,BX
		ADD	SI,[DI].NEW_EXE.NE_SEGTAB	;SI IS SEGTBL ENTRY

		MOV	AX,[SI].NEW_SEG.NS_MINALLOC
		MOV	BX,[SI].NEW_SEG.NS_FLAGS
		MOV	DX,[SI].NEW_SEG1.NS_HANDLE
iff	keep_read_only
		AND	BX,NOT NSERONLY
endif
		CMP	[DI].NEW_EXE1.NE_PAUTODATA,SI
		JZ	LOAD_DGROUP_SEGMENT

		TEST	BL,NSDATA
		JZ	109$
		CMP	[SI].NEW_SEG.NS_MINALLOC,DI
		JZ	ALLOC_FINISH			;64K DATA ALREADY ALLOCATED

		CMP	SEGNO,1				;SEGMENT 1 NOT ALLOCATED YET
		JZ	109$

		CMP	[SI-SIZE NEW_SEG1].NEW_SEG.NS_MINALLOC,DI	;WAS PREVIOUS SEGMENT == 64K?
		JNZ	109$

		TEST	[SI-SIZE NEW_SEG1].NEW_SEG.NS_FLAGS,NSDATA	;WAS IT DATA?
		JNZ	ALLOC_FINISH					;YES, THIS ALREADY ALLOCATED

		;
		;CODE WAS ALLOCATED AT LENGTH ZERO TO JUST ALLOCATE SELECTOR
		;
;		DEBMSG	'REALLOC Code Segment'

109$:
		XOR	CX,CX
		OR	AX,AX
		JNZ	11$
		INC	CX
11$:
		PUSH	DX
		PUSHM	DX,CX,AX,DI
		CALL	_GLOBALREALLOC		;RESIZE CODE SEGMENT TO CORRECT SIZE
		POP	DX

		CMP	AX,DX			;MAKE SURE HANDLE SURVIVED
		JE	ALLOC_FINISH
		DEBMSG	'REALLOC FAILED'
LOAD_FAIL:
		XOR	AX,AX				;ERROR LOADING SEGMENT
		XOR	DX,DX
		JMP	LOAD_END

LOAD_DGROUP_SEGMENT:

;		DEBMSG	'Allocate DGROUP'

		TEST	BL,NSALLOCED
		JNZ	ALLOC_FINISH
;		JZ	21$
;		DEBMSG	'DGROUP Already Allocated...'	;I DON'T THINK THIS CAN HAPPEN
;		JMP	LOAD_FAIL

21$:
		XOR	CX,CX
		ADD	AX,[DI].NEW_EXE.NE_STACK
		ADC	CX,DI
		ADD	AX,[DI].NEW_EXE.NE_HEAP
		ADC	CX,DI
		JZ	25$
		OR	AX,AX
		JZ	25$
		DEBMSG	'DGROUP OVERFLOW'
		JMP	LOAD_FAIL
25$:
		PUSHM	GMEM_MOVEABLE OR GMEM_ZEROINIT,CX,AX	;FOR NOW WE ZEROINIT, ITS EASIER...
		CALL	_GLOBALALLOC

		OR	AX,AX
		JNZ	26$
		DEBMSG	'DGROUP ALLOC FAILED'
		JMP	LOAD_FAIL

26$:
		MOV	[SI].NEW_SEG1.NS_HANDLE,AX
		OR	BPTR [SI].NEW_SEG.NS_FLAGS,NSALLOCED
		PUSH	AX
		PUSHM	AX,DS
		CALL	SETOWNER			;MAY NOT NEED THIS SINCE IT REALLY BELONGS TO TASK...
		POP	DX
ALLOC_FINISH:
;		DEBMSG	'Allocation OK'
		;
		;DX IS HANDLE OF SEGMENT WE ARE LOADING
		;
		MOV	SEG_HANDLE,DX
		;
		;MAKE LOWER 2 BITS MATCH CODE SEGMENT TO YIELD SELECTOR
		;
		MOV	AX,CS
		AND	DX,NOT 3
		AND	AL,3
		OR	DL,AL
		MOV	AX,[SI].NEW_SEG.NS_FLAGS
		MOV	SEG_SELECTOR,DX
iff	keep_read_only
		AND	AL,NOT NSERONLY			;IGNORE R/O E/O BIT
endif
		;
		;IF CODE, OR R/O DATA, NEED TO CHANGE SELECTOR ACCESS
		;
if	keep_read_only
		TEST	AL,NSERONLY
		JNZ	31$
endif
		TEST	AL,NSDATA
		JNZ	35$
31$:
;		DEBMSG	'Change Selector ACCESS Rights'

		PUSH	DX
		PUSHM	DX,DI,DI
		CALL	_SELECTORACCESSRIGHTS		;GET CURRENT ACCESS RIGHTS BITS
		AND	AL,0F7H				;BIT 3 OFF MEANS DATA
		OR	AL,2				;BIT 1 ON MEANS WRITEABLE
		PUSHM	1,AX
		CALL	_SELECTORACCESSRIGHTS		;CHANGE TO R/W DATA SEGMENT
35$:
		MOV	AX,MASTER_TEMP_SEGMENT		;SET DURING APP STARTUP
		MOV	RETRIES_LEFT,2			;ALLOW 2 RETRIES ON THE LOAD
		;
		;IF EXEPACKED OR RELOCS, NEED ANOTHER SEGMENT ALLOCATED PLEASE
		;
		MOV	TEMP_SEGMENT,AX
		OR	AX,AX
		JNZ	39$

;		DEBMSG	'Allocate TEMP Segment'

		MOV	AX,[SI].NEW_SEG.NS_SECTOR	;SKIP IF NO DATA TO READ
		OR	AX,AX
		JZ	39$
		MOV	AX,[SI].NEW_SEG.NS_CBSEG	;MAKE IT SIZE OF DATA
		XOR	CX,CX
		OR	AX,AX
		JNZ	37$
		INC	CX
37$:
		ADD	AX,511+511			;FOR ALIGNMENT STUFF
		ADC	CX,0
		PUSHM	GMEM_MOVEABLE,CX,AX		;ALLOCATE 64K PLEASE

		CMP	GLOBALDOS_FAILED,0		;HAS THIS CALL FAILED BEFORE?
		JNZ	38$

		PUSHM	CX,AX
		CALL	_GLOBALDOSALLOC			;TRY FIXED DOS MEMORY (FOR FASTER I/O)
		OR	AX,AX
		JZ	375$
		ADD	SP,6				;DON'T NEED GLOBALALLOC PARAMS
		MOV	TEMP_DOS_SEGMENT,AX
		MOV	DX,AX
		JMP	389$

375$:
		CALL	GET_CSALIAS_AX
		PUSH	DS
		MOV	DS,AX
		ASSUME	DS:LOADER___SLRLOAD
		MOV	GLOBALDOS_FAILED,-1
		MOV	AX,DS
		POP	DS
		ASSUME	DS:NOTHING
		CALL	FREE_CSALIAS_AX
38$:
		CALL	_GLOBALALLOC
		OR	AX,AX
		JNZ	381$
		DEBMSG	'TEMP ALLOC FAILED'
		JMP	LOAD_FAIL1

381$:
		MOV	TEMP_HANDLE,AX
		PUSH	AX
		CALL	_GLOBALLOCK
389$:
		MOV	TEMP_SEGMENT,DX
39$:
		JMP	LOAD_RETRY

LOAD_FAIL1:
		JMP	LOAD_FAIL

LOAD_DISK_ERROR:
		POP	DS
LOAD_DISK_ERROR1:
		DEC	RETRIES_LEFT
		JNZ	40$
		DEBMSG	'DISK RETRIES FAILED'
		JMP	LOAD_FAIL1
40$:
		XOR	DI,DI

		DEBMSG	'Reset Disk'
		DEBMSG	'Retry Segment',SEGNO

		MOV	AH,0DH				;RESET DISK SUBSYSTEM
		CALL	_DOS3CALL
LOAD_RETRY:
		;
		;
		;
		MOV	DX,[SI].NEW_SEG.NS_SECTOR	;PAGE NUMBER OF SEGMENT
		XOR	CX,CX
		OR	DX,DX
		JZ	511$

		MOV	BX,LA_FILE_HANDLE
		MOV	AX,[DI].NEW_EXE.NE_ALIGN	;SHIFT PAGE NUMBER BY NE_ALIGN BITS
		OR	AX,AX
		JZ	42$
41$:
		ADD	DX,DX
		ADC	CX,CX
		DEC	AX
		JNZ	41$				;CX:DX IS POSITION
42$:

;		DEBMSG	'Disk SEEK - CX',CX
;		DEBMSG	'Disk SEEK - DX',DX
;		DEBMSG	'Disk SEEK - BX',BX

		;
		;SEEK TO 512 BOUNDARY <= CX:DX
		;

		MOV	AX,DX
		AND	DX,NOT 511
		AND	AX,511
		MOV	PRE_DELTA,AX			;# UNNEEDED BYTES

		MOV	AX,4200H
		CALL	_DOS3CALL
		PUSH	DS
		JC	LOAD_DISK_ERROR			;POSITION SHOULD NEVER FAIL...

		MOV	CX,[SI].NEW_SEG.NS_CBSEG	;BYTES IN FILE
		ADD	CX,PRE_DELTA
		MOV	AX,512
		SUB	AX,CX
		AND	AX,511
		MOV	POST_DELTA,AX
		ADD	CX,AX				;READ EVEN 512-BYTE SECTORS

;		TEST	[SI].NEW_SEG.NS_FLAGS,NSITER
;		JZ	5$
		MOV	DS,TEMP_SEGMENT
		CALL	DO_READ
		JC	LOAD_DISK_ERROR
		MOV	ES,SEG_SELECTOR
		MOV	BX,PRE_DELTA			;SKIP THIS MANY BYTES
		CALL	DECOMPRESS
;		JMP	51$

;5$:
;		MOV	DS,SEG_SELECTOR
;		CALL	DO_READ
;		JC	LOAD_DISK_ERROR
51$:
		;
		;CX IS NUMBER OF BYTES INITIALIZED
		;
		POP	DS
511$:
		MOV	AX,[SI].NEW_SEG.NS_MINALLOC
		MOV	ES,SEG_SELECTOR
		SUB	AX,CX
		MOV	DI,CX
		MOV	CX,AX
		JNZ	53$
		;
		;IF NONE WERE READ, WE ZERO FILL 64K...
		;
		CMP	[SI].NEW_SEG.NS_SECTOR,0
		JNZ	6$			;COMPLETELY INITIALIZED, SKIP ZEROING
		XOR	AX,AX
		STOSB
		DEC	CX
53$:
;		DEBMSG	'Zero Fill'

		XOR	AX,AX
		TEST	DI,1
		JZ	52$
		STOSB
		DEC	CX
52$:
		SHR	CX,1
		REP	STOSW
		ADC	CX,CX
		REP	STOSB
6$:
;		TEST	[SI].NEW_SEG.NS_FLAGS,NSRELOC
		OR	DX,DX
		JZ	7$
		CALL	PROCESS_RELOCS
		JNC	65$
		JMP	LOAD_DISK_ERROR1

65$:
;		DEBMSG	'RELOCS APPLIED'
7$:
		OR	BPTR [SI].NEW_SEG.NS_FLAGS,NSLOADED
		TEST	BPTR [SI].NEW_SEG.NS_FLAGS,NSDATA
		JNZ	8$
		PUSH	SEG_HANDLE
		CALL	_PATCHCODEHANDLE
8$:
		;
		;IF CODE OR READ-ONLY, NEED TO ADJUST ACCESS RIGHTS AGAIN...
		;
		MOV	AX,[SI].NEW_SEG.NS_FLAGS
iff	keep_read_only
		AND	AL,NOT NSERONLY		;IGNORE E/O R/O BIT
else
		TEST	AL,NSERONLY
		JNZ	81$
endif
		TEST	AL,NSDATA
		JNZ	89$
81$:
		PUSH	AX
		PUSHM	SEG_SELECTOR,0,0
		CALL	_SELECTORACCESSRIGHTS
		POP	BX
		AND	AL,0F1H
if	keep_read_only
		TEST	BL,NSERONLY
		JNZ	82$
endif
		OR	AL,2
82$:
		TEST	BL,NSDATA
		JNZ	83$
		OR	AL,8			;CODE
83$:
		PUSHM	SEG_SELECTOR,1,AX
		CALL	_SELECTORACCESSRIGHTS
89$:
		;
		;LOAD SUCCESS, RETURN HANDLE AND SELECTOR
		;
		MOV	AX,SEG_SELECTOR
		MOV	DX,SEG_HANDLE
LOAD_END:
		PUSHM	DX,AX
		MOV	BX,TEMP_HANDLE
		OR	BX,BX
		JZ	NO_TEMP_TEMP
;		DEBMSG	'Release TEMP Segment'

		PUSH	BX
		CALL	_GLOBALFREE
NO_TEMP_TEMP:
		MOV	BX,TEMP_DOS_SEGMENT
		OR	BX,BX
		JZ	NO_TEMP_DOS
		PUSH	BX
		CALL	_GLOBALDOSFREE
NO_TEMP_DOS:
		POPM	AX,DX

		DEBMSG	'LOADAPPSEG Complete'
		;
		;AX == SEGMENT, DX == HANDLE
		;
		POPM	DI,SI,DS
		MOV	SP,BP
		POP	BP
		RET	6

LOADAPPSEG	ENDP


DO_READ		PROC	NEAR
		;
		;CX IS # OF BYTES TO READ
		;
		;RETURN CX == BYTES READ
		;
;		DEBMSG	'DO_READ'
		PUSH	CX
		XOR	DX,DX
		OR	CX,CX
		MOV	BX,LA_FILE_HANDLE
		MOV	AH,3FH
		JZ	5$
4$:
		CALL	_DOS3CALL
		JC	9$				;HANDLE OR HARDWARE ERROR
		CMP	AX,CX
		JNE	8$				;END-OF-FILE
9$:
		POP	CX
		RET

8$:
		SUB	AX,CX
		NEG	AX
		CMP	POST_DELTA,AX			;OFF BY MORE THAN POST_DELTA?
		JAE	9$				;DON'T NEED THOSE ANYWAY...
		STC
		POP	CX
		RET

5$:
		MOV	CH,80H
		CALL	_DOS3CALL
		JC	9$				;HANDLE OR HARDWARE ERROR
		CMP	AX,CX
		JNE	8$				;END-OF-FILE
		MOV	DX,CX
		MOV	AH,3FH
		JMP	4$

DO_READ		ENDP


DECOMPRESS	PROC	NEAR
		;
		;DS IS SOURCE SEGMENT, ES IS TARGET SEGMENT
		;CX IS SOURCE BYTE-COUNT - FILE-SIZE
		;BX IS SOURCE OFFSET TO START WITH
		;
		;RETURN CX IS BYTES EXPANDED
		;	BX IS OFFSET TO RELOCS
		;	DX IS # OF RELOCS
		;
		PUSHM	BP,SI,DI
		MOV	BP,CX
		MOV	SI,BX
		XOR	DI,DI
IF 0
		CMP	WPTR [SI],0
		JZ	8$
1$:
		SUB	BP,4		;ARE THERE 4 BYTES LEFT
		JBE	9$
		MOV	CX,[SI]		;REPEAT COUNT
		MOV	DX,2[SI]	;BYTES TO BE REPEATED
		ADD	SI,4
		SUB	BP,DX
		JB	9$
		MOV	AX,[SI]
		CMP	DX,2
		JA	5$
		JZ	3$
		MOV	AH,AL
		SHR	CX,1
		JNC	3$
		STOSB
3$:
		REP	STOSW
		ADD	SI,DX
		JMP	1$

5$:
		;
		;DX IS # OF BYTES
		;CX IS # OF TIMES TO REPEAT
		;
		MOV	BX,CX
6$:
		MOV	CX,DX
		SHR	CX,1
		REP	MOVSW
		ADC	CX,CX
		REP	MOVSB
		SUB	SI,DX
		DEC	BX
		JNZ	6$
		ADD	SI,DX
		JMP	1$

8$:
ENDIF
		LODSW
		PUSH	AX
		CALL	DPMI_UNQUIK
;9$:
		POPM	DX
		MOV	BX,SI
		MOV	CX,DI
		POPM	DI,SI,BP
		RET


;
;		LEA	DX,NOEXEPACK_ERR
;		JMP	MSG_ABORT

DECOMPRESS	ENDP


FREE_CSALIAS_AX	PROC	NEAR
		;
		;
		;
		PUSH	AX
		CALL	_FREESELECTOR
		RET

FREE_CSALIAS_AX	ENDP


PROCESS_RELOCS	PROC	NEAR
		;
		;FIRST, READ WORD DEFINING # OF RELOCS
		;
		PUSHM	DS,SI,DI
;		DEBMSG	'Apply Relocs'

		MOV	DS,TEMP_SEGMENT
		MOV	SI,BX
		MOV	RELOC_STACK,SP
1$:
		;
		;SET UP START OF A NEW RELOC PACKET
		;
		LODSW
		XOR	CH,CH
if	BOX
		XOR	AX,-1
endif
		MOV	CL,AH			;# OF ITEMS IN THIS PACKET
;		DEBMSG	'Items this packet',CX
		SUB	DX,CX
		JC	RELOC_ERR1
;		DEBMSG	'Items after this packet',DX

		PUSH	DX			;OVERALL # OF RELOCS AFTER THIS PACKET

		CMP	AL,0F0H			;SPECIAL BASE TYPES
		JZ	3$
		;
		;DEFINE TARGET ROUTINE
		;
		MOV	BL,AL
		AND	BX,7
		ADD	BX,BX
		MOV	BX,TARG_TYPE_TBL[BX]
		MOV	TARG_RTN,BX
		;
		;JUMP TO SOURCE ROUTINE
		;
		MOV	BL,AL
		SHR	BX,2
		AND	BX,6
		JMP	SOURCE_TYPE_TBL[BX]	;INTERNAL, IMPORT, FLOAT

RELOC_ERR1:
		DEBMSG	'RELOC COUNT FAIL'
		JMP	RELOC_ERR9

3$:
		;
		;SPECIAL BASE TYPE, CX IS # OF THEM
		;
		MOV	AL,[SI]
		MOV	DI,1[SI]
		ADD	SI,3
		CALL	SEG_AL_SELECTOR_ESBX	;CHANGE AL TO SELECTOR IN AX, DESTROYS BX
		MOV	ES,SEG_SELECTOR
		MOV	DX,AX
		CALL	RELOC_INT_OFF16
		DEC	CX
		JNZ	3$
RELOC_NEXT:
		POP	DX
		OR	DX,DX
		JNZ	1$
RELOC_DONE:
		POPM	DI,SI,DS
		RET

OSTYPE_ABORT:
		;
		;FLOAT TYPES ARE LAST, WE ARE DONE
		;
		POPM	DX,DI,SI,DS
		RET


RELOC_SRC_INTERNAL:
		;
		;SOURCE IS INTERNAL, RARE UNLESS IOPL...
		;
		LODSB
		CMP	AL,-1
		JNZ	RELOC_SRC_INT_FIXED
RELOC_SRC_INT_MOVABLE:
		;
		;WORKS PRETTY MUCH LIKE IMPORT BY ORDINAL
		;
		MOV	AX,EXE_SELECTOR
		JMP	RSO_1


RELOC_SRC_INT_FIXED:
		;
		;THESE SHOULD HAVE ALL CHANGED INTO SPECIAL BASE FIXUPPS
		;

		CALL	SEG_AL_SELECTOR_ESBX	;RETURN SELECTOR IN AX

		MOV	ES,SEG_SELECTOR
		MOV	BX,AX
RSI_1:
		MOV	DI,[SI]
		MOV	DX,2[SI]
		ADD	SI,4
		PUSH	CX
		CALL	TARG_RTN
		POP	CX
		DEC	CX
		JNZ	RSI_1
		JMP	RELOC_NEXT


RELOC_SRC_ORDINAL:
		;
		;IMPORTING BY ORDINAL
		;
		LODSW
		MOV	MODULE_NUMBER,AX
		MOV	ES,EXE_SELECTOR
		DEC	AX
		MOV	BX,ES:NEW_EXE.NE_MODTAB
		ADD	AX,AX
		ADD	BX,AX
		MOV	AX,ES:[BX]	;MODULE HANDLE
RSO_1:
		MOV	DI,[SI]		;OFFSET TO MODIFY
		MOV	DX,2[SI]	;ORDINAL #
		ADD	SI,4
		PUSHM	AX,CX		;PRESERVE FOR LOOPING

		PUSHM	AX,DX
		CALL	GETENTRY	;RETURNS DX:AX IS IMPORT ADDRESS

		MOV	ES,SEG_SELECTOR
		MOV	BX,DX
		MOV	DX,AX
		OR	BX,BX
		JZ	RSO_ERR
		CALL	TARG_RTN

		POPM	CX,AX
		LOOP	RSO_1
		JMP	RELOC_NEXT

RSO_ERR:
		DEBMSG	'Reloc Failure, Module',MODULE_NUMBER
		DEBMSG	'Reloc Failure, Ordinal',<-2[SI]>
		JMP	RELOC_ERR9

RSN_ERR:
		DEBMSG	'Reloc Failure, Module',MODULE_NUMBER
		DEBMSG	'Reloc Failure, By Name',DI
		JMP	RELOC_ERR9

RELOC_ERR:
		DEBMSG	'RELOC CHAIN FAILED'
RELOC_ERR9:
		MOV	SP,RELOC_STACK
		STC
		JMP	RELOC_DONE


RELOC_SRC_NAME:
		;
		;IMPORTING BY NAME
		;
		;
		;MUST MAKE IMPORTED NAME LOOK LIKE ZERO-TERMINATED STRING...
		;
;		DEBMSG	'IMPORT-BY-NAME',TARG_RTN

		LODSW
		MOV	MODULE_NUMBER,AX
		MOV	ES,EXE_SELECTOR
		DEC	AX
		MOV	BX,ES:NEW_EXE.NE_MODTAB
		ADD	AX,AX
		ADD	BX,AX
		MOV	AX,ES:[BX]			;HANDLE OF MODULE WE REFERENCE
RSN_1:
		PUSHM	AX,CX
		MOV	ES,EXE_SELECTOR
		MOV	BX,2[SI]			;OFFSET INTO IMPORTED NAMES TABLE
		ADD	BX,ES:NEW_EXE.NE_IMPTAB		;ADDRESS OF IMPORTED NAMES TABLE == OFFSET TO NAME

		XOR	CH,CH
		MOV	CL,ES:[BX]			;LENGTH OF STRING
		INC	BX
		MOV	DI,BX				;NAME TEXT
		ADD	DI,CX
		XCHG	CH,ES:[DI]			;NUL TERMINATE, SAVE OLD
		PUSHM	ES,CX
		
		PUSHM	AX,ES,BX
		CALL	_GETPROCADDRESS			;RETURNS DX:AX

		POPM	CX,ES
		MOV	BX,DX
		MOV	ES:[DI],CH
		MOV	DX,AX
		OR	BX,BX
		JZ	RSN_ERR
		MOV	DI,[SI]
		ADD	SI,4
		MOV	ES,SEG_SELECTOR
		CALL	TARG_RTN

		POPM	CX,AX
		LOOP	RSN_1

		JMP	RELOC_NEXT

RELOC_SRC_OSFLOAT:
		;
		;FLOATING POINT FIXUPPS
		;
		LODSW
		XOR	AH,AH
		MOV	BX,AX
		SHL	BX,2
		MOV	ES,SEG_SELECTOR
		MOV	DX,X87[BX-4]
		MOV	BX,X87[BX-2]
RS_OSF_1:
		LODSW
		MOV	DI,AX
		ADD	ES:[DI],DX
		ADD	ES:[DI+1],BX
		LOOP	RS_OSF_1

		JMP	RELOC_NEXT


RELOC_INT_BYTE:
		MOV	ES:[DI],DL
		RET

RELOC_INT_BYTE_A:
		ADD	ES:[DI],DL
		RET

RELOC_INT_SEG16:
		MOV	DX,BX
RELOC_INT_OFF16:
		XOR	BX,BX
		INC	DI
RIO_16:
		MOV	AX,DX
		XCHG	ES:[DI-1],AX
		DEC	BX
		MOV	DI,AX
		JZ	RI_ERR
		INC	DI
		JNZ	RIO_16
		RET

RI_ERR:
		JMP	RELOC_ERR


RELOC_INT_SEG16_A:
		MOV	DX,BX
RELOC_INT_OFF16_A:
		ADD	ES:[DI],DX
		RET

RELOC_INT_PTR16:
		XOR	CX,CX
		INC	DI
RIO_32:
		MOV	AX,DX
		XCHG	ES:[DI-1],AX
		MOV	ES:[DI+1],BX
		DEC	CX
		MOV	DI,AX
		JZ	RI_ERR
		INC	DI
		JNZ	RIO_32
		RET

RELOC_INT_PTR16_A:
		ADD	ES:[DI],DX
		ADD	ES:2[DI],BX
		RET


		EVEN

X87		DW	FIARQQ,FJARQQ
		DW	FISRQQ,FJSRQQ
		DW	FICRQQ,FJCRQQ
		DW	FIERQQ,0
		DW	FIDRQQ,0

SOURCE_TYPE_TBL	LABEL	WORD

		DW	RELOC_SRC_INTERNAL
		DW	RELOC_SRC_ORDINAL
		DW	RELOC_SRC_NAME
RELOC_OSTYPE_TBL DW	RELOC_SRC_OSFLOAT

		EVEN
TARG_TYPE_TBL	DW	RELOC_INT_BYTE
		DW	RELOC_INT_SEG16
		DW	RELOC_INT_PTR16
		DW	RELOC_INT_OFF16
		DW	RELOC_INT_BYTE_A
		DW	RELOC_INT_SEG16_A
		DW	RELOC_INT_PTR16_A
		DW	RELOC_INT_OFF16_A

PROCESS_RELOCS	ENDP

SEG_AL_SELECTOR_ESBX	PROC	NEAR
		;
		;
		;
		XOR	AH,AH
		DEC	AX			;ZERO BASE, TIMES 10
		MOV	ES,EXE_SELECTOR
		ADD	AX,AX
		MOV	BX,AX
		SHL	AX,2
		ADD	BX,AX
		ADD	BX,ES:NEW_EXE.NE_SEGTAB
		MOV	AX,ES:[BX].NEW_SEG1.NS_HANDLE
		MOV	BX,CS
		AND	AX,0FFFCH
		AND	BX,3
		OR	AX,BX
		RET

SEG_AL_SELECTOR_ESBX	ENDP

IF 0

PROCESS_RELOCS	PROC	NEAR
		;
		;FIRST, READ WORD DEFINING # OF RELOCS
		;
		PUSHM	DS,SI,DI
		MOV	DS,TEMP_SEGMENT
;		MOV	CX,2
;		CALL	DO_READ
;		JC	RI_ERR0
;		MOV	AX,DS:0
		MOV	ES,SEG_SELECTOR
		MOV	RELOC_COUNT,DX
		MOV	SI,BX
		;
		;NOW, READ IN MULTIPLES OF 64K OF RELOC INFO...
		;
1$:
		MOV	CX,RELOC_COUNT		;# OF RELOCS LEFT THIS SEGMENT

;		DEBMSG	'Relocs',CX

;		OR	CX,CX
;		JZ	9$
;		CMP	CX,8*1024		;# OF RELOCS MAX PER BUFFER
;		JB	2$
;		MOV	CX,8*1024
2$:
;		PUSH	CX
;		SUB	RELOC_COUNT,CX
;		SHL	CX,3			;# OF RELOCS * 8 BYTES PER RELOC

;		CALL	DO_READ
;		POP	CX
;		JC	RI_ERR0
;		XOR	SI,SI
3$:
		PUSHM	DS,SI
		MOV	BX,[SI]			;RELOC TYPE
		MOV	DI,2[SI]		;OFFSET FROM ES
		MOV	DX,6[SI]		;TARGET OFFSET
		MOV	AX,4[SI]		;TARGET SEGMENT

;		DEBMSG	'RELOC Offset',DI

		MOV	SI,BX
		MOV	BL,BH
		AND	BX,NRRTYP
		SHL	BX,1
		MOV	DS,EXE_SELECTOR
		JMP	RELOC_TYPE_TBL[BX]

RELOC_TYPE_INTERNAL_MOVABLE:
		;
		;NEED TO SET UP GETENTRY
		;
		PUSHM	ES,CX
		PUSHM	DS,DX				;MODULE IS ME, ENTRY IS DX
		JMP	RTO

RELOC_TYPE_INTERNAL:
		;
		;
		;
		CMP	AL,0FFH
		JZ	RELOC_TYPE_INTERNAL_MOVABLE
		XOR	AH,AH
		DEC	AX			;ZERO BASE, TIMES 10
		ADD	AX,AX
		MOV	BX,AX
		SHL	AX,2
		ADD	BX,AX
		ADD	BX,DS:NEW_EXE.NE_SEGTAB
		MOV	AX,[BX].NEW_SEG1.NS_HANDLE
		MOV	BX,CS
		AND	AX,0FFFCH
		AND	BX,3
		OR	BX,AX
DO_RELOC_INT:
		;
		;BX:DX IS TARGET ITEM
		;
		MOV	AX,SI
		AND	AX,0400H
		SHR	AX,6
		AND	SI,0FH
		OR	SI,AX
		SHL	SI,1
		JMP	INT_TBL[SI]

RELOC_NEXT:
		POPM	SI,DS
		DEC	CX
		LEA	SI,8[SI]
		JNZ	3$
;		JMP	1$

9$:
		POP	DI
		POPM	SI,DS
		RET

OSTYPE_ABORT:
		ADD	SP,4
		JMP	9$

RI_ERR:
		POPM	SI,DS
RI_ERR0:
		DEBMSG	'RELOCS FAILED'
		STC
		JMP	9$

RELOC_INT_BYTE:
		MOV	ES:[DI],DL
		JMP	RELOC_NEXT

RELOC_INT_BYTE_A:
		ADD	ES:[DI],DL
		JMP	RELOC_NEXT

RELOC_INT_SEG16:
		MOV	DX,BX
RELOC_INT_OFF16:
		XOR	BX,BX
		INC	DI
RIO_16:
		MOV	AX,DX
		XCHG	ES:[DI-1],AX
		DEC	BX
		MOV	DI,AX
		JZ	RI_ERR
		INC	DI
		JNZ	RIO_16
		JMP	RELOC_NEXT

RELOC_INT_SEG16_A:
		MOV	DX,BX
RELOC_INT_OFF16_A:
		ADD	ES:[DI],DX
		JMP	RELOC_NEXT

RELOC_INT_PTR16:
		XOR	SI,SI
		INC	DI
RIO_32:
		MOV	AX,DX
		XCHG	ES:[DI-1],AX
		MOV	ES:[DI+1],BX
		DEC	SI
		MOV	DI,AX
		JZ	RI_ERR
		INC	DI
		JNZ	RIO_32
		JMP	RELOC_NEXT

RELOC_INT_PTR16_A:
		ADD	ES:[DI],DX
		ADD	ES:2[DI],BX
		JMP	RELOC_NEXT

RELOC_TYPE_ORDINAL:
		;
		;IMPORTING BY ORDINAL
		;
		;SI IS TYPE-FLAGS
		;AX IS MODULE
		;DX IS ORDINAL #
		;DI IS DESTINATION
		;BX IS AVAILABLE
		;
		DEC	AX
		MOV	BX,DS:NEW_EXE.NE_MODTAB
		ADD	AX,AX
		ADD	BX,AX
		PUSHM	ES,CX
		PUSHM	DS:[BX],DX
RTO:
		CALL	GETENTRY
RTO_1:
		POPM	CX,ES
		MOV	BX,DX
		MOV	DX,AX
		OR	AX,BX
		JNZ	DO_RELOC_INT
		JMP	RI_ERR

RELOC_TYPE_NAME:
		;
		;IMPORTING BY NAME
		;
		;SI IS TYPE-FLAGS
		;AX IS MODULE
		;DX IS NAME OFFSET
		;DI IS DESTINATION
		;BX IS AVAILABLE
		;
		;MUST MAKE IMPORTED NAME LOOK LIKE ZERO-TERMINATED STRING...
		;
		DEC	AX
		MOV	BX,DS:NEW_EXE.NE_MODTAB
		ADD	AX,AX
		ADD	BX,AX
		PUSHM	ES,CX,DI
		MOV	AX,[BX]				;HANDLE OF MODULE WE REFERENCE
		MOV	BX,DS:NEW_EXE.NE_IMPTAB		;ADDRESS OF IMPORTED NAMES TABLE
		ADD	BX,DX
		XOR	CH,CH
		MOV	CL,[BX]				;LENGTH OF STRING
		INC	BX
		MOV	DI,BX
		ADD	DI,CX
		XCHG	CH,[DI]
		PUSH	CX
		
		PUSHM	AX,DS,BX
		CALL	_GETPROCADDRESS			;RETURNS DX:AX
		POP	CX
		MOV	[DI],CH
		POP	DI
		JMP	RTO_1

RELOC_TYPE_OSFLOAT:
		;
		;FLOATING POINT FIXUPPS
		;
;		CMP	AX,6
;		JZ	OSFLOAT_6			;TYPE 6 ALWAYS
;		JA	RI_ERR				;BIGGER FAILS
		MOV	BX,AX
;		MOV	AL,X87PRESENT
		ADD	BX,BX
;		OR	AL,AL
;		JNZ	RELOC_NEXT
		CMP	AX,6
		JAE	RI_ERR
		JMP	X87[BX]

;OSFLOAT_6:
;		ADD	WPTR ES:[DI],FIWRQQ
;		JMP	RELOC_NEXT


OSFLOAT_1:
		ADD	WPTR ES:[DI],FIARQQ
		ADD	WPTR ES:[DI+1],FJARQQ
		JMP	RELOC_NEXT

OSFLOAT_2:
		ADD	WPTR ES:[DI],FISRQQ
		ADD	WPTR ES:[DI+1],FJSRQQ
		JMP	RELOC_NEXT

OSFLOAT_3:
		ADD	WPTR ES:[DI],FICRQQ
		ADD	WPTR ES:[DI+1],FJCRQQ
		JMP	RELOC_NEXT

OSFLOAT_4:
		ADD	WPTR ES:[DI],FIERQQ
		JMP	RELOC_NEXT

OSFLOAT_5:
		ADD	WPTR ES:[DI],FIDRQQ
		JMP	RELOC_NEXT

		EVEN
X87		DW	RI_ERR
		DW	OSFLOAT_1
		DW	OSFLOAT_2
		DW	OSFLOAT_3
		DW	OSFLOAT_4
		DW	OSFLOAT_5

RELOC_TYPE_TBL	LABEL	WORD

		DW	RELOC_TYPE_INTERNAL
		DW	RELOC_TYPE_ORDINAL
		DW	RELOC_TYPE_NAME
RELOC_OSTYPE_TBL DW	RELOC_TYPE_OSFLOAT

		EVEN
INT_TBL		DW	RELOC_INT_BYTE
		DW	RI_ERR
		DW	RELOC_INT_SEG16
		DW	RELOC_INT_PTR16
		DW	RI_ERR
		DW	RELOC_INT_OFF16
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RELOC_INT_BYTE_A
		DW	RI_ERR
		DW	RELOC_INT_SEG16_A
		DW	RELOC_INT_PTR16_A
		DW	RI_ERR
		DW	RELOC_INT_OFF16_A
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR
		DW	RI_ERR

PROCESS_RELOCS	ENDP

ENDIF

if	debug

HEXWOUT		PROC	NEAR
		;
		;PRINT AX
		;
		PUSH	AX
		MOV	AL,AH
		CALL	HEXOUT
		POP	AX
HEXOUT:
		PUSH	AX
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		CALL	HEXNIB
		POP	AX
HEXNIB:
		AND	AL,0FH
		OR	AL,30H
		CMP	AL,'9'
		JBE	HEX_OK
		ADD	AL,7
HEX_OK:
		STOSB
		RET

HEXWOUT		ENDP

endif

INIT_SYSCALLS	PROC	NEAR
		;
		;INITIALIZE SYSTEM-CALL JMP TABLE
		;	'KERNEL'  IS MODULE#1
		;	'USER' IS MODULE#2
		;
		;	AX IS EXE_SELECTOR
		;	DS & ES ARE CS ALIASES
		;
		PUSH	DS
		MOV	DS,AX
		LEA	SI,RTBL
		LEA	DI,GTBL
		MOV	BX,DS:NEW_EXE.NE_MODTAB
		POP	DS
1$:
		PUSH	AX			;AX IS EXETABLE
		PUSH	DS			;DS IS CS ALIAS
		MOV	DS,AX
		MOV	CX,DS:[BX]		;NEXT MODULE HANDLE
		INC	BX
		INC	BX
		POP	DS
		PUSH	BX
		JMP	4$

2$:
		XOR	AH,AH
		PUSHM	ES,CX

		PUSHM	CX,AX
		CALL	GETENTRY

		POPM	CX,ES
		STOSW
		MOV	AX,DX
		STOSW
4$:
		LODSB				;ANY MORE THIS MODULE?
		OR	AL,AL
		JNZ	2$
5$:
		CMP	[SI],AL			;ANY MORE MODULES?
		POPM	BX,AX
		JNZ	1$
8$:
		RET

INIT_SYSCALLS	ENDP


LOADERRMSG	DB	"OPTLOAD -- Error loading module", 0
CANTOPEN_MSG	DB	"OPTLOAD -- Cannot Open",0

if	debug
PROGRESS_MSG	DB	"OPTLOAD for Windows",0
endif

RTBL		DB	15,16,17,18,49,50,102,110,132,176,184,185,196,0
RTBL2		DB	1,0
		DB	0

GLOBALDOS_FAILED	DB	0
PRELOADS_DONE		DB	0

		EVEN	?

GTBL		LABEL	DWORD

		NMD	GLOBALALLOC		;KERNEL.15		;THESE ARE NOW JUST DD'S
		NMD	GLOBALREALLOC		;KERNEL.16
		NMD	GLOBALFREE		;KERNEL.17
		NMD	GLOBALLOCK		;KERNEL.18
		NMD	GETMODULEFILENAME	;KERNEL.49
		NMD	GETPROCADDRESS		;KERNEL.50
		NMD	DOS3CALL		;KERNEL.102
		NMD	PATCHCODEHANDLE		;KERNEL.110
		NMD	GETWINFLAGS		;KERNEL.132
		NMD	FREESELECTOR		;KERNEL.176
		NMD	GLOBALDOSALLOC		;KERNEL.184
		NMD	GLOBALDOSFREE		;KERNEL.185
		NMD	SELECTORACCESSRIGHTS	;KERNEL.196
		NMD	MESSAGEBOX		;USER.1

MASTER_TEMP_HANDLE	DW	0
MASTER_TEMP_SEGMENT	DW	0
MAX_SEGSZ_FILE	DW	0		;MAX SIZE OF SEGMENT IN FILE (IN BYTES), ROUNDED FOR 512 ALIGNMENT
DGROUP_SEGNO	DW	0
ME_ASCIZ	DD	0

ME_ASCIZ_TEXT	DB	260 DUP(0)

BOOTAPP_END	LABEL	BYTE

endif

LOADER___SLRLOAD	ENDS

		END

