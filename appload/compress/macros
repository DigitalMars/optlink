.xlist
	page	,127

%		.MODEL	MYMODEL

debug			EQU	0-1

ifndef	J
J	equ	0
endif

K		EQU	*1024
k		EQU	*1024

TEMP_RECORD_SIZE	EQU	16K


fg_td		=	-1
fg_cfg		=	-1

if	_PRODUCT	EQ	3	;OPTLINK FOR DOS

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	0
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	0

else if	_PRODUCT EQ 5	;OS2LINK FOR DOS

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	-1
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	-1		;HAS A DEF FILE
fg_slrpack	EQU	0
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	-1
fg_winpack	EQU	0
fg_dospack	EQU	0

else if _PRODUCT EQ 7

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	-1		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	-1

else if _PRODUCT EQ 9

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	-1		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	-1
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	-1

else if _PRODUCT EQ 10			;OPTIMP

fg_td		=	0
fg_cfg		=	0

fg_xref		EQU	0
fg_cv		EQU	0
fg_segm		EQU	0
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	-1		;HAS A DEF FILE
fg_slrpack	EQU	0
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	-1
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	0

else if _PRODUCT EQ 12			;WINPACK

fg_xref		EQU	-1
fg_cv		EQU	-1
fg_segm		EQU	-1
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	-1		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	0
fg_mscmd	EQU	-1
fg_implib	EQU	0
fg_phar		EQU	-1
fg_winpack	EQU	-1
fg_dospack	EQU	0

else if _PRODUCT EQ 13			;WINPACK

fg_xref		EQU	0
fg_cv		EQU	0
fg_segm		EQU	-1
fg_ai		EQU	0
fg_rat		EQU	0
fg_ov		EQU	0		;SINGLE-LEVEL OVERLAYS
fg_rom		EQU	0		;ROM-LINK
fg_def		EQU	0		;HAS A DEF FILE
fg_slrpack	EQU	-1
fg_plink	EQU	0
fg_mscmd	EQU	0
fg_implib	EQU	0
fg_phar		EQU	0
fg_winpack	EQU	0
fg_dospack	EQU	-1

endif

% ifidni	<HOST_OS>,<OS2>

fgh_os2		EQU	-1
fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
FF_COUNT	EQU	10
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2

% else ifidni	<HOST_OS>,<DPMI>

.286P

fgh_os2		EQU	0
fgh_prot	EQU	-1
fgh_dpmi	EQU	-1
fgh_win		EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2

% else ifidni	<HOST_OS>,<WIN>

.286P

fgh_os2		EQU	0
fgh_prot	EQU	-1
fgh_dpmi	EQU	0
fgh_win		EQU	-1
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2

else if _PRODUCT EQ 13

.286P

fgh_os2		EQU	0
fgh_prot	EQU	0
fgh_dpmi	EQU	0
fgh_win		EQU	0
fg_virt		EQU	0
fg_sym_virt	EQU	0
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2


else

fgh_os2		EQU	0
fgh_prot	EQU	0
fgh_dpmi	EQU	0
fgh_win		EQU	0
fg_virt		EQU	-1
fg_sym_virt	EQU	-1
if	fg_implib
page_size	EQU	16K
PAGE_SIZE	EQU	16K
PAGE_SHIFT	EQU	2
else
page_size	EQU	8K
PAGE_SIZE	EQU	8K
PAGE_SHIFT	EQU	3
endif

endif

if	fg_dospack

fg_hufpack	EQU	0

else

fg_hufpack	EQU	0

endif

if	PAGE_SIZE EQ 16K

PAGE_POWER	EQU	14

else

PAGE_POWER	EQU	13

endif

INBUF_LEN		EQU	256
SYMBOL_TEXT_SIZE	EQU	256
NFN_TEXT_SIZE		EQU	256

INDIRECT_NEST_LIMIT	EQU	10

NEW_FIXUPP_SIZE		EQU	1K

CV_TEMP_SIZE		EQU	1K
TEMP_SIZE		EQU	1K

FILENAME_HASH_SIZE	EQU	0FBH
THEADR_HASH_SIZE	EQU	61
VIRDEF_MCD_HASH_SIZE	EQU	0FBH

CASE_SENSITIVE	EQU	0
MAX_RECORD_LEN	EQU	1024+64+6K	;FOR BORLAND
SLRIB		EQU	0		;NOT OPTLIB
OPTLIB		EQU	0

MAX_LEDATA_LEN	EQU	2K

BLOCK_BASE	EQU	2		;STARTING OFFSET FOR FAR BLOCKS (FIRST WORD IS USAGE COUNT)
					;**** FARCALLTRANSLATE MAY NOT HANDLE CHANGE CORECTLY ****

EMS_XMS_DELTA	EQU	1K/(PAGE_SIZE/(1K))*2

N_R_THREADS	EQU	4		;# OF OPEN-READ THREADS
N_W_THREADS	EQU	2

;PHYS_TABLE_SIZE EQU	4		;# OF 16K BLOCKS RELEASED LOCALLY OS/2

;MAX_VECTORS	EQU	32K/VECTOR_SIZE*2

	.EN	UG,JB
	.DS	CJ

M1	EQU	-1

ifndef		_RT

_RT	EQU	<0>

endif
ifndef	_AI

_AI	EQU	<0>

endif

% ifidni	<MYMODEL>,<SMALL>

DCA		EQU	DW
EXTCA		EQU	EXTW
@@CODESIZE	EQU	WORD
FILEPARSE_TEXT	EQU	<>
ROOT_TEXT	EQU	<>
PASS1_TEXT	EQU	<>
MIDDLE_TEXT	EQU	<>
PASS2_TEXT	EQU	<>
STARTUP_TEXT	EQU	<>
PHASE1_TEXT	EQU	<>

else

DCA		EQU	DD
EXTCA		EQU	EXTD
@@CODESIZE	EQU	DWORD

endif

;FG_VIRT 	EQU	_VM*M1		;VIRTUAL MEMORY
;FG_XREF 	EQU	_XR*M1		;CROSS REFERENCE
;FG_CV		EQU	_CV*M1		;CODEVIEW SUPPORT
;FG_SYM_VIRT	EQU	_VM*M1		;SYMBOLS VIRTUAL
;FG_SEGM 	EQU	_SG*M1		;SEGMENTED EXE
;FG_AI		EQU	_AI*M1		;AI ARCHITECTS
;FG_RAT		EQU	_RT*M1		;RATIONAL
;FG_OV		EQU	_O1*M1		;SINGLE LEVEL OVERLAYS
;FG_OS2		EQU	_O2*M1		;OS2 HOST
;FG_ROM		EQU	_RM*M1		;OPTLOC
;FG_DEF		EQU	_DF*M1		;.DEF FILE
;FG_SLRPACK	EQU	_SP*M1		;SLR LZW PACKING
;FG_PLINK	EQU	_PL*M1		;PLINK COMPATIBLE
;FG_MSCMD	EQU	_MS*M1		;MS CMDLINE SUPPORT
;
;FG_IMPLIB	EQU	0

;FG_PHAR 	EQU	0

if	fgh_os2

	.286P

	SOFT	EXTF	DOSREAD,DOSWRITE,DOSCHGFILEPTR,DOSOPEN,DOSNEWSIZE,DOSREALLOCSEG,DOSSETSIGHANDLER
	SOFT	EXTF	DOSEXIT,DOSCLOSE,DOSSEMCLEAR,DOSSEMSET,DOSSEMWAIT
	SOFT	EXTF	DOSSEMREQUEST,DOSENTERCRITSEC,DOSEXITCRITSEC
	SOFT	EXTF	DOSFREESEG,DOSSETPRTY,DOSALLOCSEG,DOSCREATETHREAD
	SOFT	EXTF	DOSQCURDISK,DOSDELETE,DOSFINDFIRST,DOSFINDNEXT
	SOFT	EXTF	DOSQFILEINFO,DOSSETFILEINFO,DOSSLEEP,DOSSETMAXFH

endif

if	fgh_win

	.286P

	SOFT	EXTF	INITAPP,INITTASK,GLOBALALLOC,GLOBALLOCK,GLOBALHANDLE,GLOBALFREE,WAITEVENT,DOS3CALL

endif

	PUBLIC	fg_ov,fgh_os2,fg_virt,fg_xref,fg_sym_virt,fg_cv,fg_def,fg_rom,fg_implib
	PUBLIC	fg_segm,fg_ai,fg_rat,fg_slrpack,fg_plink,fg_mscmd,fgh_dpmi,fg_td,fg_cfg

fg_prot 		EQU	(fg_segm OR fg_ai OR fg_rat)

iff	fg_rat or fg_ai
fg_norm_exe		EQU	-1
else
fg_norm_exe	EQU	0
endif

if	fg_plink OR fg_ov
any_overlays		EQU	-1
else
any_overlays		EQU	0
endif

alloc_support		EQU	any_overlays

fg_pack_zero		EQU	-1

exepack_support EQU	-1

if	fgh_prot
data_in_codeseg		EQU	0
;CDATA			EQU	DGROUP
else
data_in_codeseg		EQU	-1
;CDATA			EQU	CODE
endif

if	fg_ai

MOVABLE_MASK	EQU	0

endif

BPTR	EQU	BYTE PTR
WPTR	EQU	WORD PTR
BPT	EQU	BYTE PTR
WPT	EQU	WORD PTR
OFF	EQU	OFFSET
DWORDP	EQU	DWORD

LE_REC		RECORD	BIT_ME:1,BIT_LE:1,BIT_LI:1,BIT_FI:1,BIT_FR:1,BIT_32:1

;RECTYP_CLASS	EQU	1
;RECTYP_GROUP	EQU	2
;RECTYP_MODULE	EQU	3
;RECTYP_OUTFILE	EQU	4
;RECTYP_SEGMENT	EQU	5
;RECTYP_COMDAT	EQU	6

PRETEXT_PTR_STRUCT	STRUC

		DD	?

PRETEXT_PTR_STRUCT	ENDS

_PTP_MCD	EQU	(DWORD PTR 0FFFCH)

TEXT_PTR_STRUCT	STRUC

_TP_FLAGS	DW	?		;LOCALNESS
_TP_HASH	DW	?
_TP_LENGTH	DW	?
_TP_TEXT	DW	?

TEXT_PTR_STRUCT	ENDS

if	any_overlays

LIBALLOC_STRUCT 	STRUC

_LIBALLOC_NEXT_HASH	DD	?
_LIBALLOC_NEXT		DD	?	;NEXT REFERENCING SEGMOD
_LIBALLOC_FROM		DD	?	;REFERENCING SEGMOD
_LIBALLOC_TO		DD	?	;REFERENCED SEGMOD

LIBALLOC_STRUCT 	ENDS

PUBALLOC_STRUCT 	STRUC

_PUBALLOC_NEXT_HASH	DD	?
_PUBALLOC_NEXT		DD	?	;NEXT REFERENCING SEGMOD
_PUBALLOC_FROM		DD	?	;REFERENCING SEGMOD
_PUBALLOC_TO		DD	?	;REFERENCED SYMBOL

PUBALLOC_STRUCT 	ENDS

CACHE_STRUCT	STRUC

_CACHE_FLAGS	DB	?
_CACHE_ORDER	DB	?
_CACHE_MIN_SIZE DW	?
_CACHE_MAX_SIZE DW	?

CACHE_STRUCT	ENDS

CACHE_FLAGS	RECORD	CCH_MIN_PCNT:1, CCH_MAX_PCNT:1

endif

ALLOCS_STRUCT	STRUC

ALLO_LAST_LIST	DD	?		;LAST STORED LIST OF BLOCKS
ALLO_PTR	DD	?		;LOGICAL PTR TO NEXT AVAILABLE BYTE
ALLO_CNT	DW	?		;BYTES LEFT THIS BLOCK
ALLO_SUB_CNT	DW	?
ALLO_SUB_PTR	DD	?
ALLO_NEXT_BLK	DW	?		;PTR TO STORE NEXT BLOCK LOCALLY
ALLO_HASH_TABLE_PTR	DD	?	;HASH TABLE IF IT EXISTS
ALLO_HASH	DW	?		;HASH IF IT EXISTS
ALLO_BLK_CNT	DW	?		;ALLOCATED BLOCK COUNT
ALLO_BLK_LIST	DW	8 DUP(?)	;LIST OF UP TO 8 ALLOCATED BLOCKS

ALLOCS_STRUCT	ENDS


LKD_ALLOC_STRUCT	STRUC

_LKD_ALLOC_PTR	DD	?		;NEXT AVAILABLE BYTE
_LKD_AVAIL_1K	DD	?		;LIST OF AVAILABLE BLOCKS
_LKD_AVAIL_2K	DD	?		;
_LKD_AVAIL_MISC	DD	?		;LIST OF MISCELLANEOUS SIZED BLOCKS
_LKD_ALLOC_CNT	DW	?		;BYTES LEFT THIS BLOCK
_LKD_BLKS_COUNT2 DW	?		;# OF BLOCKS OWNED * 2
_LKD_BLKS_OWNED	DW	16 DUP(?)	;MAX LOCKED STORAGE

LKD_ALLOC_STRUCT	ENDS


SEQ_STRUCT	STRUC

_SEQ_PTR	DD	?		;NEXT ADDRESS TO WRITE TO
_SEQ_TABLE	DW	32K/PAGE_SIZE*4 DUP(?)	;128K MAX DATA THIS TYPE
_SEQ_TARGET	DW	?		;PTR TO NEXEHEADER OFFSET OF OFFSET...
_SEQ_NEXT_TARGET DW	?		;

SEQ_STRUCT	ENDS

DTA_STRUCT	STRUC

FDATECREATION	DW	?
FTIMECREATION	DW	?
FDATELASTACCESS DW	?
FTIMELASTACCESS DW	?
FDATELASTWRITE	DW	?
FTIMELASTWRITE	DW	?
CBFILE		DD	?
CBFILEALLOC	DD	?
ATTRFILE	DW	?
CCHNAME 	DB	?
ACHNAME 	DB	13 DUP(?)

DTA_STRUCT	ENDS

CMDLINE_STRUCT	STRUC

CMD_SELECTED	DCA	?	;USE SRCNAM (NZ) OR NUL
CMD_EXTENT	DW	?	;DEFAULT EXTENT
if	fg_mscmd
;CMD_PREPROC	DW	?	;LOOK FOR LEADING COMMAND CHARS?
;CMD_POSTPROC	DW	?	;ROUTINE AFTER FILENAME FOUND
;CMD_DESTINATION DW	?	;FN STRUCTURE
CMD_DESIRED	DCA	?	;WANT AT ALL?  LIKE OUTPUT LIBRARY NAME
CMD_PMSG	DW	?	;PROMPT MESSAGE
endif

CMDLINE_STRUCT	ENDS

;LNAME_ARRAY_BLOCK_SIZE	EQU 2048		;room for 128 more

;LNAME_STRUCT	STRUC
;
;_LNAME_NEXT		DD	?		;PTR TO NEXT WITH SAME HASH
;_LNAME_HASH		DW	?		;4 MORE HASH BITS
;_LNAME_TEXT		DW	?		;AT LEAST TWO ZEROS...
;
;LNAME_STRUCT	ENDS

;SMALL_LNAME_HASH	EQU	3fdh	;PRIME NUMBER???

if page_size eq 16k
SMALL_TEXT_HASH 	EQU	0ffdh	;PRIME?????
SMALL_SYM_HASH		EQU	1fffh	;0ffdh	;PRIME?????
SMALL_RAINBOW_HASH	EQU	0ffdh	;PRIME?????
else if page_size eq 8k
;SMALL_TEXT_HASH 	EQU	7F7H
SMALL_SYM_HASH		EQU	0ffdh	;7F7H
;SMALL_RAINBOW_HASH	EQU	7F7H
else
.err
endif
;LARGE_LNAME_HASH	EQU	7F7H
;LARGE_FAR_HASH 	EQU	1FFFH
;HUGE_FAR_HASH		EQU	3FFDH

PRIME_128		EQU	007FH
PRIME_256		EQU	00FBH
PRIME_512		EQU	01FDH
PRIME_1K		EQU	03FDH
PRIME_2K		EQU	07F7H
PRIME_4K		EQU	0FFDH

SEGMENT_HASH_SIZE	EQU	0FFFH
SEGMENT_HASH_DXLIMIT	EQU	0FFFH

FIXDS	MACRO
	APUSH	SS
	APOP	DS
	ENDM

FIXES	MACRO
	APUSH	SS
	APOP	ES
	ENDM

APUSH	MACRO	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	PUSHAS	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	IRP	X,<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10>
	IFNB	<X>
	PUSH	X
	ENDIF
	ENDM
	ENDM

APOP	MACRO	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	POPAS	X1,X2,X3,X4,X5,X6,X7,X8,X9,X10
	IRP	X,<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10>
	IFNB	<X>
	POP	X
	ENDIF
	ENDM
	ENDM


	.SALL

LONGST		STRUC
LW		DW	?
HW		DW	?
LONGST		ENDS

FAR_PTR_S	STRUC

FP_BASE 	DD	?	;		START OF ENTRIES
FP_NEXT 	DD	?	;		NEXT PLACE TO STORE ENTRY
FP_INSTALL_ROUTINE	DCA	?	;
FP_AX_TO_DSSI	DCA	?
FP_AX_TO_ESDI	DCA	?
FP_LIMIT	DW	?	;		# OF VALID ENTRIES IN TABLE
FP_COUNT	DW	?	;		# LEFT TO ALLOCATE THIS BLOCK
FP_BASES	DW	?	;POINTS TO DGROUP 512-BYTE ALLOCATION

FAR_PTR_S	ENDS

STD_PTR_S	STRUC				;USED BY LIBRARIES, SOON MASTER GROUPS, SEGMENTS, CLASSES, POSSIBLY EVEN SYMBOLS, OTHERS

_STD_BASE_NEXT 	DD	?	;		NEXT PLACE TO STORE BLOCK POINTER
_STD_NEXT 	DD	?	;		NEXT PLACE TO STORE PTR
_STD_LIMIT	DW	?	;		# OF VALID ENTRIES IN TABLE
_STD_COUNT	DW	?	;		# LEFT TO ALLOCATE THIS BLOCK
_STD_ALLOC_ROUTINE	DCA	?	;	ALLOCATE MEMORY FOR PTRS
_STD_TYPE_TEXT	DW	?
_STD_INSTALL_ROUTINE	DCA	?	;	INSTALL NEXT ENTRY INTO TABLE
_STD_INSTALL_RANDOM_ROUTINE	DCA	?	;
_STD_AX_TO_DSSI	DCA	?	;		CONVERT AX TO PTR IN DS:SI PHYSICAL
_STD_AX_TO_ESDI	DCA	?	;		CONVERT AX TO PTR IN ES:DI PHYSICAL
if	fgh_os2
_STD_AX_TO_DSSI_THREAD	DCA	?	;	CONVERT FROM THREAD (SS!=DGROUP)
endif
_STD_PTRS	DD	16 DUP(?)	;	INITIALLY PTRS, THEN PTRS TO BLOCKS, THEN PTR TO MASTER BLOCK

STD_PTR_S	ENDS


PAR_PTR_S	STRUC		;USED FOR PARALLEL STRUCTURES

_PAR_PTRS_PTR	DD	?	;ADDRESS OF BLOCK POINTERS
_PAR_TO_DSSI	DCA	?
_PAR_TO_ESDI	DCA	?
_PAR_SHIFTS	DW	?	;
_PAR_MASK	DW	?	;
_PAR_BLOCKS	DW	?	;# OF BLOCKS MAX
_PAR_LIMIT	DW	?	;FOR RANDOM INSTALLERS

PAR_PTR_S	ENDS


CONVERT_PAR_GINDEX_AX_DSSI	MACRO	XX

		LEA	SI,XX
		CALL	DGROUP:[SI]._PAR_TO_DSSI

		ENDM

CONVERT_PAR_GINDEX_AX_ESDI	MACRO	XX

		LEA	DI,XX
		CALL	DGROUP:[DI]._PAR_TO_ESDI

		ENDM


FA_S		STRUC

FA_PTR		DD	?
FA_CNT		DW	?

FA_S		ENDS

if	fgh_os2

SEMAPHORE_STRUCT	STRUC

_SEM_ITSELF	DD	?
_SEM_COUNTER	DW	?
_SEM_NOTHING	DW	?

SEMAPHORE_STRUCT	ENDS

endif

PLTYPES 	RECORD	SEG_OVERLAYABLE:1,SECTION_ASSIGNED:1,LEVEL_0_SECTION:1

LDATA_HEADER_TYPE STRUC

_LD_NEXT_LDATA	DD	?	;NEXT LDATA THIS SEGMOD, OR FIXUPP
_LD_TYPE	DB	?	;LEDATA, FIXUPP, LIDATA, 32 VS 16 BIT,FR, ETC
		DB	?
_LD_SECOND_BLK	DW	?	;IN CASE RECORD GETS SPLIT...
_LD_LENGTH	DW	?	;LENGTH OF DATA RECORD
_LD_OFFSET	DD	?	;IF DATA, THIS IS SEGMOD OFFSET

LDATA_HEADER_TYPE ENDS

FIXUPP_HEADER_TYPE STRUC

_FH_NEXT_FIXUPP DD	?

_FH_TYPE	DB	?
_FH_XTRA	DB	?
_FH_SECOND_BLK	DW	?	;IN CASE OF SPLIT BLOCK

_FH_LENGTH	DW	?

FIXUPP_HEADER_TYPE ENDS

FARCALL_HEADER_TYPE STRUC

_FC_NEXT_FARCALL	DD	?
_FC_SEGMOD_GINDEX	DW	?
_FC_LENGTH		DW	?

FARCALL_HEADER_TYPE ENDS

LINK_TARGETS_STRUC	STRUC

_LT_SEG_CLASS	DD	?
_LT_NEXT	DD	?
_LT_TYPE	DW	?

LINK_TARGETS_STRUC	ENDS

SSSS		STRUC

ADDER		DW	?
AMASK		DW	?

SSSS		ENDS

;BP_STRUC	STRUC
;			DB	0FF80H DUP(?)
;	***
;	THIS STARTS REUSABLE PER RECORD TYPE
;	***

;REUSABLE_BP		DB	(110 + \
;				75) AND 0FFFEH DUP(?)

;CV_TYPE_BP		DW	?	;**

;BP_STRUC	ENDS

DO	MACRO	XX
XX	EQU	XX&_BP[BP]
	ENDM

FORREF_HEADER_TYPE STRUC

_FR_NEXT_FORREF DD	?

_FR_TYPE	DB	?
_FR_XTRA	DB	?	;TYPE OF DATA TO FIXUPP
_FR_SECOND_BLK	DW	?

_FR_LENGTH	DW	?

FORREF_HEADER_TYPE ENDS

CVL_STRUCT	STRUC

_CVL_OFFSET	DD	?
_CVL_LINNUM	DW	?
_CVL_SRC_GINDEX	DW	?

CVL_STRUCT	ENDS

LINNUM_HEADER_TYPE STRUC

_LN_NEXT_LINNUM DD	?	;NEXT LINNUM RECORD THIS SEG_SRC_MOD

_LN_SECOND_BLK	DW	?	;IF RECORD IS SPLIT
_LN_LENGTH	DW	?	;LENGTH AFTER HEADER

_LN_TYPE	DW	?	;16 OR 32 BIT
_LN_SRC_GINDEX	DW	?	;SOURCE FILE INDEX FOR THESE LINES

LINNUM_HEADER_TYPE ENDS


CMDLINE_PTR	EQU	CURN_INPTR
CMDLINE_LENGTH	EQU	CURN_COUNT

MAP_RECORD	RECORD	MAP_A:1,MAP_E:1,MAP_N:1,MAP_M:1,MAP_S:1,MAP_L:1,MAP_D:1

if	fg_segm

FLG0C	RECORD	APPTYPE:1,\	;0=PROGRAM, 1=DLL
		APP??:1,\	;UNKNOWN
		APPERRORS:1,\	;ERRORS DURING LINK
		APP???:3,\	;UNKNOWN
		APPWINFLAGS:2,\ ;WINDOWAPI, WINDOWCOMPAT, NOTWINDOWCOMPAT
		APPFLOATS:1,\	;FLOATS USED?
		APP386:1,\	;386 INSTRUCTIONS
		APP286:1,\	;286 INSTRUCTIONS
		APP86:1,\	;8086-ONLY
		APPPROT:1,\	;PROTMODE APP
		APPINSTANCE:1,\ ;INSTANCE DATA
		APPMULTI:1,\	;MULTIPLE DATA (NONSHARED)
		APPSOLO:1	;SOLO DATA (SHARED)

endif

OFFS		EQU	WORD PTR 0
SEGM		EQU	WORD PTR 2
PHYS		EQU	WORD PTR 4

if	fg_virt

EMS_STRUC	STRUC

_EMS_LENGTH	DD	?	;LENGTH OF REGION
_EMS_SRC_TYPE	DB	?	;0 = CONVENTIONAL, 1 = EMS
_EMS_SRC_HANDLE DW	?	;
_EMS_SRC_OFFSET DW	?
_EMS_SRC_SEG	DW	?
_EMS_DST_TYPE	DB	?
_EMS_DST_HANDLE DW	?
_EMS_DST_OFFSET DW	?
_EMS_DST_SEG	DW	?

EMS_STRUC	ENDS

EMS_XMS_STRUCT	STRUC

_EX_PREV_BLOCK	DW	?
_EX_NEXT_BLOCK	DW	?
_EX_TO_LOG	DW	?

EMS_XMS_STRUCT	ENDS

XMS_STRUC	STRUC

XMS_PAGES	DW	?	;# OF PAGES FOR THIS GUY
XMS_HANDLE	DW	?	;HANDLE FOR THIS GUY

XMS_STRUC	ENDS

endif

ALLOC_STRUC	STRUC
_A_PTR		DW	?
_A_RELEASED	DW	?
ALLOC_STRUC	ENDS

GET_NAME_HASH	MACRO	;SYM_TOO_LONG
;;GET NAME FROM DS:SI INTO SYMBOL_TEXT IN DATA SEGMENT
		;;ES=SS=DGROUP
		;;DS:SI IS SOURCE TEXT, SYMBOL_LENGTH&SYMBOL_TEXT ARE DESTIN
		LODSB				;;SYMBOL LENGTH
		XOR	AH,AH
		LEA	DI,SYMBOL_TPTR._TP_LENGTH
		STOSW				;;STORE SYMBOL LENGTH
		XOR	DX,DX			;;HASH TOTALS
		CALL	OPTI_MOVE		;;GO THRU JUMP TABLE U/L

		ENDM

GET_NAME_HASHW	MACRO
;;GET NAME FROM DS:SI INTO SYMBOL_TEXT IN DATA SEGMENT
		;;ES=SS=DGROUP
		;;DS:SI IS SOURCE TEXT, SYMBOL_LENGTH&SYMBOL_TEXT ARE DESTIN
		LODSW				;;SYMBOL LENGTH
		LEA	DI,SYMBOL_TPTR._TP_LENGTH
		STOSW				;;STORE SYMBOL LENGTH
		XOR	DX,DX			;;HASH TOTALS
		CALL	OPTI_MOVE		;;GO THRU JUMP TABLE U/L

		ENDM

INSTALL_POINTER_LINDEX	MACRO	XX		;;INSTALL AX:BX=PTR, RETURN AX=LINDEX
		IFIDN	<LNAME_LARRAY>,<XX>
;;		PUSH	SI
;;		LEA	SI,XX
		CALL	LNAME_LARRAY.FP_INSTALL_ROUTINE
;;		POP	SI
		ELSE
		.ERR
		ENDIF
		ENDM

INSTALL_POINTER_GINDEX	MACRO	XX		;;INSTALL AX:BX=PTR, RETURN AX=GINDEX
		PUSH	SI			;;USED TO CREATE MASTER INDEXES
		LEA	SI,XX
		CALL	DGROUP:_STD_INSTALL_ROUTINE[SI]
		POP	SI
		ENDM

INSTALL_GINDEX_LINDEX	MACRO	XX		;;INSTALL AX=GINDEX, RETURN AX=LINDEX
		IFIDN	<LNAME_LARRAY>,<XX>
		.ERR
		ELSE
		PUSH	SI
		LEA	SI,XX
		CALL	DGROUP:FP_INSTALL_ROUTINE[SI]
		POP	SI
		ENDIF
		ENDM

NEW_ARRAY	MACRO	XX,YY
		PUSH	BX
		PUSH	AX
		LEA	BX,XX
		MOV	AX,YY
		EXTP	DO_NEW_ARRAY
		CALL	DO_NEW_ARRAY
		POPM	AX,BX
		ENDM

INIT_ARRAY	MACRO	XX,SIZE
		MOV	AX,XX&_ARRAY.SP_BASE
;;		ADD	AX,SIZE
		MOV	XX&_ARRAY.SP_NEXT,AX
		ENDM

NEXT_INDEXI	MACRO
		;;THIS MACRO ASSUMES RANDOM INDEX SIZE
		LOCAL	LOC1

		LODSB
		CBW
		TEST	AL,80H
		JZ	LOC1
		AND	AL,7FH
		MOV	AH,AL
		LODSB
LOC1:
		ENDM

NEXT_INDEX	MACRO	ZZ
		LODSB
		TEST	AL,80H
		JNZ	ZZ
		CBW
ZZ&_RET:
		ENDM

DOLONG		MACRO	ZZ
ZZ:
		AND	AL,7FH
		MOV	AH,AL
		LODSB
		JMP	ZZ&_RET
		ENDM

CONVERT_MYCOMDAT_AX_DSBX	MACRO
	SOFT	EXTP	MYCOMDAT_SEARCH
		CALL	MYCOMDAT_SEARCH
		ASSUME	DS:NOTHING
		ENDM

CONVERT_GINDEX_AX_DSSI	MACRO	XX
		LEA	SI,XX
		CALL	DGROUP:[SI]._STD_AX_TO_DSSI
		ASSUME	DS:NOTHING
		ENDM

TCONVERT_GINDEX_AX_DSSI	MACRO	XX
		CAPTURE	TCONVERT_SEM
		LEA	SI,XX
		CALL	DGROUP:[SI]._STD_AX_TO_DSSI_THREAD
		ASSUME	DS:NOTHING
		RELEASE	TCONVERT_SEM
		ENDM

TSCONVERT_GINDEX_AX_DSSI	MACRO	XX
		LEA	SI,XX
		CALL	DGROUP:[SI]._STD_AX_TO_DSSI_THREAD
		ASSUME	DS:NOTHING
		ENDM

CONVERT_GINDEX_AX_ESDI	MACRO	XX
		LEA	DI,XX
		CALL	DGROUP:[DI]._STD_AX_TO_ESDI
		ENDM

CONVERT_LINDEX_AX_PTR_DSSI	MACRO	ARRAY_ID
		IFIDN	<LNAME_LARRAY>,<ARRAY_ID>
		CALL	[LNAME_LARRAY].FP_AX_TO_DSSI
		ASSUME	DS:NOTHING
		ELSE
		.ERR
		ENDIF
		ENDM

;CONVERT_LINDEX_AX_PTR_ESDI	MACRO	ARRAY_ID
;		IFIDN	<LNAME_LARRAY>,<ARRAY_ID>
;		LEA	DI,ARRAY_ID
;		CALL	DGROUP:[DI].FP_AX_TO_ESDI
;		ELSE
;		.ERR
;		ENDIF
;		ENDM

CONVERT_LINDEX_GINDEX_DSSI	MACRO	ARRAY_ID
		IFIDN	<LNAME_LARRAY>,<ARRAY_ID>
		.ERR
		ELSE
		LEA	SI,ARRAY_ID
		CALL	DGROUP:[SI].FP_AX_TO_DSSI
		ASSUME	DS:NOTHING
		ENDIF
		ENDM

CONVERT_LINDEX_GINDEX_ESDI	MACRO	ARRAY_ID
		IFIDN	<LNAME_LARRAY>,<ARRAY_ID>
		.ERR
		ELSE
		LEA	DI,ARRAY_ID
		CALL	DGROUP:[DI].FP_AX_TO_ESDI
		ENDIF
		ENDM

P1ONLY_POOL_ALLOC	MACRO	XX		;;USED ONLY ON PASS1, THEN CAN BE DELETED
	SOFT	EXTP	P1ONLY_POOL_GET
		CALL	P1ONLY_POOL_GET
		ENDM

SECTION_POOL_ALLOC	MACRO	XX
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	SECTION_POOL_GET
		CALL	SECTION_POOL_GET

		ENDM

TILLP2_POOL_ALLOC	MACRO	XX		;;PROBABLY NOT NEEDED AGAIN TILL PASS2
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	TILLP2_POOL_GET
		CALL	TILLP2_POOL_GET

		ENDM

TILLMIDDLE_POOL_ALLOC	MACRO	XX		;;PROBABLY NOT NEEDED AGAIN TILL MIDDLE
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	TILLMIDDLE_POOL_GET
		CALL	TILLMIDDLE_POOL_GET

		ENDM

CLASS_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	CLASS_POOL_GET
		CALL	CLASS_POOL_GET

		ENDM

SEGMENT_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	SEGMENT_POOL_GET
		CALL	SEGMENT_POOL_GET

		ENDM

SEGMOD_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	SEGMOD_POOL_GET
		CALL	SEGMOD_POOL_GET

		ENDM

MODULE_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	MODULE_POOL_GET
		CALL	MODULE_POOL_GET

		ENDM

GROUP_POOL_ALLOC	MACRO
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	GROUP_POOL_GET
		CALL	GROUP_POOL_GET

		ENDM

SSYM_POOL_ALLOC MACRO	XX
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	SSYM_POOL_GET
		CALL	SSYM_POOL_GET

		ENDM

TEXT_POOL_ALLOC MACRO	XX			;USED FOR LNAME TEXT,
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	TEXT_POOL_GET
		CALL	TEXT_POOL_GET
		ENDM

LTEXT_POOL_ALLOC MACRO	XX			;USED FOR LOCAL LNAME TEXT,
		;;ALREADY DWORD ALIGNED...
		;;RETURN ES:DI = PHYS, AX IS LOGICAL
	SOFT	EXTP	LTEXT_POOL_GET
		CALL	LTEXT_POOL_GET
		ENDM

TEXT_POOL_ALLOC_FIX	MACRO	XX
		ENDM

SYM_POOL_ALLOC_FIX	MACRO	XX
		ENDM

SSYM_POOL_ALLOC_FIX	 MACRO	 XX
		ENDM

OPTIMOVE	MACRO
		SHR	CX,1
		REP	MOVSW
		ADC	CX,CX
		REP	MOVSB
		ENDM

OPTI_MOVSB	EQU	OPTIMOVE

OPTI_MOVSW_386	MACRO			;;WORD MOVE LARGE ENOUGH TO GET ADVANTAGE FROM 386
		REP	MOVSW		;;SO WHAT FOR NOW
		ENDM

OPTI_MOVSW	MACRO
;;		SHR	CX,1
;;		DB	66H
		REP	MOVSW		;;USE SHR CX,1 REP MOVSD ON 386
;;		ADC	CX,CX
;;		REP	MOVSW
		ENDM

OPTI_STOSD	MACRO
;;		DB	66H
		ADD	CX,CX
		REP	STOSW
		ENDM

OPTI_STOSD_386	MACRO
;;		DB	66H
		ADD	CX,CX
		REP	STOSW
		ENDM

OPTI_STOSW	MACRO
;;		SHR	CX,1
;;		DB	66H
;;		REP	STOSW
;;		ADC	CX,CX
		REP	STOSW
		ENDM

OPTI_STOSB	MACRO
		MOV	AH,AL
		SHR	CX,1
		REP	STOSW
		ADC	CX,CX
		REP	STOSB
		ENDM

SKIP_INDEX	MACRO
		LODSB
		ROL	AL,1
		SBB	AX,AX
		SUB	SI,AX
		ENDM

SETT	MACRO	XX
;;	OR	BPTR (XX/8)-80H[BP],1 SHL (XX MOD 8)
	EXTB	XX
	MOV	DGROUP:XX,-1
	ENDM

BITT	MACRO	XX
;;	TEST	BPTR (XX/8)-80H[BP],1 SHL (XX MOD 8)
	EXTB	XX
	TEST	DGROUP:XX,-1
	ENDM

RESS	MACRO	XX
;;	AND	BPTR (XX/8)-80H[BP],NOT (1 SHL (XX MOD 8))
	EXTB	XX
	MOV	DGROUP:XX,0
	ENDM

;BITT2	MACRO	XX
;	TEST	BPTR (XX/8)[STACK_VARIABLES],1 SHL (XX MOD 8)
;	ENDM

	if	fg_virt

LOCKIT		MACRO
	SOFT	EXTP	LOCK_BLOCK
		CALL	LOCK_BLOCK
		ENDM

UNLOCKIT		MACRO
	SOFT	EXTP	UNLOCK_BLOCK
		CALL	UNLOCK_BLOCK
		ENDM

MCONVERT_BX_TO_DX	MACRO
		SOFT EXTP	CONVERT_BX_TO_DX
		CALL	CONVERT_BX_TO_DX
		ENDM

CONV_ES 	MACRO
	SOFT	EXTP	CONVERT_ES_TO_ES
		CALL	CONVERT_ES_TO_ES
		ENDM

CONV_ES_AX		MACRO
	SOFT	EXTP	CONVERT_ES_TO_ES
		PUSH	AX
		CALL	CONVERT_ES_TO_ES
		POP	AX
		ENDM

CONV_DS 	MACRO

	SOFT	EXTP	CONVERT_DS_TO_DS
		CALL	CONVERT_DS_TO_DS

		ENDM

VIRT_?		EQU

	else

LOCKIT		MACRO
		ENDM
UNLOCKIT	MACRO
		ENDM
MCONVERT_BX_TO_DX	MACRO
		MOV	DX,BX
		ENDM
CONV_ES 	MACRO
		ENDM
CONV_ES_AX	MACRO
		ENDM
CONV_DS 	MACRO
		ENDM

VIRT_?		EQU	<;>

	endif

if	fg_sym_virt

SYM_ALIGN	EQU	<ALIGN	4,,1>

SYM_?		EQU			;ALLOW THIS INSTRUCTION

NOT_SYM_?	EQU	<;>

SYM_CONV_DS	MACRO

	SOFT	EXTP	CONVERT_DS_TO_DS
		CALL	CONVERT_DS_TO_DS

		ENDM

SYM_LOCKIT	MACRO
	SOFT	EXTP	SYM_LOCK_BLOCK
		CALL	SYM_LOCK_BLOCK
		ENDM

SYM_UNLOCKIT	MACRO
	SOFT	EXTP	SYM_UNLOCK_BLOCK
		CALL	SYM_UNLOCK_BLOCK
		ENDM

SYM_CONV_ES	MACRO

	SOFT	EXTP	CONVERT_ES_TO_ES
		CALL	CONVERT_ES_TO_ES

		ENDM

SYM_CONV_DS_AX	MACRO

	SOFT	EXTP	CONVERT_DS_TO_DS
		PUSH	AX
		CALL	CONVERT_DS_TO_DS
		POP	AX

		ENDM

SYM_CONV_ES_AX	MACRO

	SOFT	EXTP	CONVERT_ES_TO_ES
		PUSH	AX
		CALL	CONVERT_ES_TO_ES
		POP	AX

		ENDM

else

SYM_ALIGN	EQU	<ALIGN	4>

SYM_?		EQU	<;>

NOT_SYM_?	EQU

SYM_CONV_DS	EQU	<;>

SYM_CONV_ES	EQU	<;>

SYM_LOCKIT	EQU	<;>
SYM_UNLOCKIT	EQU	<;>

SYM_CONV_DS_AX	EQU	<;>

SYM_CONV_ES_AX	EQU	<;>

endif

if fgh_prot

PUSHI		MACRO	XX,Y,Z,A,B,C,D,E,F,G
		PUSH	Y Z A B C D E F G
		ENDM

ROLI		MACRO	XX,Y,Z,A,B,C,D
		ROL	XX,Y Z A B C D
		ENDM

RORI		MACRO	XX,Y,Z,A,B,C,D
		ROR	XX,Y Z A B C D
		ENDM

SHRI		MACRO	XX,Y,Z,A,B,C,D
		SHR	XX,Y Z A B C D
		ENDM

SHLI		MACRO	XX,Y,Z,A,B,C,D
		SHL	XX,Y Z A B C D
		ENDM

RCRI		MACRO	XX,Y,Z,A,B,C,D
		RCR	XX,Y,Z,A,B,C,D
		ENDM

else

PUSHI		MACRO	XX,Y,Z,A,B,C,D,E,F,G
		MOV	XX,Y Z A B C D E F G
		PUSH	XX
		ENDM

ROLI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		ROL	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		ROL	XX,1
		ENDM
		ENDIF
		ENDM

RORI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		ROR	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		ROR	XX,1
		ENDM
		ENDIF
		ENDM

SHRI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		SHR	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		SHR	XX,1
		ENDM
		ENDIF
		ENDM

SHLI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		SHL	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		ADD	XX,XX
		ENDM
		ENDIF
		ENDM

RCRI		MACRO	XX,Y,Z,A,B,C
		IF	Y Z A B C GT 4
		PUSH	CX
		MOV	CL,Y Z A B C
		RCR	XX,CL
		POP	CX
		ELSE
		REPT	Y Z A B C
		RCR	XX,1
		ENDM
		ENDIF
		ENDM

endif

if	fgh_os2

CAPTURE		MACRO	XX		;CAPTURE THIS SEMAPHORE

		PUSHM	DS,BX
		MOV	BX,SEG XX
		MOV	DS,BX
		MOV	BX,OFF XX
		CALL	CAPTURE_DSBX
		POPM	BX,DS
		ENDM

RELEASE		MACRO	XX		;RELEASE THIS SEMAPHORE

		PUSHM	DS,BX
		MOV	BX,SEG XX
		MOV	DS,BX
		MOV	BX,OFF XX
		CALL	RELEASE_DSBX
		POPM	BX,DS
		ENDM

else

CAPTURE		MACRO	XX
		ENDM

RELEASE		MACRO	XX
		ENDM

endif

INT21		MACRO
if	fgh_dpmi
	SOFT	EXTP	INT21_ROUTINE
		CALL	INT21_ROUTINE
else if fgh_win
		CALL	DOS3CALL
else
		INT	21H
		CLD
endif
		ENDM

DOS		MACRO
	SOFT	EXTP	DOS_ROUTINE
		CALL	DOS_ROUTINE
		ENDM

.LIST

