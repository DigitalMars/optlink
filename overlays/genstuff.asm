		TITLE	GENSTUFF - Copyright (c) SLR Systems 1994

		INCLUDE MACROS
		INCLUDE	SECTS
		INCLUDE	IO_STRUC
		INCLUDE	SECTIONS

		PUBLIC	STORE_VECTOR_TABLE_ADDRESS


		.DATA

		EXTERNDEF	MODEL_FAR_BYTE:BYTE,TEMP_RECORD:BYTE,LDATA_TYPE:BYTE

		EXTERNDEF	VECTOR_COUNT:DWORD,VECTOR_SIZE:DWORD,SECTION_NUMBER:DWORD,SECTION_SIZE:DWORD,RELOAD_DEPTH:DWORD
		EXTERNDEF	END_OF_RECORD:DWORD,OVERLAY_INTERRUPT_NUMBER:DWORD,CACHE_BLOCK_COUNT:DWORD,CACHE_EMS_TABLE:DWORD
		EXTERNDEF	CURN_TIME_DD:DWORD,CURN_DATE_DD:DWORD,SLR_VECTORS:DWORD,SLR_SECTIONS:DWORD,SLR_RELOAD_STACK:DWORD
		EXTERNDEF	SLR_CODE:DWORD,VECTOR_TABLE_ADDRESS:DWORD,FIRST_SECTION:DWORD,FIRST_MODULE:DWORD,FIRST_OUTFILE:DWORD
		EXTERNDEF	HIGH_PC:DWORD,DATA_SECTION:DWORD,SLR_HDR_TABLE:DWORD,LAST_DATA_PTR:DWORD,SLR_CODE_HEADER:DWORD
		EXTERNDEF	LDATA_SEGMOD:DWORD,END_VECTOR_TABLE:DWORD,SLR_FNAMES:DWORD,FIRST_SECTION_GINDEX:DWORD

		EXTERNDEF	SECTION_GARRAY:STD_PTR_S


		.CODE	PASS2_TEXT

		EXTERNDEF	SET_OUTFILE:PROC,FAKE_LEDATA:PROC


STORE_VECTOR_TABLE_ADDRESS	PROC
		;
		;
		;
		CALL	GEN_SECTIONS		;MUST HAPPEN BEFORE GEN_CODE
if	any_overlays
		BITT	DOING_OVERLAYS
		JZ	L9$
		CALL	GEN_VECTORS
		CALL	GEN_CODE
		CALL	GEN_FNAMES
L9$:
endif
		RET

STORE_VECTOR_TABLE_ADDRESS	ENDP


GEN_SECTIONS	PROC	NEAR
		;
		;NOW, GENERATE RECORDS FOR SECTION DATA...
		;
if	any_overlays
		FIXES
		LEA	DI,TEMP_RECORD
		XOR	AX,AX
		STOSW					;OFFSET IN SEGMOD
endif
		MOV	ESI,FIRST_SECTION_GINDEX
L1$:
		CONVERT	ESI,ESI,SECTION_GARRAY
		ASSUME	ESI:PTR SECTION_STRUCT

		;
		;OUTPUT FILE PARAGRAPH
		;
		XOR	EAX,EAX				;NEXT IS OFFSET IN FILE
if	any_overlays
		
		STOSW					;FILLED IN AT RUN TIME...
		STOSB
		CMP	[SI]._SECT_LEVEL,AX
		JNZ	12$				;MARK ALL LEVEL-0 SECTIONS PRELOAD...
		OR	[SI]._SECT_FLAGS,MASK SECT_PRELOAD
12$:
endif
		;
		;OUTPUT FLAGS BYTE (NEED TO INCLUDE FILE?)
		;
		CMP	[ESI]._SECT_OUTFILE_GINDEX,EAX
		JZ	L22$
L23$:

ife	any_overlays

		MOV	ESI,[ESI]._SECT_NEXT_SECTION_GINDEX

		TEST	ESI,ESI
		JNZ	L1$
		RET

else

		MOV	AL,[SI]._SECT_FLAGS		;SECTION FLAGS
		BITT	SEXE_FILES_FLAG
		JNZ	26$
		LDS	BX,[SI]._SECT_OUTFILE
		SYM_CONV_DS
		MOV	BX,[BX]._OF_OUTFILE_NUMBER
		MOV	DS,CX
		SYM_CONV_DS
		XCHG	AX,BX
		OR	AL,[SI]._SECT_FLAGS
26$:
		AND	AL,MASK SECT_CACHEABLE+MASK SECT_PRELOAD+MASK SEXE_FILE_NUMBER
		CMP	[SI]._SECT_NUMBER,0		;MAKE SURE SECTION 0 NOT PRELOAD...
		JNZ	28$
		AND	AL,NOT MASK SECT_PRELOAD
		OR	AL,MASK SECT_IN_MEMORY
28$:
		STOSB
3$:
		MOV	AX,[SI]._SECT_BASE_ADDRESS.LW	;FIRST ENTRY IS LOAD PARAGRAPH
		MOV	DX,[SI]._SECT_BASE_ADDRESS.HW
		CALL	SHR_DXAX_4
		BITT	SEXE_LOAD_PARA_FLAG		;STORE ONLY IF NEEDED
		JZ	31$
		STOSW
31$:
		PUSH	AX
		MOV	AX,[SI]._SECT_MAX_ADDRESS.LW	;NEXT IS END PARAGRAPH
		MOV	DX,[SI]._SECT_MAX_ADDRESS.HW
		ADD	AX,15
		ADC	DX,0
		CALL	SHR_DXAX_4
		BITT	SEXE_END_PARENT_FLAG		;STORE ONLY IF NEEDED
		JZ	32$
		STOSW
32$:
		POP	BX
		SUB	AX,BX
		BITT	SEXE_LENGTH_FLAG
		JZ	33$
		STOSW
33$:
		;
		;IF CACHEABLE, ADD IT TO CACHE_BLOCK TOTAL
		;IF 0 LENGTH, MARK IT NOT CACHEABLE...
		;
		TEST	[SI]._SECT_FLAGS,MASK SECT_CACHEABLE
		JZ	4$
		CMP	[SI]._SECT_LEVEL,0		;LEVEL 0 ITEMS NOT CACHEABLE
		JZ	35$
		OR	AX,AX				;ZERO LENGTH NOT CACHEABLE
		JNZ	37$
35$:
		AND	[SI]._SECT_FLAGS,NOT MASK SECT_CACHEABLE
		JMP	4$

endif

L22$:
		MOV	EAX,ESI
		CALL	SET_OUTFILE
		JMP	L23$

if	any_overlays

37$:
		;
		;COUNT IF THIS BLOCK IS CACHEABLE, AND NOT LEVEL 0...
		;
		XOR	DX,DX
		MOV	CX,128				;PARAS PER BLOCK
		DIV	CX
		OR	DX,DX
		JZ	38$
		INC	AX
38$:
		ADD	CACHE_BLOCK_COUNT,AX		;# OF BLOCKS TO CACHE THIS SECTION
4$:
		PUSHM	[SI]._SECT_OUTFILE.OFFS,[SI]._SECT_OUTFILE.SEGM
		PUSH	WPTR [SI]._SECT_FLAGS
		BITT	SEXE_END_PARENT_FLAG
		JZ	5$
		LDS	SI,[SI]._SECT_PARENT_AREA
		SYM_CONV_DS
		LDS	SI,[SI]._AREA_PARENT_SECTION	;NEXT IS PARENT SECTION OFFSET
		MOV	AX,DS
		OR	AX,AX
		JZ	43$
		SYM_CONV_DS
		MOV	AX,[SI]._SECT_NUMBER
		MUL	SECTION_SIZE
43$:
		STOSW
5$:
		POPM	AX,DS,SI
		BITT	SEXE_FILES_FLAG
		JZ	59$
		PUSH	AX
		SYM_CONV_DS
		MOV	AX,FNAME_SIZE
		MUL	[SI]._OF_OUTFILE_NUMBER
;		ADD	AX,SIZE SLRCODE_STRUCT
		STOSW
		POP	AX
59$:
		TEST	AL,MASK SECT_CODEVIEW
		JNZ	55$
		;
		;IF BUFFER FULL, FLUSH A RECORD
		;
		CMP	DI,OFF TEMP_RECORD+1K
		JA	7$
6$:

		POPM	DS,SI
		MOV	CX,DS
		JCXZ	FLUSH_SECTIONS
		JMP	1$

55$:
		SUB	DI,SECTION_SIZE
		JMP	6$

7$:
		CALL	FLUSH_SECTIONS
		JMP	6$

FLUSH_SECTIONS:
		BITT	DOING_OVERLAYS
		JZ	9$
		CMP	DI,OFF TEMP_RECORD+2
		JZ	9$
		MOV	END_OF_RECORD,DI
		LES	DI,SLR_SECTIONS
		FIXDS
		LEA	SI,TEMP_RECORD
		;
		;HMM, WHAT DO WE NEED TO LOOK LIKE LEDATA?
		;
		;LDATA TYPE MUST BE MASK BIT_LE
		;ES:DI MUST BE SEGMOD LOGICAL
		;DS:SI MUST BE POINTING TO OFFSET FOLLOWED BY DATA
		;END_OF_RECORD MUST BE JUST THAT
		;
		CALL	FAKE_LEDATA1
		ASSUME	DS:NOTHING
		FIXES
		LEA	DI,TEMP_RECORD+2
		MOV	AX,END_OF_RECORD
		SUB	AX,DI
		ADD	ES:-2[DI],AX
9$:
		RET

endif

GEN_SECTIONS	ENDP

if	any_overlays

		ASSUME	DS:NOTHING

GEN_VECTORS	PROC	NEAR
		;
		;
		;
		FIXES
		LEA	DI,TEMP_RECORD
		XOR	AX,AX
		STOSW
		LDS	SI,FIRST_MODULE
		JMP	81$

2$:
		SYM_CONV_DS
		PUSHM	[SI]._S_NEXT_SYM.OFFS,[SI]._S_NEXT_SYM.SEGM
		;
		;ONLY INTERESTED IN VECTOR_YES
		;
		TEST	[SI]._S_PLINK_FLAGS,MASK VECTOR_YES
		JZ	5$
		MOV	AL,0CDH				;INTERRUPT INSTRUCTION
		MOV	AH,BPTR OVERLAY_INTERRUPT_NUMBER
		STOSW
		MOV	AX,[SI]._S_OFFSET.LW		;FIRST STORE OFFSET
		MOV	BX,[SI]._S_FRAME.LW
		AND	BL,0F0H
		SUB	AX,BX
		STOSW
		CMP	MODEL_FAR_BYTE,'Y'
		JNZ	3$
		MOV	DX,[SI]._S_FRAME.HW		;THEN FRAME
		XCHG	AX,BX
		CALL	SHR_DXAX_4
		STOSW
3$:
		MOV	AX,SECTION_SIZE
		MUL	[SI]._S_SECTION_NUM
		;
		;HANDLE 'TRACK' BIT
		;
		BITT	DOING_RELOAD
		JNZ	4$
		INC	AX
		TEST	[SI]._S_PLINK_FLAGS,MASK VECTOR_TRACK
		JNZ	4$
		DEC	AX
4$:
		STOSW
		CMP	DI,OFF TEMP_RECORD+1K
		JA	7$
5$:
		POPM	DS,SI
71$:
		MOV	CX,DS
		OR	CX,CX
		JNZ	2$
8$:
		POPM	DS,SI
81$:
		MOV	AX,DS
		OR	AX,AX
		JZ	9$
		SYM_CONV_DS
		PUSHM	[SI]._M_NEXT_MOD.OFFS,[SI]._M_NEXT_MOD.SEGM
		;
		;SCAN MY PUBDEFS FOR POSSIBLE VECTORS
		;
		LDS	SI,[SI]._M_FIRST_PUB
		JMP	71$

7$:
		CALL	FLUSH_VECTORS
		JMP	5$

9$:
		JMP	FLUSH_VECTORS

GEN_VECTORS	ENDP

FLUSH_VECTORS	PROC	NEAR
		;
		;
		;
		CMP	DI,OFF TEMP_RECORD+2
		JZ	9$
		MOV	END_OF_RECORD,DI
		LES	DI,SLR_VECTORS
		FIXDS
		LEA	SI,TEMP_RECORD
		;
		;HMM, WHAT DO WE NEED TO LOOK LIKE LEDATA?
		;
		;LDATA TYPE MUST BE MASK BIT_LE
		;ES:DI MUST BE SEGMOD LOGICAL
		;DS:SI MUST BE POINTING TO OFFSET FOLLOWED BY DATA
		;END_OF_RECORD MUST BE JUST THAT
		;
		CALL	FAKE_LEDATA1
		ASSUME	DS:NOTHING
		FIXES
		LEA	DI,TEMP_RECORD+2
		MOV	AX,END_OF_RECORD
		SUB	AX,DI
		ADD	ES:-2[DI],AX
9$:
		RET

FLUSH_VECTORS	ENDP

		ASSUME	DS:NOTHING

GEN_FNAMES	PROC	NEAR
		;
		;OUTPUT FILE NAMES
		;
		LDS	SI,FIRST_OUTFILE
		MOV	LDATA_TYPE,MASK BIT_LE
1$:
		SYM_CONV_DS
		PUSHM	[SI]._OF_NEXT_OUTFILE_ORDER.OFFS,[SI]._OF_NEXT_OUTFILE_ORDER.SEGM
		FIXES
		LEA	DI,TEMP_RECORD
		MOV	AX,FNAME_SIZE
		MUL	[SI]._OF_OUTFILE_NUMBER
;		ADD	AX,SIZE SLRCODE_STRUCT
		STOSW
		XOR	AL,AL
		TEST	[SI]._OF_FLAGS,MASK OF_ROOT
		JZ	15$
		INC	AX
15$:
		STOSB
		XOR	AX,AX
		STOSW

		LDS	SI,[SI]._OF_FILE_LIST
		SYM_CONV_DS
		LEA	SI,[SI].FILE_LIST_NFN
		MOV	BX,[SI].NFN_PATHLEN
		MOV	CX,[SI].NFN_TOTAL_LENGTH
		SUB	CX,BX
		LEA	SI,[SI+BX].NFN_TEXT
		REP	MOVSB
		XOR	AL,AL
		STOSB
		MOV	END_OF_RECORD,DI
		LES	DI,SLR_FNAMES
		FIXDS
		LEA	SI,TEMP_RECORD
		;
		;HMM, WHAT DO WE NEED TO LOOK LIKE LEDATA?
		;
		;LDATA TYPE MUST BE MASK BIT_LE
		;ES:DI MUST BE SEGMOD LOGICAL
		;DS:SI MUST BE POINTING TO OFFSET FOLLOWED BY DATA
		;END_OF_RECORD MUST BE JUST THAT
		;
		CALL	FAKE_LEDATA1
		ASSUME	DS:NOTHING
		POPM	DS,SI
		MOV	AX,DS
		OR	AX,AX
		JNZ	1$
		RET

GEN_FNAMES	ENDP

GEN_CODE	PROC	NEAR
		;
		;
		;
		FIXES
		FIXDS
		MOV	LDATA_TYPE,MASK BIT_LE
		LEA	DI,TEMP_RECORD
		XOR	AX,AX
		STOSW				;OFFSET IN SEGMENT TO WRITE THIS
		MOV	AX,HIGH_PC.LW
		MOV	DX,HIGH_PC.HW
		ADD	AX,15
		ADC	DX,0
		CALL	SHR_DXAX_4
		STOSW				;$$SLR_FIRST_AVAIL
		ADD	HIGH_PC.LW,OVLINIT_STACKSIZE	;ROOM FOR INITIALIZE STACK...
		ADC	HIGH_PC.HW,0
		MOV	AX,SECTION_SIZE
		STOSW				;$$SLR_SECT_SIZE
		MOV	AX,SECTION_NUMBER
		STOSW				;$$SLR_NSECTS - # OF SECTIONS
		MOV	AX,VECTOR_COUNT
		STOSW				;$$SLR_NVECTS - # OF VECTORS
		;
		;NOW, RELOAD STACK BASE (OFFSET FROM SECTIONS...)
		;
		LDS	SI,SLR_RELOAD_STACK
		ASSUME	DS:NOTHING
		MOV	AX,DS
		OR	AX,AX
		JZ	5$
		SYM_CONV_DS
		MOV	BX,[SI]._SM_START.LW
		LDS	SI,[SI]._SM_BASE_SEG
		SYM_CONV_DS
		MOV	AX,[SI]._SEG_BASE.LW
		AND	AL,0F0H
		XCHG	AX,BX
		SUB	AX,BX
5$:
		FIXDS
		STOSW				;$$SLR_RELOAD_STACK_BASE
		MOV	AX,6
		MUL	RELOAD_DEPTH
		STOSW				;$$SLR_RELOAD_STACK_SIZE
;		MOV	AX,RELOAD_TYPE
;		STOSW				;RELOAD TYPE
		XOR	AX,AX
		STOSW				;SKIP $$SLR_MAIN - ASSUME 0:0
		STOSW

		MOV	AX,CACHE_BLOCK_COUNT
		STOSW				;$$SLR_CACHE_BLOCKS_NEEDED
		;
		;EMS, XMS, REG
		;
						;$$SLR_EMS_TABLE
		LEA	SI,CACHE_EMS_TABLE	;$$SLR_XMS_TABLE
		MOV	CX,4*3			;$$SLR_REG_TABLE
		REP	MOVSW			;$$SLR_UMB_TABLE
		MOV	AX,OVERLAY_INTERRUPT_NUMBER
		STOSW				;$$SLR_INT_NUMBER
		XOR	AX,AX
		BITT	SEXE_FILES_FLAG
		JZ	6$
		MOV	AX,SECTION_SIZE
		DEC	AX
		DEC	AX
6$:
		STOSW				;$$SLR_SEXE_FILE_OFFSET
		STOSW				;$$SLR_NEAR_SEGMENT...
		MOV	AX,VECTOR_COUNT
		MUL	VECTOR_SIZE
		STOSW				;$$SLR_RELOAD_JUMP
		DEC	AX
		ADD	AX,VECTOR_TABLE_ADDRESS.LW
		MOV	END_VECTOR_TABLE.LW,AX
		ADC	DX,VECTOR_TABLE_ADDRESS.HW
		MOV	END_VECTOR_TABLE.HW,DX
		;
		LDS	SI,DATA_SECTION
		ASSUME	DS:NOTHING
		SYM_CONV_DS
		MOV	DX,_SECT_BASE_ADDRESS[SI].HW
		MOV	AX,_SECT_BASE_ADDRESS[SI].LW
		CALL	SHR_DXAX_4
		STOSW				;$$SLR_DATA_AREA
		MOV	AX,[SI]._SECT_NUMBER
		MUL	SECTION_SIZE
		STOSW				;$$SLR_DATA_SECTION

		LDS	SI,FIRST_SECTION
		SYM_CONV_DS
		LDS	SI,[SI]._SECT_NEXT_SECTION_ORDER
		SYM_CONV_DS
		MOV	DX,_SECT_BASE_ADDRESS[SI].HW
		MOV	AX,_SECT_BASE_ADDRESS[SI].LW
		CALL	SHR_DXAX_4
		STOSW				;$$SLR_OVERLAY_AREA

		MOV	AX,CURN_TIME_WD
		STOSW				;$$SLR_TIME_WD

		MOV	AX,CURN_DATE_WD
		STOSW				;$$SLR_DATE_WD

		XOR	AL,AL
		BITT	ROOT_ENVIRONMENT_LEGAL	;
		JZ	7$
		MOV	AL,-1
7$:
		STOSB

		FIXDS
		LEA	SI,TEMP_RECORD
		MOV	END_OF_RECORD,DI
		LES	DI,SLR_HDR_TABLE
		CALL	FAKE_LEDATA1
		ASSUME	DS:NOTHING
		MOV	AX,LAST_DATA_PTR.OFFS
		MOV	SLR_CODE_HEADER.OFFS,AX
		MOV	AX,LAST_DATA_PTR.SEGM
		MOV	SLR_CODE_HEADER.SEGM,AX
		RET

GEN_CODE	ENDP

		ASSUME	DS:DGROUP

FAKE_LEDATA1	PROC	NEAR
		;
		;
		;
		MOV	LDATA_SEGMOD.OFFS,DI
		MOV	LDATA_SEGMOD.SEGM,ES
		CALL	FAKE_LEDATA
		RET

FAKE_LEDATA1	ENDP

endif

		END

