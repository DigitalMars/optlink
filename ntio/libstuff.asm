		TITLE	LIBSTUFF - Copyright (C) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	IO_STRUC
		INCLUDE	LIBRARY




		.DATA

		EXTERNDEF	LIB_HEADER:BYTE

		EXTERNDEF	CURN_LIB_BLOCK:DWORD,OBJ_DEVICE:DWORD,DICT_BLOCKS:DWORD,NUMBLKS:DWORD,LAST_LIB_GINDEX:DWORD
		EXTERNDEF	CURN_LIBNUM:DWORD,CURN_DICT_LOG:DWORD,CURN_LIB_BLOCK_PTR:DWORD,CURN_LIB_BLOCK_PTR_LIMIT:DWORD
		EXTERNDEF	CURN_LS_BLOCK_TABLE_PTR:DWORD,CURNLIB_GINDEX:DWORD

		EXTERNDEF	LIBRARY_GARRAY:STD_PTR_S,FILNAM:NFN_STRUCT


		.CODE	PASS1_TEXT

		EXTERNDEF	_capture_eax:proc
		EXTERNDEF	_dec_lib_block:proc,READ_LIBRARY_BLOCK:PROC,RELEASE_BLOCK:PROC,_dosread:proc,GET_NEW_IO_LOG_BLK:PROC
		EXTERNDEF	CAPTURE_EAX:PROC,_read_16k_threaded:proc

;		public _readlib_16k
;_readlib_16k	proc
;_readlib_16k	endp

		PUBLIC	READLIB_16K
READLIB_16K	PROC
		;
		;
		;
		PUSH	EBX
		CALL	_dec_lib_block		;MAYBE GET RID OF THIS BLOCK

		MOV	ECX,CURN_LIB_BLOCK
		MOV	EBX,CURN_LIB_BLOCK_PTR

		INC	ECX
		ADD	EBX,8

		MOV	EAX,CURN_LIB_BLOCK_PTR_LIMIT
		MOV	CURN_LIB_BLOCK,ECX

		CMP	EAX,EBX
		JZ	L2$
L1$:
		MOV	EAX,[EBX]
		MOV	CURN_LIB_BLOCK_PTR,EBX

		TEST	EAX,EAX
		JNZ	L5$
L4$:
		MOV	EAX,ECX
		CALL	READ_LIBRARY_BLOCK

		MOV	EAX,[EBX]
		JMP	L5$

L2$:
		MOV	EAX,CURN_LS_BLOCK_TABLE_PTR

		MOV	EBX,[EAX]
		ADD	EAX,4

		MOV	CURN_LS_BLOCK_TABLE_PTR,EAX
		LEA	EAX,[EBX + PAGE_SIZE]

		MOV	CURN_LIB_BLOCK_PTR_LIMIT,EAX
		JMP	L1$

L5$:
L51$:
		MOV	EBX,OBJ_DEVICE
		ASSUME	EBX:PTR MYI_STRUCT
		MOV	ECX,CURN_LIB_BLOCK

		MOV	EDX,CURNLIB_GINDEX
		CONVERT	EDX,EDX,LIBRARY_GARRAY
		ASSUME	EDX:PTR LIBRARY_STRUCT
		INC	ECX

		MOV	[EBX].MYI_PTRA,EAX
		MOV	[EBX].MYI_BLOCK,EAX

		MOV	EDX,[EDX]._LS_BLOCKS
		MOV	EAX,FILNAM.NFN_FILE_LENGTH

		CMP	EDX,ECX
		JZ	L55$
L56$:
		MOV	EAX,PAGE_SIZE
L6$:
		MOV	[EBX].MYI_COUNT,EAX
		POP	EBX

		RET

L55$:
		AND	EAX,PAGE_SIZE-1
		JNZ	L6$
		JMP	L56$

READLIB_16K	ENDP

		ASSUME	ECX:NOTHING,EDX:NOTHING,EBX:NOTHING


		public	xGET_FIRST_SECTOR
xGET_FIRST_SECTOR	PROC
		;
		;
		;
if	fgh_inthreads
		BITT	_HOST_THREADED
		JZ	L5$

		MOV	EAX,OBJ_DEVICE
		ASSUME	EAX:PTR MYI_STRUCT

		MOV	ECX,[EAX].MYI_LOCALS
		ASSUME	ECX:PTR MYI2_STRUCT

		IMUL	EDX,[ECX].MYI2_NEXT_OPEN_FILE,SIZE OPEN_STRUCT

		LEA	EAX,[ECX].OPENFILE_HEADER_SEM

		LEA	ECX,[ECX+EDX].MYI2_OPEN_STRUC
		ASSUME	ECX:PTR OPEN_STRUCT
		CALL	CAPTURE_EAX

		LEA	EAX,[ECX].OPENFILE_HEADER

		RET

endif

L5$:
		;
		;ALLOCATE A PLACE TO PUT FIRST SECTOR OF LIBRARY FILE
		;
		MOV	EAX,OBJ_DEVICE
		MOV	EDX,OFF LIB_HEADER

		XOR	ECX,ECX
		PUSH	EDX

		MOV	CL,16

		push	EBX	; save
		push	EDX
		push	ECX
		push	EAX
		call	_dosread
		add	ESP,12
		pop	EBX

		POP	EAX
		RET

xGET_FIRST_SECTOR	ENDP


		public	xREAD_NEXT_DIRECTORY_BLOCK
xREAD_NEXT_DIRECTORY_BLOCK	PROC
		;
		;RETURN NEXT DIRECTORY BLOCK IN DS:BX
		;
if	fgh_inthreads
		BITT	_HOST_THREADED
		JZ	L5$

		MOV	EAX,OBJ_DEVICE
		ASSUME	EAX:PTR MYI_STRUCT

		push	EAX
		call	_read_16k_threaded
		add	ESP,4

		XOR	ECX,ECX
		MOV	EDX,[EAX].MYI_BLOCK

		MOV	[EAX].MYI_BLOCK,ECX
		MOV	[EAX].MYI_PTRA,ECX

		MOV	EAX,EDX

		YIELD

		RET

endif
L5$:
		;
		;ALLOCATE A PLACE TO PUT FIRST SECTOR OF LIBRARY FILE
		;
		MOV	ECX,DICT_BLOCKS
		CALL	GET_NEW_IO_LOG_BLK

		MOV	EDX,EAX
		MOV	CURN_DICT_LOG,EAX

		CMP	ECX,PAGE_SIZE/512	;MAX DIRS PER PAGE
		JBE	L1$
		MOV	ECX,PAGE_SIZE/512
L1$:
		MOV	EAX,OBJ_DEVICE
		PUSH	EDX

		SHL	ECX,9

		push	EBX	; save
		push	EDX
		push	ECX
		push	EAX
		call	_dosread
		add	ESP,12
		pop	EBX

		POP	EAX

		RET

xREAD_NEXT_DIRECTORY_BLOCK	ENDP


		END

