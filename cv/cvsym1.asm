		TITLE	CVSYM1 - Copyright (c) SLR Systems 1995

		OPTION PROC:PRIVATE

		INCLUDE	MACROS

if	fg_cvpack

		INCLUDE	CVTYPES

		PUBLIC	PROCESS_CV_SYM1_SYMBOLS


		.DATA

		EXTERNDEF	TEMP_RECORD:BYTE

		EXTERNDEF	EXETABLE:DWORD,FIX2_SM_LEN:DWORD,BYTES_SO_FAR:DWORD,LAST_PEOBJECT_NUMBER:DWORD
		EXTERNDEF	CV_SEGMENT_COUNT:DWORD,CV_ASYM_STRUCTURE:SEQ_STRUCT


		.CODE	CVPACK_TEXT

		EXTERNDEF	INSTALL_GSYM:PROC,INSTALL_GSYM_REF:PROC,INSTALL_SSYM:PROC,SKIP_LEAF_ECX:PROC

		EXTERNDEF	RELEASE_EXETABLE_ALL:PROC,ERR_RET:PROC,WARN_RET:PROC
		EXTERNDEF	_err_abort:proc,RELEASE_BLOCK:PROC,GET_NEW_LOG_BLK:PROC
		EXTERNDEF	STORE_EAXECX_EDX_SEQ:PROC,STORE_EAXECX_EDXEBX_RANDOM:PROC
		EXTERNDEF	READ_EAXECX_EDXEBX_RANDOM:PROC,FLUSH_EAX_TO_FINAL:PROC,WRITE_CV_INDEX:PROC

		EXTERNDEF	CVP_CORRUPT_ERR:ABS,CVP_SYMDEL_ERR:ABS,CVP_SCOPE_ERR:ABS,CVP_NEST_SEG_ERR:ABS
		EXTERNDEF	CVP_BLOCK_WO_PARENT_ERR:ABS,CVP_SSEARCH_ERR:ABS,CVP_SYMBOLS_64K_ERR:ABS


CVSYMBOLS_VARS		STRUC

CV_SCOPE_NEST_TABLE_BP	DB	256 DUP(?)	;SCOPES CAN NEST 256 LEVELS

CV_DELETE_FLAG_BP	DB	?
			DB	?
			DW	?

CV_SYM_RELEASE_BP	DB	?
			DB	?
			DW	?

CV_SCOPE_LEVEL_BP	DD	?
CV_BYTES_LEFT_BP	DD	?
CV_THIS_BLOCK_BP	DD	?
CV_THIS_BLOCK_LIMIT_BP	DD	?
CV_NEXT_BLOCK_BP	DD	?
CV_BYTES_PTR_BP		DD	?
CV_ID_LB_BP		DD	?
CV_ID_LIMIT_BP		DD	?
CV_SSEARCH_TBL_BP	DD	?
CV_SSEARCH_BLOCK_BP	DD	?
CV_SSEARCH_CNT_BP	DD	?
CV_PPARENT_BP		DD	?
CV_PPARENT_SEGMENT_BP	DD	?
CV_NEXT_SSEARCH_BP	DD	?
CV_TEMP_DWORD_BP	DD	?

CVSYMBOLS_VARS		ENDS


FIX	MACRO	X

X	EQU	([EBP-SIZE CVSYMBOLS_VARS].(X&_BP))

	ENDM


FIX	CV_SCOPE_NEST_TABLE
FIX	CV_SCOPE_LEVEL
FIX	CV_DELETE_FLAG
FIX	CV_SYM_RELEASE
FIX	CV_BYTES_LEFT
FIX	CV_THIS_BLOCK
FIX	CV_THIS_BLOCK_LIMIT
FIX	CV_NEXT_BLOCK
FIX	CV_BYTES_PTR
FIX	CV_ID_LB
FIX	CV_ID_LIMIT
FIX	CV_SSEARCH_TBL
FIX	CV_SSEARCH_BLOCK
FIX	CV_SSEARCH_CNT
FIX	CV_PPARENT
FIX	CV_PPARENT_SEGMENT
FIX	CV_NEXT_SSEARCH
FIX	CV_TEMP_DWORD


CV_SSEARCH_PTRS	EQU	DWORD PTR CV_SCOPE_NEST_TABLE


GET_CV_ASYM_OFFSET	MACRO
		;
		;
		;
		MOV	EAX,CV_ASYM_STRUCTURE._SEQ_PTR

		ENDM


PROCESS_CV_SYM1_SYMBOLS	PROC
		;
		;CONVERT CV4 SYMBOLS SEGMENT INTO ALIGNSYM AND GLOBALSYM
		;
		PUSHM	EBP,EDI,ESI,EBX

		MOV	EBP,ESP
		SUB	ESP,SIZE CVSYMBOLS_VARS
		ASSUME	EBP:PTR CVSYMBOLS_VARS

		XOR	EAX,EAX

		MOV	CV_SCOPE_LEVEL,EAX
		MOV	CV_BYTES_PTR,EAX

		MOV	DPTR CV_DELETE_FLAG,EAX
		MOV	DPTR CV_SYM_RELEASE,EAX

		MOV	CV_SSEARCH_CNT,EAX
		MOV	CV_SSEARCH_TBL,EAX

		CALL	INIT_CV_READER			;ESI IS POINTER
		;
		;FIRST PASS
		;
		;	1.  CHANGE SYMBOL IDs TO INTERNAL FORMAT
		;	2.  DETERMINE SYMBOLS TO DELETE BASED ON UNUSED COMDATS
		;	3.  COUNT NUMBER OF S_SSEARCH SYMBOLS WE WILL NEED
		;	4.  MOVE GDATAxx, AND UNSCOPED UDT AND CONSTANT SYMBOLS TO GLOBALSYM TABLE
		;
		CALL	GET_CV_DWORD

		CMP	EAX,'1MYS'
		JNZ	L9$

		CALL	GET_NEW_LOG_BLK

		MOV	CV_SSEARCH_TBL,EAX
		MOV	EDI,EAX

		XOR	EAX,EAX
		MOV	ECX,CV_SEGMENT_COUNT
if	fg_pe
		BITT	OUTPUT_PE
		JZ	L05$

		MOV	ECX,LAST_PEOBJECT_NUMBER
L05$:
endif
		SHRI	ECX,5			;1 BIT PER SEGMENT

		INC	ECX

		REP	STOSD

		LEA	EDI,CV_ASYM_STRUCTURE
		MOV	ECX,SIZE SEQ_STRUCT/4+ 1K*1K/PAGE_SIZE/4

		REP	STOSD

		JMP	L2$

L1$:
		CALL	GET_CV_SYMBOL		;GET PTR TO NEXT SYMBOL, SYMBOL ID ADJUSTED

		CALL	PROCSYM_PASS1[EBX*4]	;PROCESS BASED ON SYMBOL ID

		CALL	PUT_CV_SYMBOL		;STORE RESULT IF NOT DELETED

L2$:
		MOV	EAX,CV_BYTES_LEFT

		OR	EAX,EAX
		JNZ	L1$
		;
		;MIDDLE
		;
		;	0.  OUTPUT 'SYM1' Signature
		;	1.  OUTPUT S_SEARCH SYMBOLS
		;
		MOV	EAX,CV_SSEARCH_TBL
		CALL	RELEASE_BLOCK

		MOV	EAX,OFF SYM_ONE
		MOV	ECX,4

		LEA	EDX,CV_ASYM_STRUCTURE
		CALL	STORE_EAXECX_EDX_SEQ

		CALL	DO_SSEARCH_SYMS

		;
		;SECOND PASS
		;
		;	1.  IGNORE DELETED SYMBOLS
		;	2.  LINK SCOPES PER LOGICAL SEGMENT
		;	3.  CREATE STATICSYM ENTRIES FOR LPROCs AND LDATAs
		;	4.  CREATE GLOBALSYM PROCREF ENTRIES FOR GPROCs
		;	5.  CHANGE SYMBOL IDs TO EXTERNAL FORMAT
		;	6.  COPY SYMBOLS TO REAL OUTPUT
		;	7.  ADD S_ALIGN SYMBOLS AS NECESSARY	*** NO! ***
		;

		MOV	CV_SYM_RELEASE,-1

		CALL	INIT_CV_READER

		CALL	GET_CV_DWORD		;SKIP SIGNATURE

		XOR	EAX,EAX
		MOV	CV_BYTES_PTR,ESI

		MOV	CV_PPARENT,EAX
		JMP	L7$

L9$:
		CALL	RELEASE_EXETABLE_ALL
		JMP	L99$

L5$:
		CALL	GET_CV_SYMBOL2		;GET SYMBOL, PASS2

		CALL	PROCSYM_PASS2[EBX*4]	;PROCESS BASED ON SYMBOL ID

		CALL	PUT_CV_SYMBOL2		;OUTPUT IF NOT DELETED

L7$:
		MOV	EAX,CV_BYTES_LEFT

		OR	EAX,EAX
		JNZ	L5$

		CALL	ADJUST_CV_PTR		;RELEASE CURRENT (LAST) BLOCK
		;
		;CLEAN-UP
		;
		;	1.  OUTPUT ALIGNSYM SECTION AND CV_INDEX IF NOT ZERO LENGTH
		;
		CALL	CV_SYMBOL_CLEANUP
L99$:
		MOV	ESP,EBP

		POPM	EBX,ESI,EDI,EBP

		RET

PROCESS_CV_SYM1_SYMBOLS	ENDP


PP1_PASS_THRU	PROC	NEAR
		;
		;KEEP SYMBOL NO MATTER WHAT
		;
		RET

PP1_PASS_THRU	ENDP


PP1_LDATA16	PROC	NEAR
		;
		;
		;
		ASSUME	ESI:PTR cvLData16Struct

		MOV	CL,CV_DELETE_FLAG
		MOV	AL,BPTR [ESI].Segm+1	;SEGMENT IS HIGH WORD

		OR	CL,CL
		JNZ	PP1_DELETE

		AND	AL,7FH

		MOV	BPTR [ESI].Segm+1,AL

		RET

		ASSUME	ESI:NOTHING

PP1_LDATA16	ENDP


PP1_PASS_ND	PROC	NEAR
		;
		;KEEP SYMBOL IF NOT DELETING CURRENT SCOPE
		;
		MOV	AL,CV_DELETE_FLAG
PP1_PASS_ND_AL::
		OR	AL,AL
		JNZ	PP1_DELETE

		RET

PP1_PASS_ND	ENDP


PP1_CONSTANT	PROC	NEAR
		;
		;DELETE IF DELETING CURRENT SCOPE
		;GLOBALIZE IF NEST LEVEL == 0
		;
		ASSUME	ESI:PTR cvConstStruct

		MOV	ECX,CV_SCOPE_LEVEL
		MOV	AL,CV_DELETE_FLAG

		OR	ECX,ECX
		JNZ	PP1_PASS_ND_AL
		;
		;STORE IN COMPACTED GLOBAL TABLE
		;
		LEA	ECX,[ESI].Value
		CALL	SKIP_LEAF_ECX

		JMP	INSTALL_GSYM		;PUT IN GLOBAL SYMBOL TABLE, ESI IS SYMBOL, ECX IS NAME PORTION

		ASSUME	ESI:NOTHING

PP1_CONSTANT	ENDP


PP1_UDT		PROC	NEAR
		;
		;DELETE IF DELETING CURRENT SCOPE
		;GLOBALIZE IF NEST LEVEL == 0
		;
		ASSUME	ESI:PTR cvUDTStruct

		MOV	ECX,CV_SCOPE_LEVEL
		MOV	AL,CV_DELETE_FLAG

		OR	ECX,ECX
		JNZ	PP1_PASS_ND_AL
		;
		;STORE IN COMPACTED GLOBAL TABLE
		;
		LEA	ECX,[ESI].Nam
		JMP	INSTALL_GSYM		;PUT IN GLOBAL SYMBOL TABLE, ESI IS SYMBOL, ECX IS NAME PORTION

		ASSUME	ESI:NOTHING

PP1_UDT		ENDP


PP1_S_END	PROC	NEAR
		;
		;END OF A CODE BLOCK
		;
		ASSUME	ESI:PTR cvSymbolStruct

		MOV	ECX,CV_SCOPE_LEVEL
		MOV	AL,CV_DELETE_FLAG

		SUB	ECX,1
		JC	PP1_W_DELETE

		MOV	CV_SCOPE_LEVEL,ECX
		OR	AL,AL			;THIS LEVEL BEING DELETED?

		MOV	AL,CV_SCOPE_NEST_TABLE[ECX]
		JZ	L2$

		MOV	BL,I_S_DELETE		;MARK SYMBOL DELETED

		MOV	BPTR [ESI].ID,BL
L2$:
		;
		;DEFINE DELETE FLAG BASED ON PARENT
		;
		MOV	CV_DELETE_FLAG,AL

		RET

PP1_S_END	ENDP


PP1_W_DELETE	PROC	NEAR
		;
		;
		;
		MOV	AL,CVP_SYMDEL_ERR
		CALL	WARN_RET

PP1_W_DELETE	ENDP


PP1_DELETE	PROC	NEAR

		MOV	BL,I_S_DELETE	;MARK SYMBOL DELETED

		MOV	BPTR [ESI].ID,BL

		RET

PP1_DELETE	ENDP


PP1_S_GDATA16	PROC	NEAR
		;
		;DELETE IF NEEDED
		;
		ASSUME	ESI:PTR cvGData16Struct

		MOV	CL,CV_DELETE_FLAG
		MOV	AL,BPTR [ESI].Segm+1

		OR	CL,CL
		JNZ	PP1_DELETE

		AND	AL,7FH
		LEA	ECX,[ESI].Nam

		;
		;STORE IN COMPACTED GLOBAL TABLE
		;
		MOV	BPTR [ESI].Segm+1,AL
		JMP	INSTALL_GSYM		;PUT IN GLOBAL SYMBOL TABLE, ESI IS SYMBOL, ECX IS NAME PORTION
						;MARK DELETE IF INSTALL WORKS...
		ASSUME	ESI:NOTHING

PP1_S_GDATA16	ENDP


PP1_PROC16	PROC	NEAR
		;
		;PROCEDURE START...  FIRST DETERMINE IF THIS CODESEG IS MINE
		;
		ASSUME	ESI:PTR cvLProc16Struct

		MOV	CL,BPTR [ESI].Segm

		MOV	CH,BPTR [ESI].Segm+1
PP1_PROC16_1::
		CALL	IS_MY_CODESEG		;IS THIS IN MY MODULE HEADER?  ALSO, COUNT SEG REFS

		JZ	NEST_SCOPE_ON

		CALL	NEST_SCOPE_OFF

		JMP	PP1_DELETE

		ASSUME	ESI:NOTHING

PP1_PROC16	ENDP


NEST_SCOPE_OFF:
		MOV	AL,-1
		JMP	NEST_SCOPE_1


NEST_SCOPE_ON	PROC	NEAR
		;
		;
		;
		MOV	AL,0
NEST_SCOPE_1::
		MOV	ECX,CV_SCOPE_LEVEL
		MOV	AH,CV_DELETE_FLAG

		MOV	CV_DELETE_FLAG,AL

		MOV	CV_SCOPE_NEST_TABLE[ECX],AH
		INC	CL			;TO DETECT 256 OVEFLOW...

		MOV	CV_SCOPE_LEVEL,ECX
		JZ	L9$

		RET

L9$:
		MOV	AL,CVP_SCOPE_ERR
		push	EAX
		call	_err_abort

NEST_SCOPE_ON	ENDP


PP1_THUNK16	PROC	NEAR
		;
		;THUNK...  FIRST DETERMINE IF THIS CODESEG IS MINE
		;
		ASSUME	ESI:PTR CV_THUNK16_STRUCT

		MOV	CL,BPTR [ESI]._SEGMENT

		MOV	CH,BPTR [ESI]._SEGMENT+1
		JMP	PP1_PROC16_1

		ASSUME	ESI:NOTHING

PP1_THUNK16	ENDP


PP1_BLOCK16	PROC	NEAR
		;
		;
		;
		ASSUME	ESI:PTR CV_BLOCK16_STRUCT

		MOV	CL,BPTR [ESI]._SEGMENT

		MOV	CH,BPTR [ESI]._SEGMENT+1
		JMP	PP1_PROC16_1

		ASSUME	ESI:NOTHING

PP1_BLOCK16	ENDP


PP1_LABEL16	PROC	NEAR
		;
		;
		;
		ASSUME	ESI:PTR CV_LABEL16_STRUCT

		MOV	AL,BPTR [ESI]._SEGMENT+1

		TEST	AL,80H
		JNZ	PP1_DELETE

		RET

		ASSUME	ESI:NOTHING

PP1_LABEL16	ENDP


PP1_CEXMODEL16	PROC	NEAR
		;
		;
		;
		AND	BPTR [ESI].CV_CEXMODEL16_STRUCT._SEGMENT+1,7FH

		RET

PP1_CEXMODEL16	ENDP


PP1_VFTPATH16	PROC	NEAR
		;
		;
		;
		AND	BPTR [ESI].cvVFTPath16Struct.Segm+1,7FH

		RET

PP1_VFTPATH16	ENDP


PP1_LDATA32	PROC	NEAR
		;
		;
		;
		ASSUME	ESI:PTR cvLData32Struct

		MOV	CL,CV_DELETE_FLAG
		MOV	AL,BPTR [ESI].Segm+1

		OR	CL,CL
		JNZ	PP1_DELETE

		AND	AL,7FH

		MOV	BPTR [ESI].Segm+1,AL

		RET

		ASSUME	ESI:NOTHING

PP1_LDATA32	ENDP


PP1_S_GDATA32	PROC	NEAR
		;
		;DELETE IF NEEDED
		;
		ASSUME	ESI:PTR cvGData32Struct

		MOV	CL,CV_DELETE_FLAG
		MOV	AL,BPTR [ESI].Segm+1

		OR	CL,CL
		JNZ	PP1_DELETE

		AND	AL,7FH
		LEA	ECX,[ESI].Nam

		;
		;STORE IN COMPACTED GLOBAL TABLE
		;
		MOV	BPTR [ESI].Segm+1,AL
		JMP	INSTALL_GSYM		;PUT IN GLOBAL SYMBOL TABLE, ESI IS SYMBOL, ECX IS NAME PORTION
						;MARK DELETE IF INSTALL WORKS...
		ASSUME	ESI:NOTHING

PP1_S_GDATA32	ENDP


PP1_PROC32	PROC	NEAR
		;
		;PROCEDURE START...  FIRST DETERMINE IF THIS CODESEG IS MINE
		;
		ASSUME	ESI:PTR cvGProc32Struct

		MOV	CL,BPTR [ESI].Segm

		MOV	CH,BPTR [ESI].Segm+1
PP1_PROC32_1::
		CALL	IS_MY_CODESEG		;IS THIS IN MY MODULE HEADER?  ALSO, COUNT SEG REFS
		JZ	NEST_SCOPE_ON

		CALL	NEST_SCOPE_OFF

		JMP	PP1_DELETE

		ASSUME	ESI:NOTHING

PP1_PROC32	ENDP


PP1_THUNK32	PROC	NEAR
		;
		;THUNK...  FIRST DETERMINE IF THIS CODESEG IS MINE
		;
		ASSUME	ESI:PTR CV_THUNK32_STRUCT

		MOV	CL,BPTR [ESI]._SEGMENT

		MOV	CH,BPTR [ESI]._SEGMENT+1
		JMP	PP1_PROC32_1

PP1_THUNK32	ENDP


PP1_BLOCK32	PROC	NEAR
		;
		;
		;
		ASSUME	ESI:PTR CV_BLOCK32_STRUCT

		MOV	CL,BPTR [ESI]._SEGMENT

		MOV	CH,BPTR [ESI]._SEGMENT+1
		JMP	PP1_PROC32_1

PP1_BLOCK32	ENDP

		ASSUME	ESI:NOTHING

PP1_LABEL32	PROC	NEAR
		;
		;
		;
		MOV	AL,BPTR [ESI].CV_LABEL32_STRUCT._SEGMENT+1

		TEST	AL,80H
		JNZ	PP1_DELETE

		RET

PP1_LABEL32	ENDP


PP1_CEXMODEL32	PROC	NEAR
		;
		;
		;
		AND	BPTR [ESI].CV_CEXMODEL32_STRUCT._SEGMENT+1,7FH

		RET

PP1_CEXMODEL32	ENDP


PP1_VFTPATH32	PROC	NEAR
		;
		;
		;
		AND	BPTR [ESI].cvVFTPath32Struct.Segm+1,7FH

		RET

PP1_VFTPATH32	ENDP


INIT_CV_READER	PROC	NEAR	PRIVATE
		;
		;SET UP STUFF FOR SCANNING THROUGH A CODEVIEW SEGMENT
		;
		MOV	EAX,FIX2_SM_LEN
		XOR	ECX,ECX

		MOV	CV_BYTES_LEFT,EAX
		MOV	EAX,OFF EXETABLE

		MOV	CV_THIS_BLOCK,ECX
		MOV	CV_NEXT_BLOCK,EAX

;		CALL	ADJUST_CV_PTR
;		RET

INIT_CV_READER	ENDP


ADJUST_CV_PTR	PROC	NEAR	PRIVATE
		;
		;
		;
		MOV	EDX,CV_NEXT_BLOCK		;EXETABLE
		MOV	AL,CV_SYM_RELEASE

		MOV	ECX,CV_THIS_BLOCK
		OR	AL,AL

		MOV	EAX,[EDX]			;HAVE NEXT BLOCK LOADED
		JZ	L2$

		TEST	ECX,ECX					;DOES THIS BLOCK EXIST?
		JZ	L1$

		MOV	EAX,ECX
		CALL	RELEASE_BLOCK
L1$:
		XOR	ECX,ECX
		MOV	EAX,[EDX]

		MOV	[EDX],ECX
L2$:
		ADD	EDX,4
		MOV	CV_THIS_BLOCK,EAX

		OR	EAX,EAX
		JZ	L9$

		MOV	ESI,EAX
		ADD	EAX,PAGE_SIZE

		MOV	CV_NEXT_BLOCK,EDX
		MOV	CV_THIS_BLOCK_LIMIT,EAX

		RET

L9$:
		STC

		RET

ADJUST_CV_PTR	ENDP


GET_CV_DWORD	PROC	NEAR	PRIVATE
		;
		;
		;
		ADD	ESI,4
		MOV	ECX,CV_BYTES_LEFT

		MOV	EAX,CV_THIS_BLOCK_LIMIT
		SUB	ECX,4

		CMP	EAX,ESI
		JB	L5$

		MOV	CV_BYTES_LEFT,ECX
		MOV	EAX,[ESI-4]

		RET

L5$:
		SUB	ESI,4
		CALL	GET_CV_WORD

		JC	L9$

		PUSH	EAX
		CALL	GET_CV_WORD

		POP	EDX
		JC	L9$

		SHL	EAX,16
		AND	EDX,0FFFFH

		OR	EAX,EDX

		RET

L9$:
		MOV	AL,-1

		RET

GET_CV_DWORD	ENDP


GET_CV_WORD	PROC	NEAR	PRIVATE
		;
		;
		;
		ADD	ESI,2
		MOV	EAX,CV_THIS_BLOCK_LIMIT

		CMP	EAX,ESI
		JB	L5$

		XOR	EAX,EAX
		MOV	ECX,CV_BYTES_LEFT

		MOV	AL,[ESI-2]
		SUB	ECX,2

		MOV	AH,[ESI-1]
		MOV	CV_BYTES_LEFT,ECX
L9$:
		RET

L5$:
		SUB	ESI,2
		CALL	GET_CV_BYTE

		JC	L9$

		PUSH	EAX
		CALL	GET_CV_BYTE

		MOV	AH,AL
		JC	L99$

		AND	EAX,0FFFFH
L99$:
		POP	EDX

		MOV	AL,DL

		RET

GET_CV_WORD	ENDP


GET_CV_BYTE	PROC	NEAR	PRIVATE
		;
		;
		;
L1$:
		INC	ESI
		MOV	ECX,CV_BYTES_LEFT

		MOV	EAX,CV_THIS_BLOCK_LIMIT
		DEC	ECX

		CMP	EAX,ESI
		JB	L5$

		MOV	CV_BYTES_LEFT,ECX
		MOV	AL,[ESI-1]

		RET

L5$:
		DEC	ESI
		CALL	ADJUST_CV_PTR

		JNC	L1$

		RET

GET_CV_BYTE	ENDP


MOVE_EAX_CV_BYTES	PROC	NEAR	PRIVATE
		;
		;NEED TO MOVE SMALLER OF EAX AND PAGE_SIZE-SI
		;
		MOV	ECX,CV_THIS_BLOCK_LIMIT
		MOV	EDX,CV_BYTES_LEFT

		SUB	ECX,ESI
		SUB	EDX,EAX

		MOV	CV_BYTES_LEFT,EDX
		JC	L9$
L1$:
		SUB	EAX,ECX
		JA	L5$

		ADD	ECX,EAX
		XOR	EAX,EAX
L5$:
		OPTI_MOVSB

		OR	EAX,EAX
		JNZ	L3$
L9$:
		RET

L3$:
		;
		;GET NEXT BLOCK
		;
		PUSH	EAX
		CALL	ADJUST_CV_PTR

		POP	EAX
		MOV	ECX,PAGE_SIZE

		JNC	L1$

		RET

MOVE_EAX_CV_BYTES	ENDP


GET_CV_SYMBOL	PROC	NEAR
		;
		;RETURN ESI PTR TO SYMBOL, EBX IS TYPE
		;
		XOR	EBX,EBX
		CALL	GET_CV_WORD		;LENGTH OF SYMBOL RECORD

		MOV	ECX,CV_THIS_BLOCK
		JC	L99$			;WORD WASN'T THERE

		CMP	EAX,2
		JB	L99$			;MUST HAVE ID

		ADD	ECX,2
		CMP	EAX,MAX_RECORD_LEN

		MOV	EDX,ESI
		JA	L99$			;TOO BIG

		CMP	EDX,ECX			;DOES THIS SYMBOL CROSS BLOCK BOUNDS?
		JB	L51$			;YES, IF ESI IS SMALLER THAN THIS_BLOCK + 2

		LEA	EDX,[ESI+EAX]
		MOV	ECX,CV_THIS_BLOCK_LIMIT

		CMP	EDX,ECX			;YES, IF ESI + LENGTH IS > THIS_BLOCK_LIMIT
		JA	L51$

		MOV	ECX,CV_BYTES_LEFT
		SUB	ESI,2

		ASSUME	ESI:PTR cvSymbolStruct

		SUB	ECX,EAX
		JC	L99$

		MOV	BH,BPTR [ESI].ID+1
		MOV	CV_BYTES_LEFT,ECX
L2$:
		CMP	BH,1
		JB	L27$

		MOV	BL,BPTR [ESI].ID
		JA	L25$
		;
		;BX IS 100 - 1FF
		;
		SUB	EBX,100H-10H

		MOV	BPTR [ESI].ID,BL
		CMP	BL,1CH

		MOV	BPTR [ESI].ID+1,BH
		JA	L28$
L23$:
		RET

L25$:
		SUB	EBX,200H-1DH

		MOV	BPTR [ESI].ID,BL
		CMP	EBX,2AH

		MOV	BPTR [ESI].ID+1,BH
		JAE	L28$

		RET

L27$:
		;
		;BX < 100H
		;
		MOV	BL,BPTR [ESI].ID

		CMP	BL,0FH
		JA	L28$

		RET

L28$:
		XOR	EBX,EBX

		MOV	[ESI].ID,BX

		RET

L99$:
		MOV	AL,CVP_CORRUPT_ERR
		CALL	ERR_RET

		STC

		RET

L51$:
		;
		;SYMBOL CROSSES BLOCK BOUNDS
		;
		PUSH	EDI
		MOV	EDI,OFF TEMP_RECORD+4

		PUSH	EAX
		CALL	GET_CV_BYTE

		MOV	DL,AL
		MOV	EAX,CV_THIS_BLOCK_LIMIT

		MOV	CV_ID_LB,ESI		;ESI POINTS 1 PAST ID LOW BYTE
		MOV	CV_ID_LIMIT,EAX

		PUSH	EDX
		CALL	GET_CV_BYTE

		POP	EDX

		MOV	DH,AL
		POP	EAX

		SHL	EDX,16

		OR	EDX,EAX
		SUB	EAX,2

		MOV	[EDI-4],EDX
		JBE	L6$

		CALL	MOVE_EAX_CV_BYTES
L6$:
		MOV	CV_BYTES_PTR,ESI
		MOV	ESI,OFF TEMP_RECORD

		MOV	BH,BPTR TEMP_RECORD.cvSymbolStruct.ID+1
		POP	EDI

		JMP	L2$

		ASSUME	ESI:NOTHING

GET_CV_SYMBOL	ENDP


PUT_CV_SYMBOL	PROC	NEAR
		;
		;UPDATE PTRS
		;
		ASSUME	ESI:PTR cvSymbolStruct

		XOR	ECX,ECX
		MOV	EAX,CV_BYTES_PTR

		MOV	CL,BPTR [ESI].Len
		TEST	EAX,EAX

		MOV	CH,BPTR [ESI].Len+1
		JNZ	L1$

		LEA	ESI,[ESI+ECX+2]

		RET

L1$:
		;
		;TRICKY TO HANDLE MODIFICATION...
		;
		MOV	EDI,CV_ID_LB			;ONE PAST ID LOW BYTE
		MOV	EAX,ECX

		DEC	EDI
		MOV	ECX,CV_ID_LIMIT

		LEA	ESI,[ESI].ID
		SUB	ECX,EDI			;EAX IS BYTES TO MOVE, ECX IS MAX LEFT THIS BLOCK

		CMP	ECX,EAX
		JAE	L5$

		SUB	EAX,ECX

		OPTI_MOVSB

		MOV	EDI,CV_BYTES_PTR

		SUB	EDI,EAX
L5$:
		MOV	ECX,EAX

		OPTI_MOVSB

		MOV	ESI,CV_BYTES_PTR
		MOV	CV_BYTES_PTR,ECX

		RET

		ASSUME	ESI:NOTHING

PUT_CV_SYMBOL	ENDP


IS_MY_CODESEG	PROC	NEAR
		;
		;CX IS SEGMENT
		;
		OR	CH,CH
		JS	L9$

		AND	ECX,0FFFFH
		JZ	L8$
		;
		;WE ARE KEEPING, HAVE WE REFERENCED THIS SEGMENT BEFORE?
		;
		MOV	EDX,CV_SEGMENT_COUNT
		MOV	EAX,ECX

		CMP	EDX,ECX
		JB	L8$

		SHR	EAX,3			;THAT BYTE
		MOV	CH,1

		MOV	EDX,CV_SSEARCH_TBL
		AND	CL,7

		SHL	CH,CL

		MOV	CL,[EDX+EAX]
		PUSH	EBX

		TEST	CL,CH
		JNZ	L5$

		MOV	EBX,CV_SSEARCH_CNT
		OR	CL,CH

		INC	EBX
		MOV	[EDX+EAX],CL

		MOV	CV_SSEARCH_CNT,EBX
L5$:
		POP	EBX
		CMP	AL,AL

		RET

L8$:
		OR	AL,-1
L9$:
		RET

IS_MY_CODESEG	ENDP


DO_SSEARCH_SYMS	PROC	NEAR
		;
		;OUTPUT S_SSEARCH SYMBOLS, SET UP NECESSARY ARRAYS
		;
		MOV	EDX,CV_SSEARCH_CNT	;# OF START_SEARCH SYMBOLS NEEDED

		TEST	EDX,EDX
		JZ	L9$

		PUSH	EDI
		MOV	EDI,EDX
L1$:
		MOV	ECX,CV_SSEARCH_TXT_LEN
		LEA	EDX,CV_ASYM_STRUCTURE

		MOV	EAX,OFF CV_SSEARCH_TXT
		CALL	STORE_EAXECX_EDX_SEQ

		DEC	EDI
		JNZ	L1$

		MOV	ECX,CV_SSEARCH_CNT
		LEA	EDI,CV_SSEARCH_PTRS

		CMP	ECX,8
		JA	L5$			;TOO MANY, DO THE HARD WAY
L4$:
		ADD	ECX,ECX
		XOR	EAX,EAX

		REP	STOSD

		MOV	CV_NEXT_SSEARCH,4	;SKIP LEADING 00000001
		POP	EDI
L9$:
		RET


L5$:
		CMP	ECX,PAGE_SIZE/8
		JAE	L99$

		CALL	GET_NEW_LOG_BLK

		MOV	EDI,EAX
		MOV	CV_SSEARCH_PTRS,EAX

		JMP	L4$

L99$:
		MOV	AL,CVP_SSEARCH_ERR
		push	EAX
		call	_err_abort

DO_SSEARCH_SYMS	ENDP


GET_CV_SYMBOL2	PROC	NEAR
		;
		;RETURN ESI PTR TO SYMBOL
		;
		MOV	ESI,CV_BYTES_PTR
		CALL	GET_CV_DWORD		;LENGTH OF SYMBOL RECORD & ID

		MOV	ECX,EAX
		MOV	DPTR TEMP_RECORD,EAX

		SHR	ECX,16
		AND	EAX,0FFFFH

		SUB	EAX,2			;ID ALREADY STORED
		MOV	EDI,OFF TEMP_RECORD+4

		CMP	CL,I_S_DELETE
		JZ	L9$

		CALL	MOVE_EAX_CV_BYTES

		MOV	EBX,DPTR TEMP_RECORD
		MOV	CL,2

		SUB	ECX,EBX
		MOV	CV_BYTES_PTR,ESI

		SHR	EBX,16
		MOV	ESI,OFF TEMP_RECORD

		AND	ECX,3			;DOING DWORD ALIGN
		JZ	L5$

		ADD	WPTR [ESI],CX
		XOR	EAX,EAX
L3$:
		MOV	[EDI],AL
		INC	EDI

		DEC	ECX
		JNZ	L3$
L5$:
		RET

L9$:
		MOV	EBX,ECX
		CALL	SKIP_EAX_CV_BYTES

		MOV	CV_BYTES_PTR,ESI
		MOV	ESI,OFF TEMP_RECORD

		RET

GET_CV_SYMBOL2	ENDP


SKIP_EAX_CV_BYTES	PROC	NEAR	PRIVATE
		;
		;NEED TO SKIP SMALLER OF EAX AND PAGE_SIZE-SI
		;
		MOV	ECX,CV_THIS_BLOCK_LIMIT
		MOV	EDX,CV_BYTES_LEFT

		SUB	ECX,ESI
		SUB	EDX,EAX

		MOV	CV_BYTES_LEFT,EDX
		JC	L9$
L1$:
		SUB	EAX,ECX
		JA	L5$

		ADD	ECX,EAX
		XOR	EAX,EAX
L5$:
		ADD	EDI,ECX
		ADD	ESI,ECX

		XOR	ECX,ECX

		OR	EAX,EAX
		JNZ	L3$
L9$:
		RET

L3$:
		;
		;GET NEXT BLOCK
		;
		PUSH	EAX
		CALL	ADJUST_CV_PTR

		POP	EAX
		MOV	ECX,PAGE_SIZE

		JNC	L1$

		RET

SKIP_EAX_CV_BYTES	ENDP


PP2_RETT	PROC	NEAR
		;
		;NOTHING
		;
		RET

PP2_RETT	ENDP


PP2_ERROR	PROC	NEAR
		;
		;CANNOT HAPPEN
		;
		MOV	AL,CVP_CORRUPT_ERR
		push	EAX
		call	_err_abort

PP2_ERROR	ENDP



PP2_DATA16	PROC	NEAR
		;
		;INSTALL A DATAREF IN STATICSYM
		;
		ASSUME	ESI:PTR cvLData16Struct

		MOV	EDX,DPTR [ESI].Len
		MOV	EAX,DPTR [ESI].Offs

		SHR	EDX,16				;ID
		MOV	ECX,EAX

		PUSH	ESI
		LEA	ESI,[ESI].Nam

		SHR	ECX,16				;Segment
		AND	EAX,0FFFFH			;Offset

		CMP	EDX,I_S_LDATA16
		JZ	L5$

		MOV	DL,I_S_DATAREF
		CALL	INSTALL_GSYM_REF

		POP	ESI

		RET

L5$:
		MOV	EDX,S_DATAREF
		CALL	INSTALL_SSYM

		POP	ESI
		JC	PP2_DELETE

		RET

PP2_DATA16	ENDP


PP2_DATA32	PROC	NEAR
		;
		;INSTALL A DATAREF IN STATICSYM
		;
		ASSUME	ESI:PTR cvLData32Struct

		PUSH	ESI

		MOV	EDX,DPTR [ESI].Len
		MOV	ECX,DPTR [ESI].Segm

		SHR	EDX,16				;ID
		AND	ECX,0FFFFH			;SEGMENT

		MOV	EAX,[ESI].Offs
		LEA	ESI,[ESI].Nam

		CMP	DL,I_S_LDATA32
		JZ	L5$

		MOV	DL,I_S_DATAREF
		CALL	INSTALL_GSYM_REF

		POP	ESI

		RET

L5$:
		MOV	EDX,S_DATAREF
		CALL	INSTALL_SSYM

		POP	ESI
		JC	PP2_DELETE

		RET

PP2_DATA32	ENDP


PP2_PROC16	PROC	NEAR
		;
		;HANDLE NESTING
		;
		ASSUME	ESI:PTR cvLProc16Struct

		MOV	EAX,DPTR [ESI].Segm
		CALL	NEST_PROC

		MOV	EAX,DPTR [ESI].DbgEnd
		MOV	ECX,DPTR [ESI].Segm

		SHR	EAX,16			;Offset
		AND	ECX,0FFFFH		;Segment

		MOV	EDX,DPTR [ESI].Len
		PUSH	ESI

		SHR	EDX,16			;ID
		LEA	ESI,[ESI].Nam

		CMP	DL,I_S_LPROC16
		JZ	L5$

		MOV	DL,I_S_PROCREF
		CALL	INSTALL_GSYM_REF

		POP	ESI

		RET

L5$:
		MOV	EDX,S_PROCREF
		CALL	INSTALL_SSYM

		POP	ESI
		JC	PP2_DELETE

		RET

PP2_PROC16	ENDP


PP2_DELETE	PROC	NEAR
		;
		;I DON'T REMEMBER WHY THIS IS DIFFERENT FROM PP1_DELETE...
		;
		MOV	BPTR [ESI].ID,I_S_DELETE

		RET

PP2_DELETE	ENDP


PP2_PROC32	PROC	NEAR
		;
		;HANDLE NESTING
		;
		ASSUME	ESI:PTR cvLProc32Struct

		PUSH	ESI

		MOV	EAX,DPTR [ESI].Segm
		CALL	NEST_PROC

		MOV	EDX,DPTR [ESI].Len
		MOV	ECX,DPTR [ESI].Segm

		SHR	EDX,16			;ID
		AND	ECX,0FFFFH		;Segment

		MOV	EAX,[ESI].Offs
		LEA	ESI,[ESI].Nam

		CMP	DL,I_S_LPROC32
		JZ	L5$

		MOV	DL,I_S_PROCREF
		CALL	INSTALL_GSYM_REF

		POP	ESI

		RET

L5$:
		MOV	EDX,S_PROCREF
		CALL	INSTALL_SSYM

		POP	ESI
		JC	PP2_DELETE

		RET

PP2_PROC32	ENDP


PP2_THUNK16	PROC	NEAR
		;
		;NEST PROC
		;
		ASSUME	ESI:PTR CV_THUNK16_STRUCT

		MOV	AX,[ESI]._SEGMENT
		JMP	NEST_PROC

PP2_THUNK16	ENDP


PP2_THUNK32	PROC	NEAR
		;
		;NEST PROC
		;
		ASSUME	ESI:PTR CV_THUNK32_STRUCT

		MOV	EAX,DPTR [ESI]._SEGMENT
		JMP	NEST_PROC

PP2_THUNK32	ENDP


PP2_BLOCK16	PROC	NEAR
		;
		;NEST BLOCK
		;
		ASSUME	ESI:PTR CV_BLOCK16_STRUCT

		MOV	EAX,DPTR [ESI]._SEGMENT
		JMP	NEST_BLOCK

PP2_BLOCK16	ENDP


PP2_BLOCK32	PROC	NEAR
		;
		;NEST BLOCK
		;
		ASSUME	ESI:PTR CV_BLOCK32_STRUCT

		MOV	EAX,DPTR [ESI]._SEGMENT
		JMP	NEST_BLOCK

PP2_BLOCK32	ENDP


PP2_S_END	PROC	NEAR
		;
		;CLOSE A SCOPE
		;
		MOV	EDX,CV_PPARENT		;IS THERE A PARENT?
		GET_CV_ASYM_OFFSET		;IN EAX

		TEST	EDX,EDX
		JZ	L99$

		MOV	CV_TEMP_DWORD,EAX
		LEA	EAX,CV_TEMP_DWORD

		LEA	EBX,[EDX+8]
		LEA	EDX,CV_ASYM_STRUCTURE

		MOV	ECX,4
		CALL	STORE_EAXECX_EDXEBX_RANDOM

		MOV	ECX,4
		MOV	EBX,CV_PPARENT

		LEA	EAX,CV_PPARENT
		LEA	EDX,CV_ASYM_STRUCTURE

		ADD	EBX,ECX
		JMP	READ_EAXECX_EDXEBX_RANDOM

L99$:
		MOV	AL,CVP_SCOPE_ERR
		push	EAX
		call	_err_abort

PP2_S_END	ENDP


NEST_PROC	PROC	NEAR
		;
		;AX IS SEGMENT, NEST PLEASE
		;
		MOV	EDX,CV_PPARENT		;IS THERE A PARENT?
		AND	EAX,0FFFFH

		TEST	EDX,EDX
		JNZ	L7$
		;
		;THIS IS ROOT LEVEL, HOOK THIS TO CORRECT SSEARCH CHAIN.
		;
;		PUSH	ESI
		MOV	CV_PPARENT_SEGMENT,EAX

		MOV	ECX,CV_SSEARCH_CNT
		LEA	EDX,CV_SSEARCH_PTRS

		CMP	ECX,8
		JBE	L1$

		MOV	EDX,CV_SSEARCH_PTRS	;SEARCH FOR MATCH OR ZERO
L1$:
		MOV	ECX,[EDX]
		ADD	EDX,8

		CMP	ECX,EAX
		JZ	L14$

		TEST	ECX,ECX
		JNZ	L1$
L12$:
		;
		;CREATE ENTRY
		;
		MOV	[EDX-8],EAX
		GET_CV_ASYM_OFFSET		;IN EAX

		MOV	[EDX-4],EAX
L13$:
		MOV	EBX,CV_NEXT_SSEARCH
		MOV	CV_PPARENT,EAX

		MOV	EAX,EBX
		ADD	EBX,4

		ADD	EAX,SIZE CV_SEARCH_STRUCT
		MOV	ECX,6

		MOV	CV_NEXT_SSEARCH,EAX
		LEA	EDX,CV_ASYM_STRUCTURE

		LEA	EAX,CV_PPARENT
		JMP	STORE_EAXECX_EDXEBX_RANDOM

L14$:
		;
		;FOUND ENTRY
		;
		GET_CV_ASYM_OFFSET		;IN EAX
		MOV	ECX,[EDX-4]

		MOV	CV_PPARENT,EAX
		MOV	[EDX-4],EAX

		LEA	EBX,[ECX+12]		;POINT TO PNEXT
		LEA	EDX,CV_ASYM_STRUCTURE

		LEA	EAX,CV_PPARENT		;UPDATE PREVIOUS TO POINT TO ME
		MOV	ECX,4

		JMP	STORE_EAXECX_EDXEBX_RANDOM

L7$:
NEST_PROC_WITH_PARENT::
		ASSUME	ESI:PTR cvLProc16Struct

		MOV	ECX,CV_PPARENT_SEGMENT
		MOV	[ESI].pParent,EDX

		CMP	ECX,EAX
		JNZ	L99$
L8$:
		GET_CV_ASYM_OFFSET		;IN EAX

		MOV	CV_PPARENT,EAX

		RET

L99$:
		MOV	AL,CVP_NEST_SEG_ERR
		CALL	WARN_RET
		JMP	L8$

		ASSUME	ESI:NOTHING

NEST_PROC	ENDP


NEST_BLOCK	PROC	NEAR
		;
		;AX IS SEGMENT, NEST PLEASE
		;
		MOV	EDX,CV_PPARENT		;IS THERE A PARENT?

		TEST	EDX,EDX
		JNZ	NEST_PROC_WITH_PARENT

		MOV	AL,CVP_BLOCK_WO_PARENT_ERR
		push	EAX
		call	_err_abort

NEST_BLOCK	ENDP


CV_SYMBOL_CLEANUP	PROC	NEAR
		;
		;CLEAN-UP
		;
		;	1.  OUTPUT ALIGNSYM SECTION AND CV_INDEX IF NOT ZERO LENGTH
		;	2.  FIX TYPES ON ANY GLOBALSYM ENTRIES WE MADE
		;
		PUSHM	EDI,ESI,EBX

		CMP	CV_SSEARCH_CNT,8
		JBE	L1$

		MOV	EAX,CV_SSEARCH_PTRS
		CALL	RELEASE_BLOCK
L1$:
		;
		;TRANSFER STUFF FROM CV_ASYM_STRUCTURE TO EXETABLE
		;
		LEA	ESI,CV_ASYM_STRUCTURE._SEQ_TABLE
		MOV	EBX,OFF EXETABLE
L11$:
		MOV	EAX,[ESI]
		ADD	ESI,4

		MOV	[EBX],EAX
		ADD	EBX,4

		TEST	EAX,EAX
		JNZ	L11$
		;
		;NOW FLUSH THAT STUFF TO FINAL
		;
		GET_CV_ASYM_OFFSET	;EAX IS BYTES IN TABLE

		PUSH	EAX
		CALL	FLUSH_EAX_TO_FINAL
		;
		;WRITE CV_INDEX
		;
		POP	ECX
		MOV	EAX,0125H		;SSTALIGNSYM

		PUSH	ECX
		CALL	WRITE_CV_INDEX

		POP	ECX
		MOV	EDX,BYTES_SO_FAR

		ADD	EDX,ECX
		;
		MOV	BYTES_SO_FAR,EDX
		GETT	AL,CV_WARNINGS

		CMP	ECX,64K
		JB	L3$

		TEST	AL,AL
		JZ	L3$

		MOV	AL,CVP_SYMBOLS_64K_ERR
		CALL	WARN_RET
L3$:
		;
		;THAT SHOULD DO IT...
		;
		POPM	EBX,ESI,EDI

		RET

CV_SYMBOL_CLEANUP	ENDP

PUT_CV_SYMBOL2	PROC	NEAR
		;
		;
		;
		ASSUME	ESI:PTR CV_SYMBOL_STRUCT

		MOV	EAX,DPTR [ESI]._LENGTH

		MOV	ECX,EAX

		SHR	EAX,16
		AND	ECX,0FFFFH

		CMP	AL,I_S_DELETE
		JZ	L9$

		MOV	EAX,I2S_TBL[EAX*4]
		ADD	ECX,2

		MOV	[ESI]._ID,AX
		LEA	EDX,CV_ASYM_STRUCTURE

		MOV	EAX,ESI
		JMP	STORE_EAXECX_EDX_SEQ

L9$:
		RET

PUT_CV_SYMBOL2	ENDP


		.DATA

		ALIGN	4

PROCSYM_PASS1	LABEL	DWORD

		DD	PP1_W_DELETE		;TYPE 0 - UNDEFINED, WARN AND DELETE
		DD	PP1_PASS_THRU		;TYPE 1 - S_COMPILE
		DD	PP1_PASS_ND		;TYPE 2 - S_REGISTER, PASS THRU IF NOT DELETING THIS SCOPE
		DD	PP1_CONSTANT		;TYPE 3 - S_CONSTANT, GLOBALIZE IF LEVEL 0
		DD	PP1_UDT			;TYPE 4 - S_UDT
		DD	PP1_W_DELETE		;TYPE 5 - S_SSEARCH, ILLEGAL
		DD	PP1_S_END		;TYPE 6 - UNNEST SCOPES
		DD	PP1_DELETE		;TYPE 7 - S_SKIP, IGNORE
		DD	PP1_W_DELETE		;TYPE 8 - INTERNAL, MEANS DELETE LATER
		DD	PP1_PASS_THRU		;TYPE 9 - S_OBJNAME, KEEP IT
		DD	PP1_PASS_ND		;TYPE A - S_ENDARG
		DD	PP1_PASS_ND		;TYPE B - S_COBOL_UDT
		DD	PP1_PASS_ND		;TYPE C - S_MANYREG
		DD	PP1_PASS_ND		;TYPE D - S_RETURN
		DD	PP1_W_DELETE		;TYPE E - S_ENTRYTHIS
		DD	PP1_PASS_THRU		;TYPE F - S_TDBNAME, KEEP IT
		DD	PP1_PASS_ND		;TYPE 100 - S_BPREL16
		DD	PP1_LDATA16		;TYPE 101 - S_LDATA16
		DD	PP1_S_GDATA16		;TYPE 102
		DD	PP1_W_DELETE		;TYPE 103, LINKER GENERATED ONLY...
		DD	PP1_PROC16		;TYPE 104 - S_LPROC16, ENTER A 16-BIT PROCEDURE SCOPE
		DD	PP1_PROC16		;TYPE 105 - S_GPROC16
		DD	PP1_THUNK16		;TYPE 106 - S_THUNK16
		DD	PP1_BLOCK16		;TYPE 107 - S_BLOCK16
		DD	PP1_BLOCK16		;TYPE 108 - S_WITH16
		DD	PP1_LABEL16		;TYPE 109 - S_LABEL16
		DD	PP1_CEXMODEL16		;TYPE 10A - S_CEXMODEL16
		DD	PP1_VFTPATH16		;TYPE 10B - S_VFTPATH16
		DD	PP1_PASS_ND		;TYPE 10C - S_REGREL16
		DD	PP1_PASS_ND		;TYPE 200 - S_BPREL32
		DD	PP1_LDATA32		;TYPE 201 - S_LDATA32
		DD	PP1_S_GDATA32		;TYPE 202
		DD	PP1_W_DELETE		;TYPE 203, LINKER GENERATED ONLY...
		DD	PP1_PROC32		;TYPE 204 - S_LPROC32, ENTER A 32-BIT PROCEDURE SCOPE
		DD	PP1_PROC32		;TYPE 205 - S_GPROC32
		DD	PP1_THUNK32		;TYPE 206 - S_THUNK32
		DD	PP1_BLOCK32		;TYPE 207 - S_BLOCK32
		DD	PP1_BLOCK32		;TYPE 208 - S_WITH32
		DD	PP1_LABEL32		;TYPE 209 - S_LABEL32
		DD	PP1_CEXMODEL32		;TYPE 20A - S_CEXMODEL32
		DD	PP1_VFTPATH32		;TYPE 20B - S_VFTPATH32
		DD	PP1_PASS_ND		;TYPE 20C - S_REGREL32
		DD	PP1_LDATA32		;TYPE 20D - S_LTHREAD32
		DD	PP1_S_GDATA32		;TYPE 20E - S_GTHREAD32


		ALIGN	4

PROCSYM_PASS2	LABEL	DWORD

		DD	PP2_ERROR		;TYPE 0 - UNDEFINED, CAN'T PASS 2
		DD	PP2_RETT		;TYPE 1 - S_COMPILE
		DD	PP2_RETT		;TYPE 2 - S_REGISTER
		DD	PP2_RETT		;TYPE 3 - S_CONSTANT
		DD	PP2_RETT		;TYPE 4 - S_UDT
		DD	PP2_ERROR		;TYPE 5 - S_SSEARCH, ILLEGAL
		DD	PP2_S_END		;TYPE 6 - UNNEST SCOPES
		DD	PP2_ERROR		;TYPE 7 - S_SKIP, CAN'T PASS 2
		DD	PP2_RETT		;TYPE 8 - INTERNAL, MEANS DELETE LATER
		DD	PP2_RETT		;TYPE 9 - S_OBJNAME, KEEP IT
		DD	PP2_RETT		;TYPE A - S_ENDARG
		DD	PP2_RETT		;TYPE B - S_COBOL_UDT
		DD	PP2_RETT		;TYPE C - S_MANYREG
		DD	PP2_RETT		;TYPE D - S_RETURN
		DD	PP2_ERROR		;TYPE E - S_ENTRYTHIS
		DD	PP2_RETT		;TYPE F - S_TDBNAME, KEEP IT
		DD	PP2_RETT		;TYPE 100 - S_BPREL16
		DD	PP2_DATA16		;TYPE 101 - S_LDATA16
		DD	PP2_DATA16		;TYPE 102 - S_GDATA16
		DD	PP2_ERROR		;TYPE 103, LINKER GENERATED ONLY...
		DD	PP2_PROC16		;TYPE 104 - S_LPROC16, ENTER A 16-BIT PROCEDURE SCOPE
		DD	PP2_PROC16		;TYPE 105 - S_GPROC16
		DD	PP2_THUNK16		;TYPE 106 - S_THUNK16
		DD	PP2_BLOCK16		;TYPE 107 - S_BLOCK16
		DD	PP2_BLOCK16		;TYPE 108 - S_WITH16
		DD	PP2_RETT		;TYPE 109 - S_LABEL16
		DD	PP2_RETT		;TYPE 10A - S_CEXMODEL16
		DD	PP2_RETT		;TYPE 10B - S_VFTPATH16
		DD	PP2_RETT		;TYPE 10C - S_REGREL16
		DD	PP2_RETT		;TYPE 200 - S_BPREL32
		DD	PP2_DATA32		;TYPE 201 - S_LDATA32
		DD	PP2_DATA32		;TYPE 202 - S_GDATA32
		DD	PP2_ERROR		;TYPE 203, LINKER GENERATED ONLY...
		DD	PP2_PROC32		;TYPE 204 - S_LPROC32, ENTER A 32-BIT PROCEDURE SCOPE
		DD	PP2_PROC32		;TYPE 205 - S_GPROC32
		DD	PP2_THUNK32		;TYPE 206 - S_THUNK32
		DD	PP2_BLOCK32		;TYPE 207 - S_BLOCK32
		DD	PP2_BLOCK32		;TYPE 208 - S_WITH32
		DD	PP2_RETT		;TYPE 209 - S_LABEL32
		DD	PP2_RETT		;TYPE 20A - S_CEXMODEL32
		DD	PP2_RETT		;TYPE 20B - S_VFTPATH32
		DD	PP2_RETT		;TYPE 20C - S_REGREL32
		DD	PP2_DATA32		;TYPE 20D - S_LTHREAD32
		DD	PP2_DATA32		;TYPE 20E - S_GTHREAD32

SYM_ONE		DB	'SYM1'

I2S_TBL		DD	0,1,2,3,4,5,6,7,8,9,0AH,0BH,0CH,0DH,0EH,0FH
		DD	100H,101H,102H,103H,104H,105H,106H,107H,108H,109H,10AH,10BH,10CH
		DD	200H,201H,202H,203H,204H,205H,206H,207H,208H,209H,20AH,20BH,20CH,20DH,20EH
		DD	300H,301H
		DD	400H,401H,402H

CV_SSEARCH_TXT	DW	10,S_SSEARCH,0,0,0,0

CV_SSEARCH_TXT_LEN	EQU	$-CV_SSEARCH_TXT

endif

		END

