		TITLE	CVMOD3 - Copyright (c) SLR Systems 1994

		INCLUDE	MACROS
		INCLUDE	MODULES
		INCLUDE	SEGMENTS
		INCLUDE	IO_STRUC

		PUBLIC	CV_MODULE_3


		.DATA

		EXTERNDEF	CV_TEMP_RECORD:BYTE

		EXTERNDEF	CURNMOD_GINDEX:DWORD,BYTES_SO_FAR:DWORD

		EXTERNDEF	MODULE_GARRAY:STD_PTR_S,_FILE_LIST_GARRAY:STD_PTR_S,SEGMOD_GARRAY:STD_PTR_S,SEGMENT_GARRAY:STD_PTR_S
		EXTERNDEF	CSEG_GARRAY:STD_PTR_S,MDB_GARRAY:STD_PTR_S


		.CODE	PASS2_TEXT

		EXTERNDEF	MOVE_TEXT_TO_OMF:PROC,FLUSH_CV_TEMP:PROC,HANDLE_CV_INDEX:PROC


MOD4_VARS	STRUC

LAST_VALID_SEGMOD_BP	DD	?
TEMP_CSEG_COUNT_BP	DD	?
BASE_SM_START_BP	DD	?
NEXT_SEGMOD_BP		DD	?

MOD4_VARS	ENDS


FIX	MACRO	X

X	EQU	([EBP-SIZE MOD4_VARS].(X&_BP))

	ENDM


FIX	LAST_VALID_SEGMOD
FIX	TEMP_CSEG_COUNT
FIX	BASE_SM_START
FIX	NEXT_SEGMOD


NO_CSEG:
		MOV	[EDI],EAX		;CODE SEGMENT FRAME, CODE SEGMENT OFFSET
		MOV	[EDI+4],EAX		;CODE SEGMENT LENGTH

		ADD	EDI,6
		MOV	EDX,EAX

		JMP	NO_CSEG_RET


CV_MODULE_3	PROC
		;
		;OUTPUT OLD MODULE RECORD
		;
		PUSHM	EBP,EDI,ESI,EBX

		MOV	EBP,ESP
		SUB	ESP,SIZE MOD4_VARS
		ASSUME	EBP:PTR MOD4_VARS

		MOV	EAX,BYTES_SO_FAR	;IN CASE THIS DOESN'T FIT IN ONE RECORD
		XOR	ECX,ECX

		MOV	ESI,CURNMOD_GINDEX
		PUSH	EAX

		MOV	TEMP_CSEG_COUNT,ECX
		MOV	EDI,OFF CV_TEMP_RECORD

		CONVERT	ESI,ESI,MODULE_GARRAY
		ASSUME	ESI:PTR MODULE_STRUCT

		MOV	EAX,[ESI]._M_MDB_GINDEX

		TEST	EAX,EAX
		JZ	NO_CSEG

		CONVERT	EAX,EAX,MDB_GARRAY
		ASSUME	EAX:PTR MDB_STRUCT

		MOV	EBX,[EAX]._MD_CSEG_COUNT
		MOV	EAX,[EAX]._MD_FIRST_CSEGMOD_GINDEX

		TEST	EAX,EAX
		JZ	NO_CSEG

		MOV	TEMP_CSEG_COUNT,EBX
if	any_overlays
		BITT	DOING_OVERLAYS
		JZ	N_CSEG
		MOV	CX,AX
		CONVERT_GINDEX_AX_DSSI	SEGMOD_GARRAY
		PUSH	[SI]._SM_SECTION_GINDEX
		MOV	AX,CX
		JMP	N_CSEG_1

N_CSEG:
endif
		PUSH	ECX
N_CSEG_1:
		CALL	STORE_SEGMENT_STUFF	; DX IS NEXT SEGMOD OF MINE

		POP	EAX
		MOV	NEXT_SEGMOD,EDX
NO_CSEG_RET::
		MOV	WPTR [EDI],AX		;OVERLAY #
		MOV	ESI,CURNMOD_GINDEX

		XOR	EAX,EAX
		GETT	CL,NEW_CV_INFO

		OR	CL,CL
		JZ	L1$

		MOV	EAX,TEMP_CSEG_COUNT
L1$:
		ADD	EDI,2
		PUSH	EAX

		CONVERT	ESI,ESI,MODULE_GARRAY
		ASSUME	ESI:PTR MODULE_STRUCT

		SHL	EAX,16				;# OF XTRA SEGS, RESERVED
		MOV	ECX,[ESI]._M_LIBNUM

		OR	EAX,ECX

		MOV	[EDI],EAX
		ADD	EDI,4
		;
		;NOW MOVE MODULE THEADR NAME...
		;
		;
		;LIBRARIES DIFFERENT...
		;
		TEST	ECX,ECX
		JZ	L25$
L22$:
		LEA	ESI,[ESI]._M_TEXT
		CALL	MOVE_TEXT_TO_OMF

		POP	ECX
		JMP	L27$

L25$:
		MOV	EAX,[ESI]._M_FILE_LIST_GINDEX

		TEST	EAX,EAX
		JZ	L22$

		CONVERT	EAX,EAX,_FILE_LIST_GARRAY
		ASSUME	EAX:PTR FILE_LIST_STRUCT

		LEA	ESI,[EAX].FILE_LIST_NFN.NFN_TEXT
		MOV	ECX,[EAX].FILE_LIST_NFN.NFN_TOTAL_LENGTH

		MOV	[EDI],CL
		INC	EDI

		REP	MOVSB

		POP	ECX
L27$:
		CMP	ECX,2
		JB	L5$
		;
		;STORE XTRA CODE SEG SIZES
		;
		MOV	EDX,NEXT_SEGMOD
L3$:
		CMP	EDI,OFF CV_TEMP_RECORD+CV_TEMP_SIZE-6
		JC	L4$

		PUSH	EDX
		CALL	FLUSH_CV_TEMP

		POP	EDX
L4$:
		TEST	EDX,EDX
		JZ	L5$

		MOV	EAX,EDX
		CALL	STORE_SEGMENT_STUFF

		TEST	EDX,EDX
		JNZ	L3$
L5$:
		CALL	FLUSH_CV_TEMP

		POP	EAX			;OLD BYTES_SO_FAR
		MOV	ECX,101H

		CALL	HANDLE_CV_INDEX

		MOV	ESP,EBP

		POPM	EBX,ESI,EDI,EBP

		RET

CV_MODULE_3	ENDP


STORE_SEGMENT_STUFF	PROC	NEAR
		;
		;EAX IS SEGMOD_GINDEX
		;RETURN EDX=NEXT SEGMOD
		;
		PUSHM	ESI,EBX

		MOV	ESI,EAX
		MOV	LAST_VALID_SEGMOD,EAX
		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT
L3$:
		MOV	EAX,[ESI]._SM_START

		MOV	BASE_SM_START,EAX
L31$:
		MOV	EAX,[ESI]._SM_LEN
		MOV	ECX,BASE_SM_START

		SUB	EAX,ECX

		MOV	[EDI+4],AX		;UPDATE LENGTH
		;
		;SEE IF NEXT SEGMOD MATCHES - MUST MATCH SEGMENT AND CSEG-ORDER
		;
		MOV	EBX,[ESI]._SM_MODULE_CSEG_GINDEX
		MOV	EDX,[ESI]._SM_BASE_SEG_GINDEX

		CONVERT	EBX,EBX,CSEG_GARRAY
		ASSUME	EBX:PTR CSEG_STRUCT

		MOV	ECX,[EBX]._CSEG_NEXT_CSEGMOD_GINDEX
		MOV	ESI,[ESI]._SM_NEXT_SEGMOD_GINDEX

		CMP	ECX,ESI
		JNZ	L35$

		TEST	ESI,ESI
		JZ	L35$

		CONVERT	ESI,ESI,SEGMOD_GARRAY
		ASSUME	ESI:PTR SEGMOD_STRUCT

		CMP	[ESI]._SM_BASE_SEG_GINDEX,EDX
		JNZ	L34$

		MOV	LAST_VALID_SEGMOD,ECX
		JMP	L31$

L34$:
L35$:
		;
		;NOW, SUBTRACT FRAME IF REAL MODE, ELSE JUST GET OS2_NUMBER
		;
		CONVERT	EDX,EDX,SEGMENT_GARRAY			;THAT IS BASE SEGMENT
		ASSUME	EDX:PTR SEGMENT_STRUCT

		PUSH	ECX			;SAVE NEXT SEGMOD
		MOV	ECX,BASE_SM_START

		MOV	ESI,[EDX]._SEG_OS2_NUMBER
		GETT	AL,OUTPUT_SEGMENTED

		OR	AL,AL
		JNZ	L2$

		MOV	ESI,[EDX]._SEG_FRAME

		SUB	ECX,ESI

		SHR	ESI,4
L2$:
		MOV	[EDI],SI		;SEGMENT
		XOR	EAX,EAX			;OVERLAY # FOR NOW...

		MOV	[EDI+2],CX		;OFFSET
		ADD	EDI,6

		POP	EDX			;NEXT SEGMOD

		POPM	EBX,ESI

		RET

STORE_SEGMENT_STUFF	ENDP


		END

