		TITLE	FAKELEDA - Copyright (c) SLR Systems 1994

		INCLUDE MACROS
		INCLUDE	SEGMENTS

		PUBLIC	FAKE_LEDATA,LEDATA_CONT,FAKE_LEDATA_COMDAT


		.DATA

		EXTERNDEF	LDATA_TYPE:BYTE

		EXTERNDEF	END_OF_RECORD:DWORD,LDATA_LENGTH:DWORD,LDATA_SEGMOD_GINDEX:DWORD,DEFAULT_SIZE:DWORD
		EXTERNDEF	LAST_DATA_PTR:DWORD,LDATA_LOC:DWORD

		EXTERNDEF	SEGMOD_GARRAY:STD_PTR_S


		.CODE	ROOT_TEXT

		externdef	_ldata_alloc:proc
		EXTERNDEF	LDATA_ALLOC:PROC,OBJ_E:PROC


OBJ_E1:
		JMP	OBJ_E


FAKE_LEDATA	PROC
		;
		;EAX IS LEDATA RECORD TO STORE
		;
		;DESTROYS REGISTERS...
		;
		MOV	DL,-1
		MOV	CL,LDATA_TYPE
		SETT	LAST_DATA_KEEP,DL
		MOV	EDX,[EAX]
		AND	CL,MASK BIT_32
		JNZ	L1$
		AND	EDX,0FFFFH
		SUB	EAX,2
L1$:
		MOV	LDATA_LOC,EDX
		ADD	EAX,4

FAKE_LEDATA_COMDAT	LABEL	PROC
		;
		;EAX IS LEDATA RECORD AFTER OFFSET
		;
		MOV	ECX,END_OF_RECORD	;CURSEG AVAILABLE...
		MOV	ESI,EAX
		SUB	ECX,EAX			;# OF BYTES IN RECORD
		JBE	OBJ_E1			;PHASE
		MOV	EDI,ECX
		MOV	LDATA_LENGTH,ECX 	;STORE RECORD LENGTH
		LEA	EAX,[ECX + SIZE LDATA_HEADER_TYPE]
SPEC_RET:
		sub	ESP,12
		mov	EDX,ESP
		push	EDX		; &EAX
		add	EDX,4
		push	EDX		; &ECX
		add	EDX,4
		push	EDX		; &EDX
		push	EAX
		call	_ldata_alloc
		add	ESP,16
		test	EAX,EAX
		pop	EAX
		pop	ECX
		pop	EDX
		jnz	SPECIAL

;		CALL	LDATA_ALLOC	;EAX=BLOCK_BASE, ECX=PHYS
;		JC	SPECIAL

		MOV	EDX,EDI
SPEC_2:
		ASSUME	ECX:PTR LDATA_HEADER_TYPE
		MOV	[ECX]._LD_BLOCK_BASE,EAX

		XOR	EAX,EAX
		MOV	LAST_DATA_PTR,ECX
		;
		;NEXT_LDATA
		;TYPE
		;SECOND_BLK
		;LENGTH
		;OFFSET
		;
		MOV	[ECX]._LD_NEXT_LDATA,EAX
		MOV	AL,LDATA_TYPE	;LEDATA,LIDATA OR FORREF, 16 OR 32 BIT
if	fg_phar
		TEST	AL,MASK BIT_32 + MASK BIT_LI
		JZ	L5$
		CMP	DEFAULT_SIZE,0
		JZ	L5$
		AND	AL,NOT MASK BIT_32	;PHARLAP ITERATED DATA NOT REALLY LIKE NORMAL 32_BIT
		MOV	LDATA_TYPE,AL
L5$:
endif
		SHL	EAX,16

		OR	EAX,EDI

		MOV	DPTR [ECX]._LD_LENGTH,EAX
		MOV	EAX,LDATA_LOC

		MOV	[ECX]._LD_OFFSET,EAX
		MOV	EAX,EBX			;SECOND BLOCK

		MOV	EBX,EDI			;# OF BYTES
		LEA	EDI,[ECX+ SIZEOF LDATA_HEADER_TYPE]	;DESTINATION

		MOV	ECX,EDX			;# IN FIRST BLOCK
		MOV	EDX,EAX			;SECOND BLOCK


LEDATA_CONT	LABEL	PROC
		;
		;EBX IS # OF BYTES
		;ECX IS # IN FIRST BLOCK
		;EDX IS SECOND BLOCK
		;ESI IS SOURCE DATA
		;EDI IS DESTINATION
		;
		SUB	EBX,ECX		;EBX IS # IN SECOND BLOCK
		;
		;NOW MOVE REST OF FIRST BLOCK
		;
		OPTI_MOVSB
		;
		MOV	ECX,EBX
		TEST	EBX,EBX
		MOV	EDI,EDX
		JZ	LE_DONE
		;
		;
		;NOW MOVE REST OF RECORD
		;
		OPTI_MOVSB
LE_DONE:
		;
		;NOW, LINK THIS TO SEGMOD
		;
		MOV	EBX,LDATA_SEGMOD_GINDEX
		MOV	ECX,LAST_DATA_PTR
		ASSUME	ECX:PTR LDATA_HEADER_TYPE

		CONVERT	EBX,EBX,SEGMOD_GARRAY
		ASSUME	EBX:PTR SEGMOD_STRUCT

		MOV	EAX,[EBX]._SM_FIRST_DAT
		MOV	[EBX]._SM_FIRST_DAT,ECX
		MOV	[ECX]._LD_NEXT_LDATA,EAX
		RET

SPECIAL::
		SUB	EDX,SIZE LDATA_HEADER_TYPE	;I WANT HEADER MINIMUM
		JC	SPEC1
		;
		;HARD ONE, SET UP STUFF FOR DOING IT CORRECTLY...
		;
		PUSHM	EAX,ECX,EDX
		OR	LDATA_TYPE,MASK BIT_CONT

		MOV	EAX,EDI
		MOV	LAST_DATA_PTR,ECX
		SUB	EAX,EDX		;NEED THIS MANY MORE

		sub	ESP,12
		mov	EDX,ESP
		push	EDX		; &EAX
		add	EDX,4
		push	EDX		; &ECX
		add	EDX,4
		push	EDX		; &EDX
		push	EAX
		call	_ldata_alloc
		add	ESP,16
		pop	EAX
		pop	ECX
		pop	EDX
;		CALL	LDATA_ALLOC	;GET MORE...

		POP	EDX
		MOV	EBX,ECX
		POPM	ECX,EAX
		JMP	SPEC_2

SPEC1:
		;
		;CANT EVEN FIT HEADER, RELEASE THIS
		;
		DEC	DPTR [EAX]	;DON'T COUNT THAT GUY
		LEA	EAX,[EDI+SIZE LDATA_HEADER_TYPE]
		JMP	SPEC_RET

FAKE_LEDATA	ENDP


		END

