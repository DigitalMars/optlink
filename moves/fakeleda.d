// FAKELEDA - Copyright (c) SLR Systems 1994

FAKE_LEDATA(EAX)
{
	// EAX IS LEDATA RECORD TO STORE

	// DESTROYS REGISTERS...
	DL = -1;
	CL = LDATA_TYPE;
	LAST_DATA_KEEP,DL = -1;
	EDX = [EAX];
	CL &= MASK BIT_32;
	if (!CL)
	{
	    EDX &= 0FFFFH;
	    EAX -= 2;
	}
	LDATA_LOC = EDX;
	EAX += 4;
	FAKE_LEDATA_COMDAT(EAX);
}

FAKE_LEDATA_COMDAT(EAX)
{
	// EAX IS LEDATA RECORD AFTER OFFSET

	// CURSEG AVAILABLE...
	ECX = END_OF_RECORD;
	ESI = EAX;	// # OF BYTES IN RECORD
	if (ECX < EAX)
	{
		ECX -= EAX;	// PHASE
		OBJ_E();
		return;
	}
	ECX -= EAX;		// PHASE
	EDI = ECX;
	LDATA_LENGTH = ECX;	// STORE RECORD LENGTH
	EAX = ECX + LDATA_HEADER_TYPE.sizeof;

	// EAX=BLOCK_BASE, ECX=PHYS
	LDATA_ALLOC();
	if (CarryFlag)
	{
	    // I WANT HEADER MINIMUM
	    if (EDX < LDATA_HEADER_TYPE.sizeof)
	    {
		// CANT EVEN FIT HEADER, RELEASE THIS
		--*cast(int*)EAX;	// don't count that guy
		EAX = EDI + LDATA_HEADER_TYPE.sizeof;
		goto SPEC_RET;
	    }
	    EDX -= LDATA_HEADER_TYPE.sizeof;
	    // HARD ONE, SET UP STUFF FOR DOING IT CORRECTLY...

	    PUSHM	EAX,ECX,EDX
	    LDATA_TYPE |= MASK BIT_CONT;
	    EAX = EDI;
	    LAST_DATA_PTR = ECX;
	    EAX -= EDX;	// NEED THIS MANY MORE
	    LDATA_ALLOC();	// GET MORE...
	    EBX = ECX;
	    POPM	EDX,ECX,EAX
	}
	else
	    EDX = EDI;

		ASSUME	ECX:PTR LDATA_HEADER_TYPE
	[ECX]._LD_BLOCK_BASE = EAX;

	EAX = 0;
	LAST_DATA_PTR = ECX;

	// NEXT_LDATA
	// TYPE
	// SECOND_BLK
	// LENGTH
	// OFFSET

	[ECX]._LD_NEXT_LDATA = 0;
	AL = LDATA_TYPE;	// LEDATA,LIDATA OR FORREF, 16 OR 32 BIT
    version(fg_phar)
    {
	if (AL & (MASK BIT_32 | MASK BIT_LI) && DEFAULT_SIZE)
	{
	    // PHARLAP ITERATED DATA NOT REALLY LIKE NORMAL 32_BIT
	    AL &= ~ MASK BIT_32;
	    LDATA_TYPE = AL;
	}
    }
	EAX <<= 16;
	EAX |= EDI;

	DPTR [ECX]._LD_LENGTH = EAX;
	EAX = LDATA_LOC;

	[ECX]._LD_OFFSET = EAX;
	EAX = EBX;	// SECOND BLOCK

	EBX = EDI;	// # OF BYTES
	EDI = &[ECX+ SIZEOF LDATA_HEADER_TYPE];	// DESTINATION

	// # IN FIRST BLOCK
	ECX = EDX;
	// SECOND BLOCK
	EDX = EAX;
	LEDATA_CONT(EBX, ECX, EDX, ESI, EDI);
}

LEDATA_CONT(EBX, ECX, EDX, ESI, EDI)
{
	// EBX IS # OF BYTES
	// ECX IS # IN FIRST BLOCK
	// EDX IS SECOND BLOCK
	// ESI IS SOURCE DATA
	// EDI IS DESTINATION


	// EBX IS # IN SECOND BLOCK
	EBX -= ECX;

	// NOW MOVE REST OF FIRST BLOCK
	memcpy(EDI, ESI, ECX);
	ESI += ECX;

	if (EBX)
	{
	    memcpy(EDX, ESI, EBX);	    // NOW MOVE REST OF RECORD
	}

	// NOW, LINK THIS TO SEGMOD

	EBX = LDATA_SEGMOD_GINDEX;
	LDATA_HEADER_TYPE* ECX = LAST_DATA_PTR;

	CONVERT	EBX,EBX,SEGMOD_GARRAY
	ASSUME	EBX:PTR SEGMOD_STRUCT

	EAX = [EBX]._SM_FIRST_DAT;
	[EBX]._SM_FIRST_DAT = ECX;
	[ECX]._LD_NEXT_LDATA = EAX;
}

