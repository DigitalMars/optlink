		TITLE	PEEXPORT - Copyright (c) SLR Systems 1994

		INCLUDE MACROS

if	fg_pe
		INCLUDE	SYMBOLS
		INCLUDE	SEGMSYMS
		INCLUDE	PE_STRUC

		PUBLIC	PE_OUTPUT_EXPORTS


		.DATA

		EXTERNDEF	SYMBOL_TEXT:BYTE,TEMP_RECORD:BYTE,EXPORT_TABLE_USE:BYTE

		EXTERNDEF	EXP_BUFFER:DWORD,EXPORT_ORDINAL_BASE:DWORD,N_EXPORT_RVAS:DWORD
		EXTERNDEF	MODULE_NAME:DWORD,N_EXPORTS_BYNAME:DWORD,SYMBOL_LENGTH:DWORD,N_EXPORTS:DWORD
		EXTERNDEF	OPTI_STOSD_SIZE:DWORD,PE_BASE:DWORD,ENTRYNAME_BITS:DWORD,FINAL_HIGH_WATER:DWORD

		EXTERNDEF	ENTRYNAME_GARRAY:STD_PTR_S,SYMBOL_GARRAY:STD_PTR_S,ENTRYNAME_STUFF:ALLOCS_STRUCT


		.CODE	PASS2_TEXT

		EXTERNDEF	RELEASE_BLOCK:PROC,OUTPUT_LIB:PROC,UNUSE_ENTRYNAMES:PROC,UNUSE_SORTED_EXPORTS:PROC
		EXTERNDEF	CHANGE_PE_OBJECT:PROC,ERR_ASCIZ_RET:PROC,OUTPUT_DIN:PROC,STORE_EAXECX_EDXEBX_RANDOM:PROC
		EXTERNDEF	MOVE_EAX_TO_FINAL_HIGH_WATER:PROC,MOVE_EAX_TO_EDX_FINAL:PROC,MOVE_ASCIZ_ESI_EDI:PROC
		EXTERNDEF	_release_minidata:proc,RELEASE_GARRAY:PROC,CONVERT_SUBBX_TO_EAX:PROC

		EXTERNDEF	EXP_CONST_ERR:ABS


N_PTRS_ALLOWED	EQU	32
N_ORDS_ALLOWED	EQU	32


PE_EXP_VARS	STRUC

PEEXP_DIR_BP		PE_EXPORT_DIR_STRUCT <>
ENT_STUFF_BP		ENT_STRUCT<>
PE_EXPORTS_STRUCTURE_BP	SEQ_STRUCT <>			;64K		;**
			DD	3 * (32K/PAGE_SIZE) * 2 DUP(?)		;** TOTAL 256K FOR STORING ADDRESSES
									;**
PTRS_BUFFER_BP		DD	N_PTRS_ALLOWED DUP(?)			;**
ORDS_BUFFER_BP		DW	N_ORDS_ALLOWED DUP(?)

PEEXP_ADDRESSES_FA_BP	DD	?
PEEXP_NAME_PTRS_FA_BP	DD	?
PEEXP_ORDINALS_FA_BP	DD	?
PEEXP_STRINGS_FA_BP	DD	?

NAME_PTRS_PTR_BP	DD	?
ORDINALS_PTR_BP		DD	?
STRINGS_PTR_BP		DD	?

NAME_PTRS_LEFT_BP	DD	?
ORDINALS_LEFT_BP	DD	?
STRING_BYTES_LEFT_BP	DD	?

MY_RVA_BP		DD	?
NEXT_STRING_RVA_BP	DD	?
EXP_TEMP_BP		DD	?

WM_PTR_BP		DD	?
WM_PTR_LIMIT_BP		DD	?
WM_BLK_PTR_BP		DD	?
ORDBITS_PTR_BP		DD	?
ORDBITS_NUMBER_BP	DD	?
CURN_ORDNUM_DWORD_BP	DD	?
CURN_ORDNUM_BP		DD	?

PE_EXP_VARS	ENDS


FIX	MACRO	X

X	EQU	([EBP-SIZE PE_EXP_VARS].(X&_BP))

	ENDM


FIX	PEEXP_DIR
FIX	ENT_STUFF
FIX	PE_EXPORTS_STRUCTURE
FIX	PTRS_BUFFER
FIX	ORDS_BUFFER
FIX	PEEXP_ADDRESSES_FA
FIX	PEEXP_NAME_PTRS_FA
FIX	PEEXP_ORDINALS_FA
FIX	PEEXP_STRINGS_FA

FIX	NAME_PTRS_PTR
FIX	ORDINALS_PTR
FIX	STRINGS_PTR

FIX	NAME_PTRS_LEFT
FIX	ORDINALS_LEFT
FIX	STRING_BYTES_LEFT

FIX	MY_RVA
FIX	NEXT_STRING_RVA
FIX	EXP_TEMP

FIX	WM_PTR_LIMIT
FIX	WM_PTR
FIX	WM_BLK_PTR
FIX	ORDBITS_PTR
FIX	ORDBITS_NUMBER
FIX	CURN_ORDNUM_DWORD
FIX	CURN_ORDNUM


PE_OUTPUT_EXPORTS	PROC
		;
		;THIS BUILDS AND OUTPUTS THE EXPORTS SECTION...
		;
		CMP	ENTRYNAME_BITS,0
		JNZ	L0$

		CALL	OUTPUT_DIN		;IF REQUESTED
		CALL	OUTPUT_LIB		;IF REQUESTED

L09$:
		RET				;NO EXPORTS, DONE!

L0$:
		BITT	OUTPUT_PE
		JZ	L09$

		PUSH	EBP
		MOV	EBP,ESP

		SUB	ESP,SIZE PE_EXP_VARS
		ASSUME	EBP:PTR PE_EXP_VARS
		;
		;CALCULATE ADDRESSES TO STORE STUFF AT...
		;
		CALL	CHANGE_PE_OBJECT	;FLUSH PREVIOUS OBJECT, SETUP FOR NEW, DS:SI POINTS TO OBJECT
		ASSUME	EAX:PTR PE_OBJECT_STRUCT

		MOV	[EAX]._PEOBJECT_FLAGS,MASK PEL_INIT_DATA_OBJECT + MASK PEH_READABLE
		;
		;DEFINE EXPORT DIRECTORY
		;
		MOV	ESI,EAX
		LEA	EDI,PEEXP_DIR
		ASSUME	ESI:PTR PE_OBJECT_STRUCT

		MOV	ECX,SIZE PE_EXPORT_DIR_STRUCT/4
		XOR	EAX,EAX

		REP	STOSD

		LEA	EDI,PE_EXPORTS_STRUCTURE	;FOR RANDOM ACCESSING ORDINALS
		MOV	ECX,(PE_EXP_VARS.PTRS_BUFFER_BP-PE_EXP_VARS.PE_EXPORTS_STRUCTURE_BP)/4

		REP	STOSD

		MOV	EAX,EXPORT_ORDINAL_BASE
		MOV	EBX,N_EXPORT_RVAS

		MOV	PEEXP_DIR._PEEXP_ORDINAL_BASE,EAX
		MOV	PEEXP_DIR._PEEXP_N_EXPORTS,EBX

		CMP	N_EXPORTS,EBX
		JAE	L05$

		SETT	STORE_DSSICX_USE_ZERO
		MOV	OPTI_STOSD_SIZE,PAGE_SIZE/4
L05$:
		MOV	EDX,N_EXPORTS_BYNAME
		MOV	EAX,[ESI]._PEOBJECT_RVA

		MOV	PEEXP_DIR._PEEXP_N_POINTERS,EDX
		MOV	EDI,FINAL_HIGH_WATER

		MOV	MY_RVA,EAX
		SUB	EDI,EAX

		ADD	EAX,SIZE PE_EXPORT_DIR_STRUCT
		MOV	ECX,FINAL_HIGH_WATER

		MOV	PEEXP_DIR._PEEXP_ADDRESSES_RVA,EAX
		ADD	ECX,SIZE PE_EXPORT_DIR_STRUCT

		SHL	EBX,2				;N_EXPORT_RVAS
		MOV	PEEXP_ADDRESSES_FA,ECX

		ADD	EAX,EBX
		MOV	ECX,EDI

		MOV	EBX,N_EXPORTS_BYNAME
		MOV	PEEXP_DIR._PEEXP_NAMES_RVA,EAX


		SHL	EBX,2
		ADD	ECX,EAX

		MOV	PEEXP_NAME_PTRS_FA,ECX
		ADD	EAX,EBX

		MOV	ECX,EDI
		MOV	EBX,N_EXPORTS_BYNAME

		MOV	PEEXP_DIR._PEEXP_ORDINALS_RVA,EAX
		ADD	EBX,EBX

		ADD	ECX,EAX
		ADD	EAX,EBX

		MOV	PEEXP_ORDINALS_FA,ECX
		ADD	EDI,EAX

		MOV	NEXT_STRING_RVA,EAX
		LEA	EAX,PTRS_BUFFER

		MOV	PEEXP_STRINGS_FA,EDI
		MOV	NAME_PTRS_PTR,EAX

		MOV	NAME_PTRS_LEFT,N_PTRS_ALLOWED

		LEA	EAX,ORDS_BUFFER
		MOV	ECX,OFF TEMP_RECORD

		MOV	ORDINALS_LEFT,N_ORDS_ALLOWED

		MOV	ORDINALS_PTR,EAX
		MOV	STRINGS_PTR,ECX

		MOV	STRING_BYTES_LEFT,MAX_RECORD_LEN
		;
		;MOVE .DLL NAME
		;
		MOV	ECX,DPTR MODULE_NAME
		MOV	EAX,OFF MODULE_NAME+4

		INC	ECX
		CALL	MOVE_STRING			;RETURNS DX:AX AS RVA

		MOV	PEEXP_DIR._PEEXP_NAME_RVA,EAX
		;
		;STORE DIR
		;
		LEA	EAX,PEEXP_DIR

		MOV	ECX,SIZE PE_EXPORT_DIR_STRUCT
		CALL	MOVE_EAX_TO_FINAL_HIGH_WATER
		;
		;SET UP CURN_ORDNUM STUFF
		;
		CALL	NEXT_ORDNUM_INIT
		;
		;NOW SCAN FOR DECLARED ENTRY POINTS...
		;
		CALL	TBLINIT

		JMP	L3$

L1$:
		CALL	HANDLE_ENTRY
L3$:
		CALL	TBLNEXT
		JNZ	L1$

		XOR	EAX,EAX

		XCHG	EAX,ENTRYNAME_BITS

		TEST	EAX,EAX
		JZ	L5$
		CALL	RELEASE_BLOCK
L5$:
		RESS	STORE_DSSICX_USE_ZERO
		;
		;FLUSH EXPORT DATA TO OUTPUT FILE
		;
		CALL	FLUSH_EXPORTS_STRUCTURE

		CALL	FLUSH_NAME_PTRS
		CALL	FLUSH_ORDINALS
		CALL	FLUSH_STRING_BUFFER

if	V5
		CALL	OUTPUT_DIN		;IF REQUESTED
		CALL	OUTPUT_LIB		;IF REQUESTED
endif

		CALL	UNUSE_ENTRYNAMES	;FREE UP THAT STORAGE IF .MAP DOESN'T NEED IT...
		CALL	UNUSE_SORTED_EXPORTS

L8$:

		MOV	ESP,EBP

		POP	EBP

		RET

PE_OUTPUT_EXPORTS	ENDP


HANDLE_ENTRY	PROC	NEAR	PRIVATE
		;
		;EAX IS ENTRYNAME_GINDEX
		;
		CONVERT	EAX,EAX,ENTRYNAME_GARRAY
		ASSUME	EAX:PTR ENT_STRUCT

		MOV	ESI,EAX
		ASSUME	ESI:PTR ENT_STRUCT
		MOV	EAX,[EAX]._ENT_ORD

		TEST	EAX,EAX			;WAS ORDINAL # SPECIFIED?
		JNZ	L1$

		CALL	GET_NEXT_ORDNUM

		MOV	[ESI]._ENT_ORD,EAX
L1$:
		LEA	EDI,ENT_STUFF
		MOV	ECX,ENT_STRUCT._ENT_TEXT/4

		REP	MOVSD

		MOV	EDI,OFF SYMBOL_TEXT
		CALL	MOVE_ASCIZ_ESI_EDI

		SUB	EDI,OFF SYMBOL_TEXT
		MOV	AL,ENT_STUFF._ENT_FLAGS

		MOV	SYMBOL_LENGTH,EDI
		GETT	AH,ALL_EXPORTS_BY_ORDINAL
		;
		;DO WE OUTPUT THIS GUY'S NAME?
		;
		TEST	AL,MASK ENT_BYNAME		;IF EXPORTING THIS BY NAME, ADD IN THIS NAME SIZE
		JNZ	L33$

		TEST	AL,MASK ENT_NONAME
		JNZ	L49$

		OR	AH,AH
		JNZ	L32$

		TEST	AL,MASK ENT_ORD_SPECIFIED
		JZ	L33$
L32$:
		GETT	AL,KILL_NONRESIDENT_NAMES

		OR	AL,AL
		JNZ	L49$
L33$:
		MOV	ECX,SYMBOL_LENGTH
		MOV	EAX,OFF SYMBOL_TEXT

		INC	ECX
		CALL	MOVE_STRING

		CALL	STORE_NAME_PTR			;ITS RVA IS IN EAX

		MOV	EAX,ENT_STUFF._ENT_ORD
		CALL	STORE_ORDINAL			;
L49$:
		;
		;ORDINAL IS SPECIFIED, STORE IN EXPORT_ADDRESS TABLE
		;
		MOV	ESI,ENT_STUFF._ENT_INTERNAL_NAME_GINDEX

		CONVERT	ESI,ESI,SYMBOL_GARRAY
		ASSUME	ESI:PTR SYMBOL_STRUCT

		MOV	AL,[ESI]._S_NSYM_TYPE

		CMP	AL,NSYM_RELOC
		JNZ	L51$
L52$:
		MOV	EAX,[ESI]._S_OFFSET
		MOV	EDX,PE_BASE

		SUB	EAX,EDX
		JMP	STORE_EXPORT_ADDRESS

L51$:
		CMP	AL,NSYM_CONST
		JZ	L52$

		CMP	AL,NSYM_ASEG
		JZ	L52$

		MOV	AL,EXP_CONST_ERR
		LEA	ECX,[ESI]._S_NAME_TEXT

		CALL	ERR_ASCIZ_RET

		JMP	L52$

		ASSUME	ESI:NOTHING

HANDLE_ENTRY	ENDP


STORE_EXPORT_ADDRESS	PROC	NEAR
		;
		;EAX IS ADDRESS TO STORE FOR ORDINAL
		;
		PUSH	EBX
		MOV	EXP_TEMP,EAX

		MOV	EBX,ENT_STUFF._ENT_ORD
		MOV	ECX,EXPORT_ORDINAL_BASE

		SUB	EBX,ECX
		MOV	ECX,4

		SHL	EBX,2
		LEA	EDX,PE_EXPORTS_STRUCTURE

		LEA	EAX,EXP_TEMP
		CALL	STORE_EAXECX_EDXEBX_RANDOM

		POP	EBX

		RET

STORE_EXPORT_ADDRESS	ENDP


STORE_ORDINAL	PROC	NEAR
		;
		;AX IS ORDINAL TO STORE
		;
		MOV	EDX,ORDINALS_PTR
		MOV	ECX,EXPORT_ORDINAL_BASE

		SUB	EAX,ECX
		MOV	ECX,ORDINALS_LEFT

		MOV	WPTR [EDX],AX
		ADD	EDX,2

		DEC	ECX
		MOV	ORDINALS_PTR,EDX

		MOV	ORDINALS_LEFT,ECX
		JZ	FLUSH_ORDINALS

		RET

STORE_ORDINAL	ENDP


FLUSH_ORDINALS	PROC	NEAR
		;
		;
		;
		LEA	EAX,ORDS_BUFFER
		MOV	ECX,ORDINALS_PTR

		MOV	ORDINALS_LEFT,N_ORDS_ALLOWED

		SUB	ECX,EAX
		JZ	L9$

		MOV	EDX,PEEXP_ORDINALS_FA
		MOV	ORDINALS_PTR,EAX

		ADD	PEEXP_ORDINALS_FA,ECX
		JMP	MOVE_EAX_TO_EDX_FINAL

L9$:
		RET

FLUSH_ORDINALS	ENDP


STORE_NAME_PTR	PROC	NEAR
		;
		;DX:AX IS ADDRESS TO STORE
		;
		MOV	EDX,NAME_PTRS_PTR
		MOV	ECX,NAME_PTRS_LEFT

		MOV	[EDX],EAX
		ADD	EDX,4

		DEC	ECX
		MOV	NAME_PTRS_PTR,EDX

		MOV	NAME_PTRS_LEFT,ECX
		JZ	FLUSH_NAME_PTRS

		RET

STORE_NAME_PTR	ENDP


FLUSH_NAME_PTRS	PROC	NEAR
		;
		;
		;
		LEA	EAX,PTRS_BUFFER
		MOV	ECX,NAME_PTRS_PTR

		MOV	NAME_PTRS_LEFT,N_PTRS_ALLOWED

		SUB	ECX,EAX
		JZ	L9$

		MOV	EDX,PEEXP_NAME_PTRS_FA
		MOV	NAME_PTRS_PTR,EAX

		ADD	PEEXP_NAME_PTRS_FA,ECX
		JMP	MOVE_EAX_TO_EDX_FINAL

L9$:
		RET

FLUSH_NAME_PTRS	ENDP


MOVE_STRING	PROC	NEAR
		;
		;EAX IS STRING TO MOVE
		;ECX IS LENGTH
		;
		;RETURNS RVA IN EAX
		;
		PUSH	ESI
		MOV	ESI,EAX

		MOV	EDX,STRING_BYTES_LEFT
		PUSH	EDI

		SUB	EDX,ECX
		JC	L5$
L0$:
		MOV	STRING_BYTES_LEFT,EDX
		MOV	EDI,STRINGS_PTR

		MOV	EAX,NEXT_STRING_RVA
		MOV	EDX,ECX

		OPTI_MOVSB

		ADD	EDX,EAX
		MOV	STRINGS_PTR,EDI

		MOV	NEXT_STRING_RVA,EDX
		POP	EDI

		POP	ESI

		RET

L5$:
		PUSH	ECX
		CALL	FLUSH_STRING_BUFFER

		POP	ECX
		MOV	EDX,STRING_BYTES_LEFT

		SUB	EDX,ECX
		JMP	L0$

MOVE_STRING	ENDP


FLUSH_STRING_BUFFER	PROC	NEAR
		;
		;
		;
		MOV	ECX,MAX_RECORD_LEN
		MOV	EAX,STRING_BYTES_LEFT

		MOV	STRING_BYTES_LEFT,ECX
		SUB	ECX,EAX

		MOV	EDX,PEEXP_STRINGS_FA
		JZ	L9$

		LEA	EAX,[ECX+EDX]

		MOV	PEEXP_STRINGS_FA,EAX
		MOV	EAX,OFF TEMP_RECORD

		MOV	STRINGS_PTR,EAX
		JMP	MOVE_EAX_TO_EDX_FINAL

L9$:
		RET

FLUSH_STRING_BUFFER	ENDP


TBLINIT 	PROC	PRIVATE
		;
		;
		;
		MOV	ESI,OFF EXP_BUFFER+4	;TABLE OF BLOCKS OF INDEXES

		LODSD				;FIRST BLOCK

		MOV	WM_BLK_PTR,ESI		;POINTER TO NEXT BLOCK

		TEST	EAX,EAX
		JZ	L9$
		;
		MOV	WM_PTR,EAX		;PHYSICAL POINTER TO NEXT INDEX TO PICK
		ADD	EAX,PAGE_SIZE

		MOV	WM_PTR_LIMIT,EAX
L9$:
		RET

TBLINIT 	ENDP


TBLNEXT 	PROC	PRIVATE
		;
		;GET NEXT SYMBOL INDEX IN AX, DS:SI POINTS
		;
		MOV	ECX,WM_PTR
		MOV	EDX,WM_PTR_LIMIT

		CMP	ECX,EDX
		JZ	L5$

		MOV	EAX,[ECX]		;NEXT INDEX
		ADD	ECX,4

		TEST	EAX,EAX
		MOV	WM_PTR,ECX		;UPDATE POINTER

		RET

L5$:
		;
		;NEXT BLOCK
		;
		MOV	ECX,WM_BLK_PTR

		MOV	EAX,[ECX]
		ADD	ECX,4

		MOV	WM_PTR,EAX
		ADD	EAX,PAGE_SIZE

		MOV	WM_BLK_PTR,ECX
		MOV	WM_PTR_LIMIT,EAX

		JMP	TBLNEXT

TBLNEXT 	ENDP


GET_NEXT_ORDNUM	PROC	NEAR
		;
		;SCAN FOR NEXT AVAILABLE ORDINAL #... THEN MARK IT USED
		;
		MOV	ECX,CURN_ORDNUM_DWORD
		MOV	EAX,CURN_ORDNUM

		TEST	ECX,ECX
		JZ	L5$
L1$:
		SHR	ECX,1
		INC	EAX

		JNC	L1$

		MOV	CURN_ORDNUM_DWORD,ECX
		MOV	CURN_ORDNUM,EAX

		DEC	EAX

		RET

L5$:
		MOV	EDX,ORDBITS_PTR
		MOV	EAX,ORDBITS_NUMBER
L6$:
		MOV	ECX,[EDX]
		ADD	EDX,4

		ADD	EAX,32
		INC	ECX

		JZ	L6$

		DEC	ECX
		MOV	ORDBITS_NUMBER,EAX

		XOR	ECX,-1
		MOV	ORDBITS_PTR,EDX

		JMP	L1$

GET_NEXT_ORDNUM	ENDP


NEXT_ORDNUM_INIT	PROC	NEAR
		;
		;
		;
		PUSH	ESI
		MOV	ESI,ENTRYNAME_BITS	;TABLE OF BITS SET FOR EACH ORDINAL IN USE

		XOR	EDX,EDX
		MOV	EAX,EXPORT_ORDINAL_BASE	;DELTA ON ORDINALS

		CMP	EAX,32
		JB	L5$

		MOV	ECX,EAX

		AND	ECX,NOT 1FH		;SAVE BITS MORE SIGNIFICANT THAN 31

		MOV	EDX,ECX

		SHR	ECX,3			;8 BITS PER BYTE

		ADD	ESI,ECX
		AND	EAX,1FH
L5$:
		MOV	ECX,[ESI]
		ADD	ESI,4

		NOT	ECX

		MOV	ORDBITS_NUMBER,EDX
		MOV	ORDBITS_PTR,ESI

		TEST	EAX,EAX		;ANY MORE BITS TO SKIP ?
		JZ	L8$
L6$:
		SHR	ECX,1
		INC	EDX

		DEC	EAX
		JNZ	L6$
L8$:
		MOV	CURN_ORDNUM_DWORD,ECX
		MOV	CURN_ORDNUM,EDX

		POP	ESI

		RET

NEXT_ORDNUM_INIT	ENDP


FLUSH_EXPORTS_STRUCTURE	PROC
		;
		;FLUSH ANY DATA TO OUTPUT FILE, RELEASING STORAGE
		;
		PUSHM	EDI,ESI,EBX
		LEA	EBX,PE_EXPORTS_STRUCTURE
		ASSUME	EBX:PTR SEQ_STRUCT

		MOV	ECX,[EBX]._SEQ_PTR		;# OF BYTES IN TABLE
		LEA	EBX,[EBX]._SEQ_TABLE
		ASSUME	EBX:NOTHING

		TEST	ECX,ECX
		JZ	L9$
L1$:
;		MOV	EAX,[EBX]
		CALL	CONVERT_SUBBX_TO_EAX		;THERE MIGHT BE HOLES...
		ADD	EBX,4
		;
		;IF ECX > PAGE_SIZE, WRITE PAGE_SIZE
		;
		PUSHM	ECX,EAX

		CMP	ECX,PAGE_SIZE
		JB	L2$

		MOV	ECX,PAGE_SIZE
L2$:
		PUSH	ECX
		MOV	EDX,PEEXP_ADDRESSES_FA

		ADD	PEEXP_ADDRESSES_FA,ECX
		CALL	MOVE_EAX_TO_EDX_FINAL

		POP	EDX				;BYTES MOVED
		POP	EAX				;BLOCK ADDRESS

		POP	ECX				;TOTAL BYTES TO MOVE
		CALL	RELEASE_BLOCK

		SUB	ECX,EDX
		JNZ	L1$
L9$:
		POPM	EBX,ESI,EDI

		RET

FLUSH_EXPORTS_STRUCTURE	ENDP

endif

		PUBLIC	UNUSE_ENTRYNAMES

UNUSE_ENTRYNAMES	PROC
		;
		;I AM DONE USING ENTRYNAME TABLE, AM I THE LAST?
		;
		DEC	EXPORT_TABLE_USE
		JZ	RELEASE_ENTRYNAME_TABLE

		RET

UNUSE_ENTRYNAMES	ENDP


RELEASE_ENTRYNAME_TABLE PROC	NEAR
		;
		;
		;
		MOV	EAX,OFF ENTRYNAME_STUFF
		push	EAX
		call	_release_minidata
		add	ESP,4

		MOV	EAX,OFF ENTRYNAME_GARRAY
		JMP	RELEASE_GARRAY

RELEASE_ENTRYNAME_TABLE ENDP


		END

