		TITLE	DEF - Copyright (c) SLR Systems 1992

		INCLUDE MACROS
		INCLUDE	SECTS
		INCLUDE	SYMBOLS
		INCLUDE	SEGMSYMS
		INCLUDE	SEGMENTS
		INCLUDE	CLASSES
		INCLUDE	EXES
		INCLUDE	IO_STRUC
		INCLUDE	WINMACS

		PUBLIC	PROCESS_DEF,RC_PROTMODE,GET_NUM_DOT_NUM

		EXTERNDEF	STUBSTUFF:CMDLINE_STRUCT,RCSTUFF:CMDLINE_STRUCT


		.DATA

		EXTERNDEF	SYMBOL_TEXT:BYTE,EXETYPE_FLAG:BYTE,SEG_COMBINE:BYTE,EXP_FLAGS:BYTE,EXP_FLAGS_EXT:BYTE,EXP_PWORDS:BYTE
		EXTERNDEF	COMMENT_CHAR:BYTE,FNTBL:BYTE,INBUF:BYTE,CLASS_TYPE:BYTE,SEG32_FLAGS:BYTE

		EXTERNDEF	SEG_NAME_LINDEX:DWORD,CLASS_NAME_LINDEX:DWORD,IMPEXP_INTNAM:DWORD,IMPEXP_NAM:DWORD,IMPEXP_MOD:DWORD
		EXTERNDEF	SYMBOL_LENGTH:DWORD,INPTR1:DWORD,FLAG_0C_MASK:DWORD,DATA_DEFAULTS:DWORD,SPECIFIC_FLAGS:DWORD
		EXTERNDEF	SPECIFIC_MASK:DWORD,TOKSTR:DWORD,CODE_DEFAULTS_MASK:DWORD,DATA_DEFAULTS_MASK:DWORD,FLAG_0C:DWORD
		EXTERNDEF	IMP_ORDNUM:DWORD,EXP_ORDNUM:DWORD,WINDOWS_RELEASE:DWORD,CURN_COUNT:DWORD,SYMBOL_HASH:DWORD
		EXTERNDEF	OVERLAY_NUMBER:DWORD,SEG_OS2_FLAGS:DWORD,FIRST_CLASS_GINDEX:DWORD,CODE_DEFAULTS:DWORD
		EXTERNDEF	DEF_SEGMENT_GINDEX:DWORD,APPLOADER_SEGMENT_GINDEX:DWORD,FIRST_FARCALL:DWORD,LAST_FARCALL:DWORD
		EXTERNDEF	EXE_DESCRIPTION:DWORD,CURN_INPTR:DWORD,DEFFILE:DWORD,HEAP_SIZE:DWORD,OMF_NAME:DWORD
		EXTERNDEF	FIRST_COMDAT_SUGGESTED:DWORD,LAST_COMDAT_SUGGESTED:DWORD,PE_BASE:DWORD

		EXTERNDEF	STUB_LIST:FILE_LISTS,OLD_LIST:FILE_LISTS,RC_LIST:FILE_LISTS,CODE_TPTR:TPTR_STRUCT,INDNAM:NFN_STRUCT
		EXTERNDEF	SEGMENT_GARRAY:STD_PTR_S,PEXEHEADER:PEXE,NEXEHEADER:NEXE,FILNAM:NFN_STRUCT,SYMBOL_TPTR:TPTR_STRUCT

		EXTERNDEF	OPTI_MOVE:DWORD,GINPUT_LINE_NUMBER:DWORD



		.CODE	FILEPARSE_TEXT

		EXTERNDEF	GET_NUMBER16:PROC,HANDLE_OLD:PROC,YYLEX_SYMBOL:PROC,NEST_INDIRECT:PROC,GET_KEYWORD:PROC
		EXTERNDEF	GET_SEGMENT_ENTRY:PROC,GETNST:PROC,VERIFY_DEFINES:PROC,SET_STACK_1:PROC,_move_nfn:proc
		EXTERNDEF	YYLEX_FILENAME:PROC,ERR_INBUF_RET:PROC,GET_SYMBOL:PROC,DEFINE_EXPORT:PROC,HANDLE_STUB:PROC
		EXTERNDEF	FAR_INSTALL:PROC,ADD_TO_EXTERNAL_LIST:PROC,DEFINE_IMPORT:PROC,ERR_INBUF_ABORT:PROC
		EXTERNDEF	SELECT_OUTPUT_SEGMENTED:PROC,HANDLE_RCS:PROC,DEFINE_CLASS:PROC,LNAME_INSTALL:PROC
		EXTERNDEF	INIT_LOCAL_STORAGE:PROC,RELEASE_LOCAL_STORAGE:PROC,ALLOC_LOCAL:PROC,LDATA_ALLOC:PROC
		EXTERNDEF	MAKE_TPTR_LINDEX:PROC,YY_FILENAME:PROC,OPTI_MOVE_UPPER_IGNORE:PROC,GET_NUMBER:PROC
		EXTERNDEF	_parse_filename:proc

		EXTERNDEF	SYNTAX_ERR:ABS,ONE_NAME_ERR:ABS,ONE_DESC_ERR:ABS,DEF_CODE_ERR:ABS,DEF_DATA_ERR:ABS
		EXTERNDEF	DEF_SEGMENTS_ERR:ABS,DUP_HEAP_ERR:ABS,DEF_EXETYPE_ERR:ABS,DUP_ENT_ORD_ERR:ABS
		EXTERNDEF	EXPORT_CONFLICT_ERR:ABS,PROT_REAL_ERR:ABS,DEF_IMPORTS_ERR:ABS,DEF_EXPORTS_ERR:ABS,DUP_OLD_ERR:ABS
		EXTERNDEF	DUP_STUB_ERR:ABS,DEF_STRING_ERR:ABS,APPLOAD_ERR:ABS,SECTION_ERR:ABS,SUBSYSTEM_ERR:ABS


.XLIST

XX	=	0
DEF		MACRO	X
X&_ID		EQU	+XX
XX		=	XX+1
		ENDM

DEF	EOF
DEF	APPLOADER
DEF	CODE
DEF	DATA
DEF	DESCRIPTION
DEF	EXETYPE
DEF	EXPORTS
DEF	FUNCTIONS
DEF	HEAPSIZE
DEF	IMPORTS
DEF	INCLUDE
DEF	LIBRARY
DEF	NAME
DEF	OLD
DEF	PROTMODE
DEF	RC
DEF	REALMODE
DEF	SEGMENTS
DEF	STACKSIZE
DEF	STUB
DEF	CODECLASSES
DEF	NEWFILES
DEF	NOEMUFLOAT
DEF	SUBSYSTEM
DEF	VERSION
DEF	FIXDS

LAST_MAIN_TOKEN EQU	FIXDS_ID

DEF	WINDOWAPI
DEF	WINDOWCOMPAT
DEF	NOTWINDOWCOMPAT
DEF	INITGLOBAL
DEF	INITINSTANCE
DEF	PRIVATELIB

DEF	CONFORMING
DEF	DISCARDABLE
DEF	EXECUTEONLY
DEF	EXECUTEREAD
DEF	FIXED
DEF	IOPL
DEF	LOADONCALL
DEF	MOVABLE
DEF	MULTIPLE
DEF	NOIOPL
DEF	NONCONFORMING
DEF	NONDISCARDABLE
DEF	NONE
DEF	NONSHARED
DEF	PRELOAD
DEF	READONLY
DEF	READWRITE
DEF	SHARED
DEF	SINGLE

DEF	EXECUTE
DEF	READ
DEF	WRITE

DEF	OS2
DEF	WINDOWS
DEF	DOS4
DEF	UNKNOWN
DEF	DOS
DEF	NT
DEF	DOSX

DEF	NODATA
DEF	NONAME
DEF	RESIDENTNAME
DEF	PRIVATE
DEF	CONSTANT
DEF	BYNAME
DEF	CLASS
DEF	MAXVAL
DEF	OVL
DEF	BASE
DEF	NATIVE
DEF	CONSOLE
DEF	POSIX

DEF	PROCESSINIT
DEF	PROCESSTERM
DEF	THREADINIT
DEF	THREADTERM



IMPURE_ID	EQU	NONSHARED_ID
LONGNAMES_ID	EQU	NEWFILES_ID
OBJECTS_ID	EQU	SEGMENTS_ID
PURE_ID		EQU	SHARED_ID
SECTIONS_ID	EQU	SEGMENTS_ID

.LIST


PROCESS_DEF	PROC
		;
		;OPEN AND READ .DEF FILE FOR SEGMENT ORDERING, ETC
		;
if	fg_td
		RESS	TLINK_SYNTAX
endif
;		ALLMSG	'DEF Verify Defines'

		CALL	VERIFY_DEFINES			;MAKE SURE DEFINES ARE DONE

;		ALLMSG	'DEF Setup INPTR'

		MOV	EAX,CURN_INPTR
		MOV	ECX,INPTR1
		MOV	CURN_COUNT,2
		MOV	BPTR [EAX],1AH
		XOR	AL,AL
		MOV	DPTR [ECX],0A0DH
		MOV	GINPUT_LINE_NUMBER,0
		MOV	COMMENT_CHAR,AL			;NO LOW-LEVEL COMMENT CHARACTER
		OR	FNTBL+'.',MASK SYMTBL_ILLEGAL	;. ILLEGAL IN SYMBOLS
		OR	FNTBL+"'",MASK SYMTBL_ILLEGAL	;' ILLEGAL IN SYMBOLS
		RESS	ECHO_INDIRECT,AL
		RESS	INBUF_EOF,AL
		RESS	GET_LINE_PARTIAL,AL
		RESS	SUPPORT_AT_INDIRECT,AL
		SETT	DEF_IN_PROGRESS
		;
		;PROCESS .DEF FILE TILL EOF
		;
if	fg_winpack

WIN_DEF		PROC	NEAR
		;
		;IF WINPACK IS SELECTED, FAKE AN APPLOADER .DEF STATEMENT...
		;
		BITT	WINPACK_SELECTED
		JZ	L9$
		;
		;SET UP SEGMENTS STATEMENT FOR LOADER_APPLOADERNAME MOVABLE
		;
		;INSERT LOADER_ IN FRONT OF SYMBOLTEXT
		;
		MOV	EAX,OFF SLRLOAD_TXT
		CALL	MOVE_EAX_TO_INBUF

		CALL	DEF_APPLOADER

		;
		;FORCE 'KERNEL' TO BE MODULE #1
		;
		MOV	EAX,OFF KERNEL_TXT
		CALL	MOVE_EAX_TO_INBUF

		CALL	DEF_IMPORTS

		MOV	ESI,OFF INBUF
		XOR	EAX,EAX
		MOV	INPTR1,ESI
		MOV	DEF_SEGMENT_GINDEX,EAX	;LET AUTO-PACKCODE STILL HAPPEN...
		MOV	DPTR [ESI],0A0DH

		CALL	DEF_PROTMODE		;FORCE PROTMODE

;		JMP	9$


L9$:

WIN_DEF		ENDP

endif

		BITT	DEFFILE_SELECTED
		JZ	L9$
		RESS	INBUF_EOF
		RESS	GET_LINE_PARTIAL
		MOV	ECX,DEFFILE
		MOV	EAX,OFF INDNAM

		push	ECX
		push	EAX
		call	_move_nfn
		add	ESP,8
		;
		;SHOULD ALREADY BE AT EOF
		;
;		ALLMSG	'DEF Nest Indirect'

		CALL	NEST_INDIRECT
		RESS	ECHO_ANY
L1$:
		CALL	YYLEX		;GET TOKEN
		JNZ	L7$		;JMP IF UNRECOGNIZED
		CMP	ECX,LAST_MAIN_TOKEN
		JA	L6$
		CALL	DEF_TABLE[ECX*4]
		JMP	L1$

L6$:
		MOV	ESI,EDX
L7$:
		JMP	SYN_ERROR

L9$:
		RESS	DEF_IN_PROGRESS
		RET

PROCESS_DEF	ENDP


MOVE_EAX_TO_INBUF	PROC	NEAR
		;
		;
		;
		PUSHM	EDI,ESI

		XOR	ECX,ECX
		LEA	ESI,[EAX+1]

		MOV	EDI,OFF INBUF
		MOV	CL,[EAX]

		MOV	INPTR1,EDI

		REP	MOVSB

		POPM	ESI,EDI

		RET

MOVE_EAX_TO_INBUF	ENDP


SLRLOAD_TXT	DB	SIZEOF SLRLOAD_TXT-1," '__SLRLOAD'  OS2 "

KERNEL_TXT	DB	SIZEOF KERNEL_TXT-1,' $$SLR$C2D$SLR$$=KERNEL.170  $$SLR$AH$SLR$$=KERNEL.114  $$SLR$MB$SLR$$=USER.1 OS2 '


DEF_EOF		PROC
		;
		;
		;
		POP	ESI			;OLD RETURN ADDRESS...
		RESS	DEF_IN_PROGRESS
		RET

DEF_EOF		ENDP


YYLEX		PROC	NEAR
		;
		;
		;
		CALL	GET_KEYWORD
		;
		;VALID TOKENS ARE:
		;
		;	ALIAS		;???
		;	APPLOADER
		;	BASE		;???
		;	CLASS
		;	CODE
		;	CODECLASSES
		;	CONFORMING
		;	CONSTANT	;???
		;	CONTIGUOUS	;???
		;	DATA
		;	DESCRIPTION
		;	DEV386		;???
		;	DEVICE		;???
		;	DISCARDABLE
		;	DOS
		;	DOS4
		;	DOSX
		;	DYNAMIC		;???
		;	EXECUTE
		;	EXECUTE-ONLY
		;	EXECUTEONLY
		;	EXECUTEREAD
		;	EXETYPE
		;	EXPANDDOWN	;???
		;	EXPORTS
		;	FIXDS
		;	FIXED
		;	FUNCTIONS
		;	HEAPSIZE
		;	HUGE		;???
		;	IMPORTS
		;	IMPURE
		;	INCLUDE
		;	INITGLOBAL
		;	INITINSTANCE
		;	INVALID		;???
		;	IOPL
		;	LIBRARY
		;	LOADONCALL
		;	LONGNAMES
		;	MACINTOSH	;???
		;	MAXVAL
		;	MIXED1632	;???
		;	MOVABLE
		;	MOVEABLE
		;	MULTIPLE
		;	NAME
		;	NEWFILES
		;	NODATA
		;	NOEMUFLOAT
		;	NOEXPANDDOWN	;???
		;	NOIOPL
		;	NONAME
		;	NONCONFORMING
		;	NONDISCARDABLE
		;	NONE
		;	NONPERMANENT	;???
		;	NONSHARED
		;	NOTWINDOWCOMPAT
		;	NULL		;???
		;	OBJECTS
		;	OLD
		;	OS2
		;	OVERLAY
		;	OVL
		;	PERMANENT	;???
		;	PHYSICAL	;???
		;	PRELOAD
		;	PRIVATE
		;	PRIVATELIB
		;	PROTMODE
		;	PURE
		;	RC
		;	READ
		;	READONLY
		;	READWRITE
		;	REALMODE
		;	RESIDENT	;???
		;	RESIDENTNAME
		;	SECTIONS
		;	SEGMENTS
		;	SHARED
		;	SINGLE
		;	STACKSIZE
		;	STUB
		;	SUBSYSTEM	;???
		;	SWAPPABLE	;???
		;	TERMINSTANCE	;???
		;	UNKNOWN
		;	VERSION		;???
		;	VIRTUAL		;???
		;	WINDOWAPI
		;	WINDOWCOMPAT
		;	WINDOWS
		;	WRITE
		;
		XOR	EAX,EAX
		MOV	ESI,OFF SYMBOL_TEXT

		MOV	EDX,SYMBOL_LENGTH
		XOR	ECX,ECX

		DEC	EDX
		MOV	AL,[ESI]

		MOV	EDX,0FFFFFFH
		JZ	L5$

		SUB	AL,'A'
		INC	ESI

		CMP	AL,26
		JAE	L1$

		CALL	YYLEX_TABLE[EAX*4]

		MOV	EAX,ESI
		JZ	L2$
L1$:
		OR	ESI,ESI
RESTORE::
		MOV	EAX,TOKSTR
		MOV	INPTR1,EAX		;UNRECOGNIZED, PUT IT BACK
		RET

YY_FAIL::
		OR	AL,-1
		RET


L5$:
		CMP	AL,CH_SEMI
		JNZ	L1$

		CALL	GETNST			;WHAT WAS IT?

		CMP	AL,1AH
		JNZ	L1$

		XOR	ECX,ECX

		RET

L2$:
		;
		;CHECK FOR length match
		;
		SUB	EAX,OFF SYMBOL_TEXT
		MOV	EDX,SYMBOL_LENGTH

		CMP	EDX,EAX
		JNZ	RESTORE

		RET

YYLEX		ENDP

SYN_ERROR:
		MOV	AL,SYNTAX_ERR
SYN_ERROR_FINAL:
		CALL	ERR_INBUF_ABORT

SYN_ERROR_RET	PROC	NEAR
		;
		CALL	ERR_INBUF_RET
		RET

SYN_ERROR_RET	ENDP


YYLEX_SUBS	PROC	NEAR

YY_A::
		;
		;APPLOADER
		;
		MOV	EAX,[ESI]
		ADD	ESI,4

		CMP	EAX,'OLPP'
		JNZ	YY_A9
		MOV	EAX,[ESI]
		MOV	CL,APPLOADER_ID

		ADD	ESI,4
		CMP	EAX,'REDA'
YY_A9:
		RET

YY_B::
		;
		;BASE
		;BYNAME
		;
		MOV	AL,[ESI]
		INC	ESI

		CMP	AL,'A'
		JZ	YY_BA

		CMP	AL,'Y'
		JNZ	YY_NBY

		MOV	EAX,[ESI]
		MOV	CL,BYNAME_ID

		ADD	ESI,4
		CMP	EAX,'EMAN'
YY_B9:
		RET

YY_BA:
		MOV	AL,[ESI]
		INC	ESI

		CMP	AL,'S'
		JNZ	YY_NBY

		MOV	AL,[ESI]
		INC	ESI

		MOV	CL,BASE_ID
		CMP	AL,'E'
YY_NBY:
		RET

YY_C::
		;
		;CLASS
		;CODE
		;CODECLASSES
		;CONFORMING
		;CONSOLE
		;CONSTANT
		;
		MOV	EAX,[ESI]
		ADD	ESI,2
		CMP	AX,'AL'
		JZ	YY_CLA
		CMP	AX,'DO'
		JZ	YY_COD
		CMP	AX,'NO'
		JNZ	YY_C_RET
YY_CON:
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'ELOS'
		MOV	CL,CONSOLE_ID
		JZ	YY_CONSOLE
		CMP	EAX,'NATS'
		JZ	YY_CONSTAN
		CMP	EAX,'MROF'
		JNZ	YY_C_RET
		MOV	EAX,[ESI]
		ADD	ESI,3
		AND	EAX,EDX
		MOV	CL,CONFORMING_ID
		CMP	EAX,'GNI'
YY_CONSOLE:
		RET

YY_CONSTAN:
		MOV	AL,[ESI]
		INC	ESI

		CMP	AL,'T'
		MOV	CL,CONSTANT_ID

		RET

YY_CLA:
		MOV	EAX,[ESI]
		MOV	CL,CLASS_ID
		ADD	ESI,2
		CMP	AX,'SS'
		RET

YY_COD:
		MOV	EAX,[ESI]
		INC	ESI
		CMP	AL,'E'
		JNZ	YY_C_RET

		CMP	AH,'C'
		MOV	CL,CODE_ID
		JNZ	YY_Y_RET

		MOV	EAX,1[ESI]
		ADD	ESI,5
		CMP	EAX,'SSAL'
		JNZ	YY_C_RET
		MOV	EAX,[ESI]
		MOV	CL,CODECLASSES_ID
		ADD	ESI,2
		CMP	AX,'SE'
		RET

YY_Y_RET:
		CMP	AL,AL
YY_C_RET:
		RET

YY_D::
		;	DATA
		;	DESCRIPTION
		;	DISCARDABLE
		;	DOS
		;	DOS4
		;	DOSX
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'A'
		JZ	YY_DA
		CMP	AL,'I'
		JZ	YY_DI
		CMP	AL,'O'
		JZ	YY_DO
		CMP	AL,'E'
		JNZ	YY_D9
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'IRCS'
		JNZ	YY_D9
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'OITP'
		JNZ	YY_D9
		MOV	AL,[ESI]
		INC	ESI
		MOV	CL,DESCRIPTION_ID
		CMP	AL,'N'
YY_D9:
		RET

YY_DO:
		;
		;DOS
		;DOS4
		;DOSX
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'S'
		JNZ	YY_D9
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'4'
		MOV	CL,DOS4_ID
		JZ	YY_D9
		CMP	AL,'X'
		MOV	CL,DOSX_ID
		JZ	YY_D9
		DEC	ESI
		CMP	AL,AL
		MOV	CL,DOS_ID
		RET

YY_DI:
		;
		;DISCARDABLE
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'RACS'
		JNZ	YY_D9
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'LBAD'
		JNZ	YY_D9
		MOV	AL,[ESI]
		INC	ESI
		MOV	CL,DISCARDABLE_ID
		CMP	AL,'E'
		RET

YY_DA:
		MOV	EAX,[ESI]
		MOV	CL,DATA_ID
		ADD	ESI,2
		CMP	AX,'AT'
		RET

YY_E::
		;
		;	EXECUTEONLY
		;	EXECUTE-ONLY
		;	EXECUTEREAD
		;	EXETYPE
		;	EXPORTS
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'X'
		JNZ	YY_E9
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'E'
		JZ	YY_EXE
		CMP	AL,'P'
		JNZ	YY_E9
		LODSD
		MOV	CL,EXPORTS_ID
		CMP	EAX,'STRO'
YY_E9:
		RET

YY_EXE:
		;
		;	EXECUTE
		;	EXECUTEONLY
		;	EXECUTE-ONLY
		;	EXECUTEREAD
		;	EXETYPE
		;
		LODSD
		CMP	EAX,'ETUC'
		JZ	YY_EXECUTE
		CMP	EAX,'EPYT'
		MOV	CL,EXETYPE_ID
		RET

YY_EXECUTE:
		MOV	CL,[ESI]
		MOV	EAX,[ESI+1]
		INC	ESI
		CMP	CL,'-'
		JZ	YY_EXECUTE_1
		MOV	EAX,[ESI-1]
		DEC	ESI
YY_EXECUTE_1:
		MOV	CL,EXECUTEREAD_ID
		ADD	ESI,4
		CMP	EAX,'DAER'
		JZ	YY_E9
		CMP	EAX,'YLNO'
		MOV	CL,EXECUTEONLY_ID
		JZ	YY_E9
		SUB	ESI,4
		MOV	CL,EXECUTE_ID
		CMP	AL,AL
		RET

YY_F::
		;
		;FIXDS
		;FIXED
		;FUNCTIONS
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'TCNU'
		JZ	YY_FUNCT
		CMP	EAX,'DEXI'
		MOV	CL,FIXED_ID
		JZ	YY_F9
		CMP	EAX,'SDXI'
		MOV	CL,FIXDS_ID
YY_F9:
		RET

YY_FUNCT:
		LODSD
		MOV	CL,FUNCTIONS_ID
		CMP	EAX,'SNOI'
		RET

YY_H::
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'SPAE'
		JNZ	YY_H9
		MOV	EAX,[ESI]
		ADD	ESI,3
		AND	EAX,EDX
		MOV	CL,HEAPSIZE_ID
		CMP	EAX,'EZI'
YY_H9:
		RET

YY_I::
		;
		;	IMPORTS
		;	IMPURE
		;	INCLUDE
		;	INITGLOBAL
		;	INITINSTANCE
		;	IOPL
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'M'
		JZ	YY_IM
		CMP	AL,'N'
		JZ	YY_IN
		CMP	AL,'O'
		JZ	YY_IO
YY_I9:
		RET

YY_IM:
		;
		;	IMPORTS
		;	IMPURE
		;
		LODSD
		MOV	CL,IMPURE_ID
		CMP	EAX,'ERUP'
		JZ	YY_I9
		CMP	EAX,'TROP'
		JNZ	YY_I9
		LODSB
		MOV	CL,IMPORTS_ID
		CMP	AL,'S'
		RET

YY_IN:
		;
		;	INCLUDE
		;	INITGLOBAL
		;	INITINSTANCE
		;
		LODSD
		CMP	EAX,'DULC'
		JZ	YY_INCLUD
		CMP	EAX,'LGTI'
		JZ	YY_INITGL
		CMP	EAX,'NITI'
		JZ	YY_INITIN
		RET

YY_INCLUD:
		LODSB
		MOV	CL,INCLUDE_ID
		CMP	AL,'E'
		RET

YY_INITGL:
		LODSD
		MOV	CL,INITGLOBAL_ID
		CMP	EAX,'LABO'
		RET

YY_INITIN:
		LODSD
		CMP	EAX,'NATS'
		JNZ	YY_I9
		LODSW
		CMP	AX,'EC'
		MOV	CL,INITINSTANCE_ID
		RET

YY_IO:
		;
		;IOPL
		;
		LODSW
		CMP	AX,'LP'
		MOV	CL,IOPL_ID
		RET

YY_L::
		;
		;LIBRARY
		;LOADONCALL
		;LONGNAMES
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'ARBI'
		JZ	YY_LIBRA
		CMP	EAX,'ODAO'
		JZ	YY_LOADO
		CMP	EAX,'NGNO'
		JZ	YY_LONGN
YY_L9:
		RET

YY_LIBRA:
		LODSW
		CMP	AX,'YR'
		MOV	CL,LIBRARY_ID
		RET

YY_LOADO:
		LODSD
		CMP	EAX,'LACN'
		JNZ	YY_L9
		LODSB
		MOV	CL,LOADONCALL_ID
		CMP	AL,'L'
		RET

YY_LONGN:
		LODSD
		MOV	CL,LONGNAMES_ID
		CMP	EAX,'SEMA'
		RET

YY_M::
		;
		;MAXVAL
		;MOVABLE
		;MOVEABLE
		;MULTIPLE
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'AEVO'
		JZ	YY_MOVEA
		CMP	EAX,'BAVO'
		JZ	YY_MOVAB
		CMP	EAX,'AVXA'
		JZ	YY_MAXVA
		CMP	EAX,'ITLU'
		JZ	YY_MULTI
		RET

YY_MOVEA:
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,MOVABLE_ID
		CMP	EAX,'ELB'
		RET

YY_MOVAB:
		LODSW
		CMP	AX,'EL'
		MOV	CL,MOVABLE_ID
		RET

YY_MAXVA:
		LODSB
		MOV	CL,MAXVAL_ID
		CMP	AL,'L'
		RET

YY_MULTI:
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,MULTIPLE_ID
		CMP	EAX,'ELP'
		RET

YY_NE:
		LODSD
		CMP	EAX,'LIFW'
		JNZ	YY_N9
		LODSW
		CMP	AX,'SE'
		MOV	CL,NEWFILES_ID
		RET

YY_NA:
		LODSW
		CMP	AX,'IT'
		JZ	YY_NATI
		CMP	AX,'EM'
		MOV	CL,NAME_ID
YY_N9:
		RET

YY_NATI:
		LODSW
		CMP	AX,'EV'
		MOV	CL,NATIVE_ID
		RET

YY_N::
		;
		;	NAME
		;	NATIVE
		;	NEWFILES
		;	NODATA
		;	NOEMUFLOAT
		;	NOIOPL
		;	NONAME
		;	NONCONFORMING
		;	NONDISCARDABLE
		;	NONE
		;	NONSHARED
		;	NOTWINDOWCOMPAT
		;	NT
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'O'
		JZ	YY_NO
		CMP	AL,'A'
		JZ	YY_NA
		CMP	AL,'E'
		JZ	YY_NE
		CMP	AL,'T'
		MOV	CL,NT_ID
		RET

YY_NO:
		LODSB
		CMP	AL,'N'
		JZ	YY_NON
		CMP	AL,'T'
		JZ	YY_NOT
		CMP	AL,'D'
		JZ	YY_NOD
		CMP	AL,'I'
		JZ	YY_NOI
		CMP	AL,'E'
		JZ	YY_NOE
YY_NO9:
		RET

YY_NOE:
		;
		;MUST BE NOEMUFLOAT
		;
		LODSD
		CMP	EAX,'LFUM'
		JNZ	YY_NO9
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,NOEMUFLOAT_ID
		CMP	EAX,'TAO'
		RET

YY_NOI:
		;
		;MUST BE NOIOPL
		;
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,NOIOPL_ID
		CMP	EAX,'LPO'
		RET

YY_NOT:
		LODSD
		CMP	EAX,'DNIW'
		JNZ	YY_NO9
		LODSD
		CMP	EAX,'OCWO'
		JNZ	YY_NO9
		LODSD
		MOV	CL,NOTWINDOWCOMPAT_ID
		CMP	EAX,'TAPM'
		RET

YY_NOD:
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,NODATA_ID
		CMP	EAX,'ATA'
		RET

YY_NON:
		;
		;	NONAME
		;	NONCONFORMING
		;	NONDISCARDABLE
		;	NONE
		;	NONSHARED
		;
		LODSB
		CMP	AL,'E'
		JBE	YY_NONE_
		CMP	AL,'S'
		JZ	YY_NONS
YY_NON9:
		RET

YY_NONE_:
		MOV	CL,NONE_ID
		JZ	YY_NON9
		CMP	AL,'A'
		JZ	YY_NONA
		CMP	AL,'C'
		JZ	YY_NONC
		CMP	AL,'D'
		JNZ	YY_NON9
YY_NOND:
		LODSD
		CMP	EAX,'ACSI'
		JNZ	YY_NON9
		LODSD
		CMP	EAX,'BADR'
		JNZ	YY_NON9
		LODSW
		CMP	AX,'EL'
		MOV	CL,NONDISCARDABLE_ID
		RET

YY_NONA:
		LODSW
		CMP	AX,'EM'
		MOV	CL,NONAME_ID
		RET

YY_NONC:
		LODSD
		CMP	EAX,'OFNO'
		JNZ	YY_NON9
		LODSD
		CMP	EAX,'NIMR'
		JNZ	YY_NON9
		LODSB
		MOV	CL,NONCONFORMING_ID
		CMP	AL,'G'
		RET

YY_NONS:
		LODSD
		CMP	EAX,'ERAH'
		JNZ	YY_NON9
		LODSB
		MOV	CL,NONSHARED_ID
		CMP	AL,'D'
		RET

YY_O::
		;
		;OBJECTS
		;OLD
		;OS2
		;OVERLAY
		;OVL
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'B'
		JZ	YY_OB
		CMP	AL,'L'
		JZ	YY_OL
		CMP	AL,'S'
		JZ	YY_OS
		CMP	AL,'V'
		JZ	YY_OV
YY_O9:
		RET

YY_OB:
		LODSD
		CMP	EAX,'TCEJ'
		JNZ	YY_O9
		LODSB
		MOV	CL,OBJECTS_ID
		CMP	AL,'S'
		RET

YY_OL:
		LODSB
		MOV	CL,OLD_ID
		CMP	AL,'D'
		RET

YY_OS:
		LODSB
		MOV	CL,OS2_ID
		CMP	AL,'2'
		RET

YY_OV:
		LODSB
		MOV	CL,OVL_ID
		CMP	AL,'L'
		JZ	YY_O9
		CMP	AL,'E'
		JNZ	YY_O9
		LODSD
		CMP	EAX,'YALR'
		RET

YY_P::
		;
		;POSIX
		;PRELOAD
		;PRIVATE
		;PRIVATELIB
		;PROCESSINIT
		;PROCESSTERM
		;PROTMODE
		;PURE
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'O'
		JZ	YY_PO
		CMP	AL,'U'
		JZ	YY_PU
		CMP	AL,'R'
		JNZ	YY_P_1
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'E'
		JZ	YY_PRE
		CMP	AL,'I'
		JZ	YY_PRI
		CMP	AL,'O'
		JNZ	YY_P_1
		LODSD
		CMP	EAX,'SSEC'
		JZ	YY_PROCESS
		CMP	EAX,'DOMT'
		JNZ	YY_P_1
		LODSB
		MOV	CL,PROTMODE_ID
		CMP	AL,'E'
YY_P_1:
		RET

YY_PO:
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,POSIX_ID
		CMP	EAX,'XIS'
		RET

YY_PROCESS:
		LODSD
		CMP	EAX,'TINI'
		MOV	CL,PROCESSINIT_ID
		JZ	YY_P_1
		CMP	EAX,'MRET'
		MOV	CL,PROCESSTERM_ID
		RET

YY_PRI:
		LODSD
		CMP	EAX,'ETAV'
		JNZ	YY_PRI_9
		MOV	EAX,[ESI]
		ADD	ESI,3
		AND	EAX,EDX
		MOV	CL,PRIVATELIB_ID
		CMP	EAX,'BIL'
		JNZ	YY_PRIVATE
YY_PRI_9:
		RET

YY_PRIVATE:
		MOV	CL,PRIVATE_ID
		SUB	ESI,3
		CMP	AL,AL
		RET

YY_PU::
		;
		;PURE
		;
		LODSW
		CMP	AX,'ER'
		MOV	CL,PURE_ID
		RET

YY_PRE:
		;
		;PRELOAD
		;
		LODSD
		MOV	CL,PRELOAD_ID
		CMP	EAX,'DAOL'
YY_PRE_9:
		RET

YY_R::
		;
		;	RC
		;	READ
		;	READONLY
		;	READWRITE
		;	REALMODE
		;	RESIDENTNAME
		;
		MOV	EAX,[ESI-1]
		ADD	ESI,3

		CMP	AH,'C'
		JZ	YY_RC9

		CMP	AH,'E'
		JNZ	YY_R9
		CMP	EAX,'DAER'
		JZ	YY_READ
		CMP	EAX,'LAER'
		JZ	YY_REAL
		CMP	EAX,'ISER'
		JZ	YY_RESI
YY_R9:
		RET

YY_RC9:
		LEA	ESI,[ESI-2]
		MOV	CL,RC_ID

		RET

YY_READ:
		LODSD
		CMP	EAX,'YLNO'
		MOV	CL,READONLY_ID
		JZ	YY_R9
		CMP	EAX,'TIRW'
		JZ	YY_READWRIT
		SUB	ESI,4
		MOV	CL,READ_ID
		CMP	AL,AL
		RET

YY_READWRIT:
		LODSB
		MOV	CL,READWRITE_ID
		CMP	AL,'E'
		RET

YY_RESI:
		LODSD
		CMP	EAX,'TNED'
		JNZ	YY_R9
		LODSD
		MOV	CL,RESIDENTNAME_ID
		CMP	EAX,'EMAN'
		RET

YY_REAL:
		LODSD
		MOV	CL,REALMODE_ID
		CMP	EAX,'EDOM'
		RET

YY_S::
		;
		;	SECTIONS
		;	SEGMENTS
		;	SHARED
		;	SINGLE
		;	STACKSIZE
		;	STUB
		;	SUBSYSTEM
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'E'
		JZ	YY_SE
		CMP	AL,'H'
		JZ	YY_SH
		CMP	AL,'I'
		JZ	YY_SI
		CMP	AL,'T'
		JZ	YY_ST
		CMP	AL,'U'
		JZ	YY_SU
YY_S9:
		RET

YY_SU:
		;
		;SUBSYSTEM
		;
		LODSD
		CMP	EAX,'SYSB'
		JNZ	YY_S9
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,SUBSYSTEM_ID
		CMP	EAX,'MET'
		RET

YY_ST:
		;
		;STACKSIZE
		;STUB
		;
		LODSW
		CMP	AX,'CA'
		JZ	YY_STAC
		CMP	AX,'BU'
		MOV	CL,STUB_ID
		RET

YY_STAC:
		LODSD
		CMP	EAX,'ZISK'
		JNZ	YY_S9
		LODSB
		MOV	CL,STACKSIZE_ID
		CMP	AL,'E'
		RET

YY_SE:
		;
		;SEGMENTS
		;SECTIONS
		;
		LODSW
		CMP	AX,'MG'
		JZ	YY_SEGM
		CMP	AX,'TC'
		JZ	YY_SECT
YY_SE9:
		RET

YY_SEGM:
		LODSD
		MOV	CL,SEGMENTS_ID
		CMP	EAX,'STNE'
		RET

YY_SECT:
		LODSD
		MOV	CL,SECTIONS_ID
		CMP	EAX,'SNOI'
		RET

YY_SH:
		;
		;SHARED
		;
		LODSD
		MOV	CL,SHARED_ID
		CMP	EAX,'DERA'
YY_S_9:
		RET

YY_SI:
		;
		;SINGLE
		;
		LODSD
		MOV	CL,SINGLE_ID
		CMP	EAX,'ELGN'
		RET

YY_T::
		;
		;THREADINIT
		;THREADTERM
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'AERH'
		JNZ	YY_T9
		LODSD
		CMP	EAX,'INID'
		JZ	YY_THREADINI
		CMP	EAX,'RETD'
		JNZ	YY_T9
		LODSB
		MOV	CL,THREADTERM_ID
		CMP	AL,'M'
YY_T9:
		RET

YY_THREADINI:
		LODSB
		MOV	CL,THREADINIT_ID
		CMP	AL,'T'
		RET

YY_U::
		;
		;UNKNOWN
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'ONKN'
		JNZ	YY_U9
		LODSW
		CMP	AX,'NW'
		MOV	CL,UNKNOWN_ID
YY_U9:
		RET

YY_V::
		;
		;VERSION
		;
		MOV	EAX,[ESI]
		ADD	ESI,4
		CMP	EAX,'ISRE'
		JNZ	YY_V9
		LODSW
		CMP	AX,'NO'
		MOV	CL,VERSION_ID
YY_V9:
		RET

YY_W::
		;
		;WINDOWAPI
		;WINDOWCOMPAT
		;WINDOWS
		;WRITE
		;
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,'R'
		JZ	YY_WR
		CMP	AL,'I'
		JZ	YY_WI
YY_W9:
		RET

YY_WI:
		LODSD
		CMP	EAX,'WODN'
		JNZ	YY_W9
		LODSB
		CMP	AL,'A'
		JZ	YY_WINDOWA
		CMP	AL,'C'
		JZ	YY_WINDOWC
		CMP	AL,'S'
		MOV	CL,WINDOWS_ID
		RET

YY_WINDOWA:
		;
		;MUST BE WINDOWAPI
		;
		LODSW
		CMP	AX,'IP'
		MOV	CL,WINDOWAPI_ID
		RET

YY_WINDOWC:
		;
		;MUST BE WINDOWCOMPAT
		;
		LODSB
		CMP	AL,'O'
		JNZ	YY_W9
		LODSD
		MOV	CL,WINDOWCOMPAT_ID
		CMP	EAX,'TAPM'
		RET

YY_WR:
		LODSD
		DEC	ESI
		AND	EAX,EDX
		MOV	CL,WRITE_ID
		CMP	EAX,'ETI'
		RET


YYLEX_SUBS	ENDP


DEF_NAME	PROC	NEAR
		;
		;NAME [appname][apptype][BASE=nnn][LONGNAMES]
		;
		;CHECK FOR APPNAME OR APPTYPE
		;
		RESS	DUP_NAME_REPORTED
L1$:
		CALL	YYLEX				;NEW KEYWORD?
		JZ	L5$
		;
		;NOT RECOGNIZED, MUST BE NAME
		;
		MOV	EAX,OFF DOT_EXE
		CALL	GET_MODULE_NAME
		JNC	L1$
		JMP	L9$

L5$:
		CMP	ECX,BASE_ID
		JNZ	L6$
		CALL	GET_BASE
		JMP	L1$

L6$:
		CMP	ECX,NEWFILES_ID
		JNZ	L7$
		SETT	LONGNAMES_FLAG
		JMP	L1$

L7$:
		CALL	GET_WIN_PARAM
		JNZ	L91$
		TEST	FLAG_0C_MASK,MASK APPWINFLAGS
		JNZ	L8$
		OR	FLAG_0C,EDX			;SET APPROPRIATE BITS
		OR	FLAG_0C_MASK,MASK APPWINFLAGS
		JMP	L1$

L91$:
		CALL	RESTORE
L9$:
		TEST	FLAG_0C_MASK,MASK APPTYPE	;HAS OUTPUT TYPE BEEN
		JNZ	L8$				;ALREADY BEEN SPECIFIED?
		OR	FLAG_0C_MASK,MASK APPTYPE	;MARK IT SPECIFIED
		AND	FLAG_0C,NOT MASK APPTYPE	;OUTPUT A PROGRAM
L99$:
		RET

L8$:
		BITT	DUP_NAME_REPORTED
		JNZ	L81$
		SETT	DUP_NAME_REPORTED
		MOV	AL,ONE_NAME_ERR
		CALL	SYN_ERROR_RET
L81$:
		RET

GET_MODULE_NAME::
		;
		;
		;
		CALL	YY_MODNAME			;UPPERCASE MODULE NAME...

		JC	GNM_9				;CARRY SET IF ZERO-LENGTH NAME
		PUSH	EDI
		MOV	ECX,SYMBOL_LENGTH

		PUSH	ESI
		ADD	ECX,4

		MOV	ESI,OFF SYMBOL_LENGTH
		MOV	EAX,ECX

		TILLP2_POOL_ALLOC			;ES:DI IS PHYS, AX IS LOG
		MOV	EDI,EAX

		XCHG	OMF_NAME,EAX

		REP	MOVSB

		OR	EAX,EAX
		POPM	ESI,EDI
		JNZ	L8$
GNM_9:
		RET

GET_WIN_PARAM::
		;
		;
		;
		SUB	ECX,WINDOWAPI_ID
		CMP	ECX,NOTWINDOWCOMPAT_ID-WINDOWAPI_ID
		JA	GWP_9
		MOV	EDX,WIN_PARAM_TABLE[ECX*4]
		CMP	AL,AL
		RET

GWP_9:
		ADD	ECX,WINDOWAPI_ID
		TEST	ESP,ESP
		RET

		ALIGN	4

WIN_PARAM_TABLE DD	300H		;WINDOWAPI
		DD	200H		;WINDOWCOMPAT
		DD	100H		;NOTWINDOWCOMPAT

DEF_NAME	ENDP


GET_BASE	PROC	NEAR
		;
		;
		;
		CALL	GETNST
		CMP	AL,'='
		JNZ	L1$
		CALL	GETNST
L1$:
		DEC	INPTR1
		CALL	GET_NUMBER	;EAX
if	fg_pe
		MOV	PE_BASE,EAX
		SETT	PE_BASE_SPECIFIED
endif
		RET

GET_BASE	ENDP


DEF_LIBRARY	PROC	NEAR
		;
		;LIBRARY [appname][apptype][PRIVATELIB]
		;
		RESS	DUP_NAME_REPORTED
L1$:
		CALL	YYLEX
		JZ	L5$
		;
		;NOT RECOGNIZED, MUST BE NAME
		;
		MOV	EAX,OFF DOT_DLL
		CALL	GET_MODULE_NAME
		JNC	L1$
		JMP	L9$

L5$:
		CMP	ECX,BASE_ID
		JNZ	L6$
		CALL	GET_BASE
		JMP	L1$

L6$:
		CMP	ECX,PRIVATELIB_ID
		JNZ	L7$
		OR	FLAG_0C,MASK APP??
		JMP	L1$

L7$:
		CALL	GET_LIB_PARAM
		JNZ	L71$
		TEST	FLAG_0C_MASK,MASK APPINSTANCE
		JNZ	L8$
		AND	FLAG_0C,NOT MASK APPINSTANCE
		OR	FLAG_0C,EDX		;SET APPROPRIATE BITS
		OR	FLAG_0C_MASK,MASK APPINSTANCE
		JMP	L1$

L71$:
		CALL	GET_PE_LIB_PARAM
		JNZ	L72$
if	fg_pe
		OR	PEXEHEADER._PEXE_DLL_FLAGS,DX
endif
		JMP	L1$

L72$:
		CALL	GET_WIN_PARAM
		JNZ	L91$
		TEST	FLAG_0C_MASK,MASK APPWINFLAGS
		JNZ	L8$
		OR	FLAG_0C,EDX			;SET APPROPRIATE BITS
		OR	FLAG_0C_MASK,MASK APPWINFLAGS
		JMP	L1$

L8$:
		BITT	DUP_NAME_REPORTED
		JNZ	L81$
		SETT	DUP_NAME_REPORTED
		MOV	AL,ONE_NAME_ERR
		CALL	SYN_ERROR_RET
L81$:
		RET

L91$:
		CALL	RESTORE
L9$:
		TEST	FLAG_0C_MASK,MASK APPTYPE	;HAS OUTPUT TYPE BEEN
		JNZ	L8$				;SPECIFIED ALREADY
		OR	FLAG_0C_MASK,MASK APPTYPE
		OR	FLAG_0C,MASK APPTYPE		;OUTPUT A LIBRARY
		;
		;IF NOT SET YET, DEFINE SHARED BIT
		;
		TEST	DATA_DEFAULTS_MASK,MASK SR_MULTIPLE+MASK SR_SHARED
		JNZ	L99$
;		OR	DATA_DEFAULTS,MASK SR_SHARED
L99$:
		RET

GET_LIB_PARAM:
		;
		;
		;
		SUB	ECX,INITGLOBAL_ID
		CMP	ECX,INITINSTANCE_ID-INITGLOBAL_ID
		JA	GLP_9
		MOV	EDX,LIB_PARAM_TABLE[ECX*4]
		CMP	AL,AL
		RET

GLP_9:
		ADD	ECX,INITGLOBAL_ID
		TEST	ESP,ESP
		RET

		ALIGN	4

LIB_PARAM_TABLE LABEL	DWORD
		DD	0		;INITGLOBAL
		DD	MASK APPINSTANCE;INITINSTANCE

GET_PE_LIB_PARAM:
		;
		;
		;
		SUB	ECX,PROCESSINIT_ID
		CMP	ECX,THREADTERM_ID-PROCESSINIT_ID
		JA	GPLP_9
		MOV	EDX,PE_LIB_PARAM_TABLE[ECX*4]
		CMP	AL,AL
		RET

GPLP_9:
		ADD	ECX,PROCESSINIT_ID
		TEST	ESP,ESP
		RET


		ALIGN	4

PE_LIB_PARAM_TABLE	DD	PDLL_PPROC_INIT
			DD	PDLL_PPROC_TERM
			DD	PDLL_PTHRD_INIT
			DD	PDLL_PTHRD_TERM

DEF_LIBRARY	ENDP


DEF_APPLOADER	PROC	NEAR
		;
		;GET NAME OF EXTERNAL THAT IS LOADER CODE
		;
		OR	FLAG_0C,800H		;MARK SELF-LOAD

		CALL	YYLEX_SYMBOL
		CMP	APPLOADER_SEGMENT_GINDEX,0
		JNZ	L9$
		CMP	FIRST_CLASS_GINDEX,0
		JNZ	L9$
		CALL	FAR_INSTALL	;WHAT ABOUT HASH?
		ASSUME	ECX:PTR SYMBOL_STRUCT
		;
		;ADD UNDEFINED SYMBOL-TYPE TO EXTERNAL-REFERENCED LIST
		;
		JNC	L1$
		CMP	[ECX]._S_NSYM_TYPE,NSYM_UNDEFINED
		JNZ	L2$
L1$:
		OR	[ECX]._S_REF_FLAGS,MASK S_REFERENCED
		CALL	ADD_TO_EXTERNAL_LIST
		JMP	L2$

L9$:
		MOV	AL,APPLOAD_ERR
		JMP	SYN_ERROR_FINAL

L2$:
		PUSHM	EDI,ESI
		MOV	EDI,OFF IMPEXP_NAM
		MOV	ESI,OFF INBUF
		MOV	ECX,INBUF_LEN/4
		PUSH	INPTR1
		REP	MOVSD
		;
		;SET UP SEGMENTS STATEMENT FOR LOADER_APPLOADERNAME MOVABLE
		;
		;INSERT LOADER_ IN FRONT OF SYMBOLTEXT
		;
		MOV	EDI,OFF INBUF
		MOV	ESI,OFF LOADER_TXT	;'LOADER_'
		MOV	CL,LOADER_TXT_LEN
		MOV	INPTR1,EDI
		REP	MOVSB
		MOV	ECX,SYMBOL_LENGTH
		MOV	ESI,OFF SYMBOL_TEXT
		REP	MOVSB
		MOV	CL,MOVABLE_TXT_LEN
		MOV	ESI,OFF MOVABLE_TXT
		REP	MOVSB			;PRELOAD MOVABLE EXECUTEREAD OS2

		CALL	DEF_SEGMENTS
		;
		;MAKE SURE THAT SEGMENT IS NOT PACKCODED
		;
		MOV	EAX,DEF_SEGMENT_GINDEX
		POP	INPTR1
		MOV	APPLOADER_SEGMENT_GINDEX,EAX
		;
		;RESTORE INBUF...
		;
		MOV	ESI,OFF IMPEXP_NAM
		MOV	EDI,OFF INBUF
		MOV	ECX,INBUF_LEN/4
		REP	MOVSD
		POPM	ESI,EDI
		RET

DEF_APPLOADER	ENDP


LOADER_TXT	DB	'"LOADER_'

LOADER_TXT_LEN	EQU	$-LOADER_TXT

MOVABLE_TXT	DB	'" PRELOAD MOVABLE NONDISCARDABLE EXECUTEREAD OS2 ',0DH,0AH

MOVABLE_TXT_LEN	EQU	$-MOVABLE_TXT


DEF_DESCRIPTION PROC	NEAR
		;
		;DESCRIPTION 'Template Program'
		;
		CALL	GET_STRING	;INTO SYMBOL_DATA
		PUSHM	EDI,ESI
		MOV	ESI,OFF SYMBOL_LENGTH
		MOV	EAX,[ESI]
		ADD	EAX,4
		MOV	ECX,EAX
		TILLP2_POOL_ALLOC		;ES:DI IS PHYS, AX IS LOG
		MOV	EDI,EAX
		XCHG	EXE_DESCRIPTION,EAX
		REP	MOVSB
		OR	EAX,EAX
		JZ	L9$
		MOV	AL,ONE_DESC_ERR
		CALL	SYN_ERROR_RET
L9$:
		POPM	ESI,EDI
		RET

DEF_DESCRIPTION ENDP


DEF_INCLUDE	PROC	NEAR
		;
		;NAME FILE TO INCLUDE
		;
		MOV	EAX,OFF STUBSTUFF
		CALL	YYLEX_FILENAME

		MOV	ECX,OFF FILNAM
		MOV	EAX,OFF INDNAM

		push	ECX
		push	EAX
		call	_move_nfn
		add	ESP,8

		CALL	NEST_INDIRECT
		RET

DEF_INCLUDE	ENDP


DEF_CODECLASSES PROC	NEAR
		;
		;SPECIFY CLASSES OTHER THAN THOSE ENDING IN 'CODE' TO BE CONSIDERED
		;CODE CLASSES
		;
		CALL	INIT_LOCAL_STORAGE	;NEED VIRTUAL SPACE FOR NAME STORAGE TEMPORARILY
L1$:
		CALL	YYLEX
		JZ	L9$

		CALL	GET_CLASS
		;
		CALL	DEFINE_CLASS		;CLASS_NAME_VPTR, RETURNS AX=INDEX, BX IS PHYS
		ASSUME	ECX:PTR CLASS_STRUCT

		OR	[ECX]._C_TYPE_FLAG,MASK SEG_CLASS_IS_CODE

		JMP	L1$

L9$:
		CALL	RESTORE
		CALL	RELEASE_LOCAL_STORAGE
		RET

DEF_CODECLASSES ENDP


DEF_CODE	PROC	NEAR
		;
		;DEFINE CODE-CLASS SEGMENT DEFAULT PARAMETERS
		;
		CALL	YYLEX		;END OF ITEMS?
		JNZ	L8$
		CALL	YYLEX_SEGSTUFF	;PARSE SEGMENT PARAMETERS
		JNZ	L5$
		TEST	AL,100B 	;LEGAL FOR CODE SEGMENTS?
		JZ	L7$
		TEST	CODE_DEFAULTS_MASK,EDX	;ALREADY DECIDED?
		JZ	L3$
		;
		;ALREADY SET, SAME?
		;
		PUSHM	EDX,ECX
		AND	ECX,EDX
		AND	EDX,CODE_DEFAULTS
		CMP	ECX,EDX
		POPM	ECX,EDX
		JNZ	L7$
L3$:
		OR	CODE_DEFAULTS_MASK,EDX
		;
		;FIXED IMPLIES NON-DISCARDABLE
		;DISCARDABLE IMPLIES MOVABLE
		;
		MOV	EAX,CODE_DEFAULTS
		NOT	EBX
		AND	EAX,EBX
		OR	EAX,ECX
		MOV	CODE_DEFAULTS,EAX
		JMP	DEF_CODE

L5$:
		CALL	YYLEX_NEWSEGSTUFF
		JNZ	L9$
		OR	CODE_DEFAULTS,EAX
		JMP	DEF_CODE

L7$:
L8$:
		MOV	AL,DEF_CODE_ERR
		CALL	SYN_ERROR_RET
		RET

L9$:
		CALL	RESTORE
		MOV	EAX,CODE_DEFAULTS
		;
		TEST	EAX,MASK SR_READ OR MASK SR_WRITE OR MASK SR_EXECUTE
		JZ	L99$
		TEST	EAX,MASK SR_WRITE	;SR_WRITE IS ERROR
		JNZ	L7$
		TEST	CODE_DEFAULTS_MASK,MASK SR_EO_RO
		JNZ	L7$
;		TEST	EAX,MASK SR_EXECUTE	;MUST HAVE SR_EXECUTE
;		JZ	L7$
		TEST	EAX,MASK SR_READ
		JNZ	L95$
		OR	EAX,MASK SR_EO_RO
L95$:
		OR	CODE_DEFAULTS_MASK,MASK SR_EO_RO
L98$:
		AND	EAX,NOT (MASK SR_READ OR MASK SR_WRITE OR MASK SR_EXECUTE)
		MOV	CODE_DEFAULTS,EAX
L99$:
		RET

DEF_CODE	ENDP


DEF_DATA	PROC	NEAR
		;
		;DEFINE DATA-CLASS SEGMENT DEFAULT PARAMETERS
		;
		CALL	YYLEX		;END OF ITEMS?
		JNZ	L8$
		CALL	YYLEX_SEGSTUFF	;PARSE SEGMENT PARAMETERS
		JNZ	L5$
		TEST	AL,010B 	;LEGAL FOR DATA SEGMENTS?
		JZ	L7$
		TEST	DATA_DEFAULTS_MASK,EDX	;ALREADY DECIDED?
		JZ	L3$
		;
		;ALREADY SET, SAME?
		;
		PUSHM	EDX,ECX
		AND	ECX,EDX
		AND	EDX,DATA_DEFAULTS
		CMP	ECX,EDX
		POPM	ECX,EDX
		JNZ	L7$
L3$:
		OR	DATA_DEFAULTS_MASK,EDX
		MOV	EAX,DATA_DEFAULTS
		NOT	EBX
		AND	EAX,EBX
		OR	EAX,ECX
		MOV	DATA_DEFAULTS,EAX
		JMP	DEF_DATA

L5$:
		CALL	YYLEX_NEWSEGSTUFF
		JNZ	L9$
		OR	DATA_DEFAULTS,EAX
		JMP	DEF_DATA

L7$:
L8$:
		MOV	AL,DEF_DATA_ERR
		CALL	SYN_ERROR_RET
		RET

L9$:
		CALL	RESTORE
		MOV	EAX,DATA_DEFAULTS
		;
		TEST	EAX,MASK SR_READ OR MASK SR_WRITE OR MASK SR_EXECUTE
		JZ	L99$
		TEST	EAX,MASK SR_EXECUTE	;SR_EXECUTE IS ERROR
		JNZ	L7$
		TEST	DATA_DEFAULTS_MASK,MASK SR_EO_RO
		JNZ	L7$
;		TEST	EAX,MASK SR_READ		;MUST HAVE SR_READ
;		JZ	L7$
		TEST	EAX,MASK SR_WRITE
		JNZ	L95$
		OR	EAX,MASK SR_EO_RO
L95$:
		OR	DATA_DEFAULTS_MASK,MASK SR_EO_RO
L98$:
		AND	EAX,NOT (MASK SR_READ OR MASK SR_WRITE OR MASK SR_EXECUTE)
		MOV	DATA_DEFAULTS,EAX
L99$:
		RET

DEF_DATA	ENDP


DEF_SEGMENTS	PROC	NEAR
		;
		;DEFINE SPECIFIC SEGMENT DEFAULT PARAMETERS
		;
		;SEGMENT_NAME [CLASS 'CLASS_NAME'] [OVL:OVL NUMBER] [PARAMS]
		;
		CALL	YYLEX
		JZ	L99$
L1$:
		XOR	EAX,EAX
		MOV	OVERLAY_NUMBER,EAX
		CALL	DEFINE_SEGMENT_GINDEX
		CALL	YYLEX
		JNZ	L3$			;NOT A RESERVED WORD, MUST BE ANOTHER SEGMENT
		CMP	ECX,OVL_ID
		JNZ	L2$
		SETT	FORCE_DOS_MODE
		CALL	GETNST
		CMP	AL,':'
		JNZ	L8$
		CALL	GET_NUMBER
		MOV	OVERLAY_NUMBER,EAX
		JMP	L3$

L99$:
		CALL	RESTORE
		JMP	L999$

L8$:
		MOV	AL,DEF_SEGMENTS_ERR
		JMP	SYN_ERROR_FINAL

L2$:
		CALL	RESTORE
L3$:
		MOV	ESI,DEF_SEGMENT_GINDEX
		CONVERT	ESI,ESI,SEGMENT_GARRAY
		ASSUME	ESI:PTR SEGMENT_STRUCT

		MOV	AL,[ESI]._SEG_ORDER_FLAG
		MOV	ECX,OVERLAY_NUMBER
		TEST	AL,MASK DEF_OS2_DEFINED
		JNZ	L8$
		OR	AL,MASK DEF_OS2_DEFINED
if	any_overlays
		MOV	[ESI]._SEG_SECTION_GINDEX,ECX
endif
		MOV	[ESI]._SEG_ORDER_FLAG,AL
		XOR	EAX,EAX
		MOV	SPECIFIC_MASK,EAX	;ALLOW ANY NOW
		MOV	SEG_OS2_FLAGS,EAX	;
		DEC	EAX
		MOV	SPECIFIC_FLAGS,EAX	;ALL DEFAULTS VALID
L4$:
		CALL	YYLEX			;END OF ITEMS?
		JNZ	L5$
		CALL	YYLEX_SEGSTUFF		;PARSE SEGMENT PARAMETERS DX=0, CX=2, BX=1, AX=3
		JNZ	L7$
		TEST	AL,001B 		;LEGAL FOR OTHER SEGMENTS?
		JZ	L8$
		TEST	SPECIFIC_MASK,EDX	;ALREADY DECIDED?
		JZ	L6$
		;
		;ALREADY SET, SAME?
		;
		PUSHM	EDX,ECX
		AND	ECX,EDX
		AND	EDX,SEG_OS2_FLAGS
		CMP	ECX,EDX
		POPM	ECX,EDX
		JNZ	L8$
L6$:
		OR	SPECIFIC_MASK,EDX
		MOV	EAX,EBX			;THESE NO LONGER VALID FROM DEFAULT, WE ARE CLEARING THEM
		NOT	EBX
		OR	EAX,EDX			;THESE NO LONGER VALID FROM, WE ARE DEFINING THEM
		OR	EAX,ECX			;THESE NO LONGER VALID, WE ARE SETTING THEM
		NOT	EAX
		AND	SPECIFIC_FLAGS,EAX

		MOV	EAX,SEG_OS2_FLAGS
		AND	EAX,EBX
		OR	EAX,ECX
		MOV	SEG_OS2_FLAGS,EAX
		JMP	L4$

L5$:
		CALL	FIX_DEF_SEGMENT
		JMP	L1$

L7$:
		CALL	YYLEX_NEWSEGSTUFF
		JNZ	L79$
		OR	SEG_OS2_FLAGS,EAX
		JMP	L4$

L79$:
		CALL	RESTORE
L998$:
		CALL	FIX_DEF_SEGMENT
L999$:
		RET

DEF_SEGMENTS	ENDP


YYLEX_NEWSEGSTUFF	PROC	NEAR
		;
		;MIGHT BE READ, WRITE, OR EXECUTE
		;
		CMP	ECX,EXECUTE_ID
		MOV	EAX,MASK SR_EXECUTE
		JZ	L5$
		CMP	ECX,READ_ID
		MOV	EAX,MASK SR_READ
		JZ	L5$
		CMP	ECX,WRITE_ID
		MOV	EAX,MASK SR_WRITE
L5$:
		RET

YYLEX_NEWSEGSTUFF	ENDP


DEFINE_SEGMENT_GINDEX	PROC	NEAR
		;
		;GET	SEGMENT_NAME [CLASS CLASS_NAME]
		;
		CALL	INIT_LOCAL_STORAGE
		CALL	GET_SEGMENT		;GET SEGMENT NAME
		CALL	YYLEX			;SEE IF CLASS NAME
		JNZ	L5$
		CMP	ECX,CLASS_ID
		JNZ	L4$
		CALL	GET_CLASS
		JMP	L6$

L4$:
		CALL	RESTORE
L5$:
		MOV	EAX,OFF CODE_TPTR
		CALL	MOVE_CLASS_NAME
L6$:
		MOV	SEG_COMBINE,SC_UNDEFINED
		MOV	SEG32_FLAGS,0		;DON'T SPECIFY USE16/USE32 FOR NOW
		CALL	GET_SEGMENT_ENTRY

		MOV	DEF_SEGMENT_GINDEX,EAX
		CALL	RELEASE_LOCAL_STORAGE
		RET

DEFINE_SEGMENT_GINDEX	ENDP


FIX_DEF_SEGMENT PROC	NEAR
		;
		;FIX FLAGS FOR SEGMENT
		;
		MOV	ECX,DEF_SEGMENT_GINDEX
		CONVERT	ECX,ECX,SEGMENT_GARRAY
		ASSUME	ECX:PTR SEGMENT_STRUCT
		;
		;MAKE CODE VS. DATA DETERMINATION
		;
		TEST	SPECIFIC_MASK,1 	;WAS CODE VS DATA SPECIFIED?
		JZ	L5$			;NOPE, USE CLASS_IS_CODE FLAG
		;
		;MAKE CLASS_IS_CODE MATCH SPECIFIED TYPE
		;
		AND	[ECX]._SEG_TYPE,NOT MASK SEG_CLASS_IS_CODE	;ASSUME DATA
		TEST	SEG_OS2_FLAGS,1		;DATA?
		JNZ	L5$
		OR	[ECX]._SEG_TYPE,MASK SEG_CLASS_IS_CODE
L5$:
		;
		;NOW USE WHATEVER DEFAULTS ARE LEFT FROM DEFAULT TYPE
		;
		MOV	EAX,CODE_DEFAULTS
		TEST	[ECX]._SEG_TYPE,MASK SEG_CLASS_IS_CODE
		JNZ	L6$
		MOV	EAX,DATA_DEFAULTS
L6$:
		AND	EAX,SPECIFIC_FLAGS	;DEFAULTS WE CAN KEEP
		OR	EAX,SEG_OS2_FLAGS
		MOV	[ECX]._SEG_OS2_FLAGS,EAX
		RET

FIX_DEF_SEGMENT ENDP


YYLEX_SEGSTUFF	PROC	NEAR
		;
		;BX IS TOKEN ID, IF VALID SEGMENT PARAM, LOAD REGS WITH
		;PROPER VALUES
		;
		SUB	ECX,CONFORMING_ID
		CMP	ECX,SINGLE_ID-CONFORMING_ID
		JA	L9$
		CMP	CL,IOPL_ID-CONFORMING_ID
		JZ	L1$
		CMP	CL,MOVABLE_ID-CONFORMING_ID
		JZ	L2$
		CMP	CL,DISCARDABLE_ID-CONFORMING_ID
		JZ	L2$
L5$:
		MOVZX	EDX,SEG_STUFF_TABLE[ECX*8]
		MOVZX	EBX,SEG_STUFF_TABLE[ECX*8+2]
		MOVZX	EAX,SEG_STUFF_TABLE[ECX*8+6]
		MOVZX	ECX,SEG_STUFF_TABLE[ECX*8+4]
		CMP	EAX,EAX
		RET

L1$:
		SETT	IOPL_USED
		JMP	L5$

L2$:
		SETT	MOVABLE_USED
		JMP	L5$

L9$:
		ADD	ECX,CONFORMING_ID
		TEST	ESP,ESP
		RET

		ALIGN	4

SEG_STUFF_TABLE LABEL	WORD
;
;	000 - code, data, other
;
;	BIT MASK, BITS TO CLEAR, BITS TO SET, WHO IS LEGAL
		;
DW	MASK SR_CONF,MASK SR_CONF,MASK SR_CONF,101B		;CONFORMING
;
;DISCARDABLE IMPLIES MOVABLE
;
DW	MASK SR_DISCARD,0,MASK SR_DISCARD+MASK SR_MOVABLE,111B	;DISCARDABLE
DW	MASK SR_EO_RO+1,1,MASK SR_EO_RO,101B			;EXECUTEONLY
DW	MASK SR_EO_RO+1,MASK SR_EO_RO+1,0,101B			;EXECUTEREAD
;
;FIXED IMPLIES NONDISCARDABLE
;
DW	MASK SR_MOVABLE,MASK SR_MOVABLE+MASK SR_DISCARD,0,111B	;FIXED
;
;MS-LINK ALSO SETS SR_MOVABLE...
;
DW	MASK SR_DPL,MASK SR_DPL,(1 SHL SR_DPL),111B		;IOPL
DW	MASK SR_PRELOAD,MASK SR_PRELOAD,0,111B			;LOADONCALL
DW	MASK SR_MOVABLE,0,MASK SR_MOVABLE,111B			;MOVABLE
;
;MULTIPLE IMPLIES NONSHARED
;
DW	MASK SR_MULTIPLE,MASK SR_MULTIPLE+MASK SR_SHARED,2 SHL SR_MULTIPLE,010B;MULTIPLE
DW	MASK SR_DPL,MASK SR_DPL,0 SHL SR_DPL,111B		;NOIOPL
DW	MASK SR_CONF,MASK SR_CONF,0,101B			;NONCONFORMING
DW	MASK SR_DISCARD,MASK SR_DISCARD,0,111B			;NONDISCARD
DW	MASK SR_MULTIPLE,MASK SR_MULTIPLE,0,010B		;NONE
DW	MASK SR_SHARED,MASK SR_SHARED,0,111B			;NONSHARED
DW	MASK SR_PRELOAD,0,MASK SR_PRELOAD,111B			;PRELOAD
DW	MASK SR_EO_RO+1,0,MASK SR_EO_RO+1,011B			;READONLY
DW	MASK SR_EO_RO+1,MASK SR_EO_RO,0+1,011B			;READWRITE
DW	MASK SR_SHARED,0,MASK SR_SHARED,111B			;SHARED
;
;SINGLE IMPLIES SHARED
;
DW	MASK SR_MULTIPLE,MASK SR_MULTIPLE,(1 SHL SR_MULTIPLE)+MASK SR_SHARED,010B;SINGLE


YYLEX_SEGSTUFF	ENDP


DEF_STACKSIZE	PROC	NEAR
		;
		;JUST LIKE /STACK IN LNKINIT...
		;
		CALL	GET_NUMBER
		CALL	SET_STACK_1
		;
		;MAYBE A COMMIT SIZE...
		;
		CALL	GETNST
		CMP	AL,','
		JNZ	L71$
		CALL	GETNST			;BORLAND GOOFY SYNTAX
L71$:
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,9
		JA	L78$
		CALL	GET_NUMBER
if	fg_pe
		MOV	PEXEHEADER._PEXE_STACK_COMMIT,EAX
endif
L78$:

		RET

DEF_STACKSIZE	ENDP


DEF_HEAPSIZE	PROC	NEAR
		;
		;JUST LIKE /STACK IN LNKINIT...
		;
		CALL	YYLEX
		JNZ	L5$
		CMP	ECX,MAXVAL_ID
		MOV	EAX,HEAP_SIZE
		JNZ	L9$
		OR	EAX,EAX
		JNZ	L9$
		SETT	HEAP_MAXVAL
		RET

L5$:
		CALL	GET_NUMBER
		XCHG	HEAP_SIZE,EAX
		SETT	HEAP_SIZE_FLAG
		OR	EAX,EAX
		JZ	L6$
L51$:
		CMP	HEAP_SIZE,EAX
		JNZ	L9$
L6$:
		BITT	HEAP_MAXVAL
		JNZ	L9$
		;
		;MAYBE A COMMIT SIZE...
		;
		CALL	GETNST
		CMP	AL,','
		JNZ	L71$
		CALL	GETNST			;BORLAND GOOFY SYNTAX
L71$:
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,9
		JA	L78$
		CALL	GET_NUMBER
if	fg_pe
		MOV	PEXEHEADER._PEXE_HEAP_COMMIT,EAX
endif
L78$:
		RET

L9$:
		MOV	AL,DUP_HEAP_ERR
		CALL	SYN_ERROR_RET
		RET

DEF_HEAPSIZE	ENDP


DEF_EXETYPE	PROC	NEAR
		;
		;SELECT OUTPUT TYPE
		;
		CALL	YYLEX		;END OF ITEMS?
		JNZ	L8$
		SUB	ECX,OS2_ID
		CMP	ECX,DOSX_ID-OS2_ID
		JA	L9$
		INC	ECX
		;
		;1 OS2
		;2 WINDOWS
		;3 DOS4 - SEGMENTED
		;4 UNKNOWN
		;5 DOS FLAT EXECUTABLE
		;6 NT PE EXECUTABLE
		;7 DOSX MZ SORT-OF
		;
		PUSH	ECX
		CMP	CL,2
		JNZ	L6$
		;
		;LOOK FOR OPTIONAL WINDOWS MINIMUM RELEASE #
		;
		BITT	WINVER_SELECTED
		JNZ	L1$
		MOV	NEXEHEADER._NEXE_WINVER_INT,3
		MOV	NEXEHEADER._NEXE_WINVER_FRAC,10
L1$:
		CALL	GETNST
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,10
		JB	L3$
		CMP	AL,"'"-30H
		JNZ	L6$
		CALL	GET_STRING
		MOV	EAX,DPTR SYMBOL_TEXT
		MOV	NEXEHEADER._NEXE_SIGN,AX
		JMP	L6$

L9$:
		CALL	RESTORE		;RE-PARSE THAT ITEM...
		RET

L3$:
		CALL	GET_NUM_DOT_NUM_WINDOWS
		BITT	WINVER_SELECTED
		JNZ	L6$
		MOV	NEXEHEADER._NEXE_WINVER_INT,AL
		MOV	NEXEHEADER._NEXE_WINVER_FRAC,DL
		SETT	WINVER_SELECTED
		JMP	L6$

L7$:
L8$:
		MOV	AL,DEF_EXETYPE_ERR
		CALL	SYN_ERROR_RET
		RET

L6$:
		POP	EAX
		XCHG	EXETYPE_FLAG,AL
		OR	AL,AL
		JZ	L69$
		CMP	EXETYPE_FLAG,AL
		JNZ	L8$
L69$:
		RET

DEF_EXETYPE	ENDP


GET_NUM_DOT_NUM	PROC
		;
		;GET A NUMBER IN AX, WITH FRACTION IN DL
		;NN[.NN]
		;
		CALL	GET_NUMBER

		PUSH	EAX
		CALL	GETNST

		CMP	AL,'.'
		JNZ	L5$

		CALL	GETNST

		DEC	INPTR1
		SUB	AL,30H

		CMP	AL,10
		JAE	L6$
L4$:
		CALL	GET_NUMBER

		MOV	EDX,EAX
		POP	EAX

		RET

L5$:
		DEC	INPTR1
L6$:
		XOR	EDX,EDX		;ASSUME FRACTION PART IS 0
		POP	EAX

		RET

GET_NUM_DOT_NUM	ENDP


GET_NUM_DOT_NUM_WINDOWS	PROC
		;
		;GET A NUMBER IN EAX, WITH FRACTION IN EDX
		;NN[.NN]
		;
		CALL	GET_NUMBER
		PUSH	EAX
		XOR	EDX,EDX		;ASSUME FRACTION PART IS 0
		CALL	GETNST
		CMP	AL,'.'
		JNZ	L5$
		CALL	GETNST
		DEC	INPTR1
		INC	EDX		;DL == 1
		SUB	AL,30H
		JZ	L4$
		DEC	EDX		;DL == 0
		CMP	AL,10
		JAE	L6$
		MOV	DL,10
L4$:
		PUSH	EDX
		CALL	GET_NUMBER
		POP	EDX
		;
		;
		MOV	DH,1
		CMP	EAX,10
		JB	L49$
		MOV	DH,10
L49$:
		MUL	DL
		DIV	DH
		MOV	DH,0
		MOV	DL,AL
		POP	EAX
		RET

L5$:
		DEC	INPTR1
L6$:
		POP	EAX
		RET

GET_NUM_DOT_NUM_WINDOWS	ENDP


DEF_RC		PROC	NEAR
		;
		;PERFORM RC FUNCTIONS
		;
;   -e	*Create a driver which uses EMS memory		(SET APP386 BIT)
;   -k	*Keep segments in .DEF file order (do not sort segments for fast load)
;   -l	*Create an application that uses LIM 3.2 EMS	(SET APP86 BIT)
;   -m	*Set Multiple Instance flag			(SET APP286 BIT)
;   -p	*Create a Private Library			(SET APP?? BIT)
;   -t	*Create a protected mode only application	(SET APPPROT BIT)
;   -30	WINDOWS 3.0
;   -31 WINDOWS 3.1
		;
		;RC [FLAGS] 'FILENAME'
		;
		BITT	RC_SUPPLIED
		JNZ	L1$
		SETT	RC_REORDER
		OR	FLAG_0C,MASK APPWINFLAGS	;YES, RESOURCES APPLIED, EXE OK
L1$:
		CALL	GETNST
		CMP	AL,'-'
		JZ	L10$
		CMP	AL,'/'
		JZ	L10$
L2$:
		DEC	INPTR1
		CALL	YYLEX
		JZ	L7$
		MOV	EAX,OFF RCSTUFF
		CALL	YYLEX_FILENAME
		SETT	RC_SUPPLIED
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_RCS
		JMP	L1$

L7$:
		CALL	RESTORE
		RET



L10$:
		CALL	GETNST
		CMP	AL,'a'
		JC	L11$
		CMP	AL,'z'
		JA	L11$
		SUB	AL,20H
L11$:
		MOV	ECX,MASK APP386			;DRIVER USES EMS
		CMP	AL,'E'
		JZ	L19$
		MOV	ECX,MASK APP86			;APP USES EMS
		CMP	AL,'L'
		JZ	L19$
		MOV	ECX,MASK APP286			;MULTIPLE INSTANCE (MORE EMS JUNK)
		CMP	AL,'M'
		JZ	L19$
		MOV	ECX,MASK APP??			;PRIVATE LIBRARY
		CMP	AL,'P'
		JZ	L19$
		CMP	AL,'T'				;PROTMODE ONLY
		JZ	L16$
		CMP	AL,'K'
		JZ	L17$
		CMP	AL,'3'
		JNZ	L9$
		CALL	GETNST
		SUB	AL,'0'
		CMP	AL,1
		JA	L9$
		MOV	AH,10
		MUL	AH
		BITT	WINVER_SELECTED
		JNZ	L1A
		MOV	NEXEHEADER._NEXE_WINVER_INT,3
		MOV	NEXEHEADER._NEXE_WINVER_FRAC,AL
		SETT	WINVER_SELECTED
L1A:
		JMP	L1$

L9$:
		MOV	ESI,EDX
		JMP	SYN_ERROR

L16$:
		CALL	DEF_PROTMODE
		JMP	L1$

L17$:
		RESS	RC_REORDER
		JMP	L1$

L19$:
		OR	FLAG_0C,ECX
		JMP	L1$

DEF_RC		ENDP


DEF_NEWFILES	PROC	NEAR
		;
		;
		;
		SETT	LONGNAMES_FLAG
		RET

DEF_NEWFILES	ENDP


DEF_NOEMUFLOAT	PROC	NEAR
		;
		;
		;
		SETT	NOEMUFLOAT_FLAG
		RET

DEF_NOEMUFLOAT	ENDP


DEF_FIXDS	PROC	NEAR
		;
		;
		;
		SETT	FIXDS_FLAG
		RET

DEF_FIXDS	ENDP


RC_PROTMODE	PROC

		CALL	DEF_PROTMODE
		RET

RC_PROTMODE	ENDP


DEF_PROTMODE	PROC	NEAR
		;
		;
		;
		BITT	PROTMODE
		JNZ	L9$
		TEST	FLAG_0C_MASK,MASK APPPROT
		JZ	L1$
		MOV	AL,PROT_REAL_ERR
		CALL	SYN_ERROR_RET
L1$:
		SETT	PROTMODE
		OR	FLAG_0C_MASK,MASK APPPROT
		OR	FLAG_0C,MASK APPPROT
L9$:
		RET

DEF_PROTMODE	ENDP


DEF_REALMODE	PROC	NEAR
		;
		;
		;
		BITT	REALMODE
		JNZ	L9$
		TEST	FLAG_0C_MASK,MASK APPPROT
		JZ	L1$
		MOV	AL,PROT_REAL_ERR
		CALL	SYN_ERROR_RET
L1$:
		SETT	REALMODE
		OR	FLAG_0C_MASK,MASK APPPROT
		AND	FLAG_0C,NOT MASK APPPROT
L9$:
		RET

DEF_REALMODE	ENDP


DEF_SUBSYSTEM	PROC	NEAR
		;
		;UNKNOWN | NATIVE | WINDOWS | CONSOLE | OS2 | POSIX
		;
		CALL	YYLEX
		JNZ	L9$
		XOR	EAX,EAX
		CMP	ECX,UNKNOWN_ID
		JZ	L7$
		INC	EAX
		CMP	ECX,NATIVE_ID
		JZ	L7$
		INC	EAX		;2
		CMP	ECX,WINDOWS_ID
		JZ	L7$
		INC	EAX		;3
		CMP	ECX,CONSOLE_ID
		JZ	L7$
		MOV	AL,5
		CMP	ECX,OS2_ID
		JZ	L7$
		CMP	ECX,POSIX_ID
		JNZ	L8$
		MOV	AL,7
L7$:
		CALL	SET_SUBSYSTEM

		JNZ	L9$
		;
		;MAYBE A SUBSYSTEM VERSION NUMBER...
		;
		CALL	GETNST
		CMP	AL,','
		JNZ	L71$
		CALL	GETNST			;BORLAND GOOFY SYNTAX
L71$:
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,9
		JA	L99$

		CALL	GET_NUM_DOT_NUM

		MOV	ECX,EDX
		CALL	SET_SUBSYS_VERSION

		JNZ	L9$

		RET

L8$:
		CALL	RESTORE
L9$:
		MOV	AL,SUBSYSTEM_ERR
		CALL	SYN_ERROR_RET
L99$:
		RET

DEF_SUBSYSTEM	ENDP

SET_SUBSYSTEM	PROC

if	fg_pe
		SETT	PE_SUBSYSTEM_DEFINED

		XCHG	PEXEHEADER._PEXE_SUBSYSTEM,AX

		TEST	AX,AX
		JZ	L71$

		CMP	PEXEHEADER._PEXE_SUBSYSTEM,AX
L71$:

endif
		RET

SET_SUBSYSTEM	ENDP


SET_SUBSYS_VERSION	PROC

		SETT	PE_SUBSYS_VERSION_DEFINED

		XCHG	PEXEHEADER._PEXE_SUBSYS_MAJOR,AX
		XCHG	PEXEHEADER._PEXE_SUBSYS_MINOR,CX

		MOV	EDX,EAX

		OR	DX,CX
		JZ	L9$

		CMP	PEXEHEADER._PEXE_SUBSYS_MAJOR,AX
		JNZ	L9$

		CMP	PEXEHEADER._PEXE_SUBSYS_MINOR,CX
L9$:
		RET

SET_SUBSYS_VERSION	ENDP


DEF_IMPORTS	PROC	NEAR
		;
		;[INTERNALNAME=]MODULENAME.ENTRY
		;
if	fg_segm OR fg_pe
		RESS	IMP_BY_NAME
		XOR	EAX,EAX
		MOV	IMPEXP_INTNAM+4,EAX	;LENGTH OF INTERNAL NAME
		MOV	IMPEXP_NAM+4,EAX 	;FOR FLUSH EXPORTS...
		MOV	IMP_ORDNUM,EAX		;FOR HINT...
		CALL	YYLEX
		JZ	L99$
		CALL	GET_SYMBOL		;INTO SYMBOL_LENGTH, NO XLAT, NO HASH

		CALL	GETNST			;MUST BE = OR .
		CMP	AL,'='
		JNZ	L1$
		MOV	EAX,OFF IMPEXP_INTNAM
		CALL	MOVE_SYMBOL_TO_EAX
		CALL	YYLEX			;CANNOT BE RESERVED WORD (LIKE EOF)
		JZ	L8$
		CALL	GET_SYMBOL		;INTO SYMBOL_LENGTH, NO XLAT, NO HASH
		CALL	GETNST
L1$:
		CMP	AL,'.'
		JNZ	L8$			;FAILURE...
		MOV	EAX,OFF IMPEXP_MOD
		CALL	MOVE_SYMBOL_TO_EAX
		CALL	GETNST
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,10
		JC	L5$			;JUMP IF NUMERIC
		;
		CALL	GET_SYMBOL		;INTO SYMBOL_LENGTH, NO XLAT, NO HASH
		MOV	EAX,OFF IMPEXP_NAM
		CALL	MOVE_SYMBOL_TO_EAX
		SETT	IMP_BY_NAME
L6$:
		CALL	DEFINE_IMPORT	;
		JMP	DEF_IMPORTS

L99$:
		CALL	RESTORE
		RET

L5$:
		CALL	GET_NUMBER
		TEST	EAX,EAX
		MOV	IMP_ORDNUM,EAX
		JZ	L8$
		CMP	DPTR IMPEXP_INTNAM+4,0	;INTERNAL NAME MUST APPEAR
		JNZ	L6$
L8$:
endif
		MOV	AL,DEF_IMPORTS_ERR
		CALL	SYN_ERROR_RET
		RET

DEF_IMPORTS	ENDP


MOVE_SYMBOL_TO_EAX	PROC	NEAR
		;
		;
		;
		PUSH	EDI
		MOV	EDI,EAX
		PUSH	ESI
		MOV	ECX,SYMBOL_LENGTH
		MOV	[EDI],EDX	;SAVE HASH VALUE
		MOV	4[EDI],ECX
		SHR	ECX,2
		MOV	ESI,OFF SYMBOL_TEXT
		ADD	ECX,2		;XTRA 4 BYTES FOR TRAILING 0
		ADD	EDI,8
		REP	MOVSD
		POPM	ESI,EDI
		RET

MOVE_SYMBOL_TO_EAX	ENDP


DEF_EXPORTS	PROC	NEAR
		;
		;DEFINE EXPORTED SYMBOLS AND ROUTINES WITH IOPL
		;
		;ENTRYNAME[=INTERNALNAME][@ORD[RESIDENTNAME | NONAME]][PWORDS][NODATA][PRIVATE][BYNAME][CONSTANT][DATA]
		;
if	fg_segm OR fg_pe
		CALL	YYLEX
		JZ	L99$		;RESERVED WORD, GET OUT
L1$:
		XOR	EAX,EAX
		MOV	IMPEXP_NAM+4,EAX
		MOV	IMPEXP_INTNAM+4,EAX
		MOV	EXP_FLAGS,AL
		MOV	EXP_FLAGS_EXT,AL
		MOV	EXP_PWORDS,AL
		MOV	EXP_ORDNUM,EAX

		CALL	GET_SYMBOL	;INTO SYMBOL_LENGTH, NO XLAT, NO HASH
		TEST	EAX,EAX
		JZ	L98$
		MOV	EAX,OFF IMPEXP_NAM
		CALL	MOVE_SYMBOL_TO_EAX
L15$:
		CALL	YYLEX		;SOMETHING I KNOW?
		JZ	L5$
		CALL	GETNST
		CMP	AL,'='
		JZ	L2$
		CMP	AL,'@'
		JZ	L3$
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,10
		JB	L4$
L18$:
		CALL	DEFINE_EXPORT
		JMP	L1$

L17$:
		DEC	EDX
		MOV	INPTR1,EDX
		JMP	L18$

L99$:
		CALL	RESTORE
L98$:
		RET

L4$:
		;
		;PWORDS
		;
		CALL	GET_NUMBER
		CMP	EAX,31
		JA	L8$
		MOV	CL,EXP_PWORDS
		MOV	EXP_PWORDS,AL
		TEST	CL,CL
		JNZ	L8$
		JMP	L15$

L2$:
		;
		;INTERNAL NAME
		;
		CMP	DPTR IMPEXP_INTNAM+4,0	;SEE IF ALREADY DECLARED
		JNZ	L81$
		CALL	GET_SYMBOL		;INTO SYMBOL_LENGTH, NO XLAT, NO HASH
		MOV	EAX,OFF IMPEXP_INTNAM
		CALL	MOVE_SYMBOL_TO_EAX

		MOV	AL,MASK ENT_USE_EXTNAM
		JMP	L6$

L3$:
		;
		;ORDINAL?
		;
		PUSH	INPTR1			;ONE PAST @
;		PUSH	ESI			;IF NOT A VALID DIGIT, ASSUME ITS
		CALL	GETNST			;ANOTHER SYMBOL STARTING WITH @
;		POP	ESI
		POP	EDX
		SUB	AL,30H
		DEC	INPTR1
		CMP	AL,10
		JAE	L17$
		CALL	GET_NUMBER
		TEST	EAX,EAX
		JZ	L8$
		MOV	ECX,EXP_ORDNUM
		MOV	EXP_ORDNUM,EAX
		OR	EXP_FLAGS,MASK ENT_ORD_SPECIFIED
		TEST	ECX,ECX
		JZ	L15$
L8$:
L81$:
		MOV	AL,DEF_EXPORTS_ERR
		CALL	SYN_ERROR_RET
		RET


L5$:
		;
		;RESERVED WORD...
		;
		MOV	AL,MASK ENT_RESIDENTNAME
		CMP	ECX,RESIDENTNAME_ID
		JZ	L6$
		CMP	ECX,NODATA_ID
		MOV	AL,MASK ENT_NODATA
		JZ	L6$
		CMP	ECX,NONAME_ID
		JZ	L61$
		CMP	ECX,BYNAME_ID
		MOV	AL,MASK ENT_BYNAME
		JZ	L6$
		CMP	ECX,PRIVATE_ID		;SKIP THIS, ITS FOR IMPLIB
		MOV	AL,MASK ENT_PRIVATE
		JZ	L6$
		CMP	ECX,CONSTANT_ID
		JZ	L15$
		CMP	ECX,DATA_ID
		JZ	L63$
		CALL	RESTORE
		CALL	DEFINE_EXPORT
		RET

L61$:
		MOV	AL,MASK ENT_NONAME
L6$:
		OR	EXP_FLAGS,AL
L62$:
		JMP	L15$
L63$:
		OR	EXP_FLAGS_EXT,MASK ENT_EXT_DATA
		JMP	L15$

else

		JMP	SYN_ERROR
endif

DEF_EXPORTS	ENDP


DEF_FUNCTIONS	PROC	NEAR
		;
		;FUNCTIONS	[:{SEGMENT | OVL NUMBER}] FUNCTION NAMES
		;
		;THIS SPECIFIES A DESIRED FUNCTION ORDER AND POSSIBLY AN ASSIGNED OVERLAY OR SEGMENT NAME
		;
		XOR	EAX,EAX
		MOV	DEF_SEGMENT_GINDEX,EAX
		CALL	GETNST
		CMP	AL,':'
		JNZ	L2$
		CALL	GETNST
		SUB	AL,'0'
		DEC	INPTR1
		CMP	AL,10
		JA	L1$
		;
		;OVERLAY SECTION #...
		;
		CALL	GET_NUMBER16
		OR	EAX,8000000H
		MOV	DEF_SEGMENT_GINDEX,EAX
		SETT	FORCE_DOS_MODE
		JMP	L3$

L1$:
		;
		;DEFINE SEGMENT TO STICK THESE GUYS INTO
		;
		CALL	DEFINE_SEGMENT_GINDEX
		JMP	L3$

L2$:
		DEC	INPTR1
L3$:
		;
		;HERE WE START STORING STUFF, LOOP ORDERING COMDATS...
		;
		CALL	YYLEX
		JZ	L9$
		CALL	YYLEX_SYMBOL		;PARSE SYMBOL
		CALL	FAR_INSTALL		;INSTALL IN SYMBOL TABLE

		PUSH	EAX			;SAVE JUST INDEX

		MOV	EAX,12
		P1ONLY_POOL_ALLOC		;RETURNS EAX
		MOV	ESI,LAST_COMDAT_SUGGESTED
		ASSUME	ESI:PTR DWORD
		MOV	EBX,EAX
		TEST	ESI,ESI
		JZ	L7$
		MOV	[ESI],EBX
L4$:
		XOR	EAX,EAX
		MOV	LAST_COMDAT_SUGGESTED,EBX
		MOV	[EBX],EAX
		POP	ECX
		MOV	EAX,DEF_SEGMENT_GINDEX
		MOV	[EBX+4],ECX
		MOV	[EBX+8],EAX
		JMP	L3$

L9$:
		CALL	RESTORE
		RET

L7$:
		MOV	FIRST_COMDAT_SUGGESTED,EBX
		JMP	L4$

DEF_FUNCTIONS	ENDP


DEF_OLD 	PROC	NEAR
		;
		;GET NAME OF OS2-EXE TO USE FOR ENTRY POINT ORDS
		;
if	fg_segm OR fg_pe
		MOV	EAX,OFF STUBSTUFF
		CALL	YYLEX_FILENAME
		BITT	OLD_SUPPLIED
		JNZ	L9$
		SETT	OLD_SUPPLIED
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_OLD
		RET

L9$:
endif
		MOV	AL,DUP_OLD_ERR
		CALL	SYN_ERROR_RET
		RET

DEF_OLD 	ENDP


DEF_STUB	PROC	NEAR
		;
		;GET NAME OF REAL-MODE EXE FILE TO USE AS 'STUB'
		;OR	NONE
		;
if	fg_segm OR fg_pe
		CALL	YYLEX
		JZ	L1$
		MOV	EAX,OFF STUBSTUFF
		CALL	YYLEX_FILENAME	;SUPPORT NO, SINGLE, AND DOUBLE QUOTES
		BITT	STUB_SUPPLIED
		JNZ	L9$
		BITT	STUB_NONE
		JNZ	L9$
		SETT	STUB_SUPPLIED
		;
		;PUT IN ADD_LIST, AND WAKE UP PROPER OPENNER...
		;
		MOV	EAX,OFF FILNAM
		CALL	HANDLE_STUB
		RET

L1$:
		CMP	ECX,NONE_ID
		JNZ	L9$
		BITT	STUB_SUPPLIED
		JNZ	L9$
		SETT	STUB_NONE
		RET

L9$:
endif
		MOV	AL,DUP_STUB_ERR
		CALL	SYN_ERROR_RET
		RET

DEF_STUB	ENDP


DEF_VERSION	PROC	NEAR
		;
		;
		;
		CALL	GET_NUM_DOT_NUM
if	fg_pe
		MOV	PEXEHEADER._PEXE_USER_MAJOR,AX
		MOV	PEXEHEADER._PEXE_USER_MINOR,DX
endif
		RET

DEF_VERSION	ENDP


GET_STRING	PROC	NEAR
		;
		;LOOKING FOR 'ASDFA"SDFASDF'	OR	"ASDF'ASDF"
		;
		PUSHM	EDI,ESI
		CALL	GETNST
		CMP	AL,''''
		JZ	L0$
		CMP	AL,'"'
		JNZ	L9$
L0$:
		MOV	DL,AL
		MOV	ESI,INPTR1
		ASSUME	ESI:PTR BYTE

		MOV	EDI,OFF SYMBOL_TEXT
		MOV	ECX,SYMBOL_TEXT_SIZE	;MAX STRING LENGTH
L1$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,DL
		JZ	L5$
		CMP	AL,20H
		JB	L6$
L2$:
		MOV	[EDI],AL
		INC	EDI
		DEC	ECX
		JNZ	L1$
L9$:
		MOV	AL,DEF_STRING_ERR
		JMP	SYN_ERROR_FINAL

L6$:
		CMP	AL,0DH
		JZ	L9$
		CMP	AL,0AH
		JZ	L9$
		CMP	AL,1AH
		JNZ	L2$
		JMP	L9$

L5$:
		MOV	AL,[ESI]
		INC	ESI
		CMP	AL,DL
		JZ	L2$
		DEC	ESI
		SUB	EDI,OFF SYMBOL_TEXT
		MOV	INPTR1,ESI
		POP	ESI
		MOV	SYMBOL_LENGTH,EDI
		POP	EDI
		RET

GET_STRING	ENDP


GET_CLASS	PROC	NEAR
		;
		;MAYBE ' OR " ENCLOSED
		;
		AND	FNTBL+'.',NOT MASK SYMTBL_ILLEGAL	;. ILLEGAL IN SYMBOLS
		CALL	GET_NAME			;PARSE AND STORE IN SYMBOL_TEXT
		OR	FNTBL+'.',MASK SYMTBL_ILLEGAL	;. ILLEGAL IN SYMBOLS
		LEA	EAX,SYMBOL_TPTR
MOVE_CLASS_NAME::
		CALL	MAKE_TPTR_LINDEX
		MOV	CLASS_NAME_LINDEX,EAX
		RET

GET_CLASS	ENDP


GET_SEGMENT	PROC	NEAR
		;
		;MAYBE ' OR " ENCLOSED
		;
		AND	FNTBL+'.',NOT MASK SYMTBL_ILLEGAL	;. ILLEGAL IN SYMBOLS
		CALL	GET_NAME			;PARSE AND STORE IN SYMBOL_TEXT
		OR	FNTBL+'.',MASK SYMTBL_ILLEGAL	;. ILLEGAL IN SYMBOLS
		LEA	EAX,SYMBOL_TPTR
		CALL	MAKE_TPTR_LINDEX
		MOV	SEG_NAME_LINDEX,EAX
		RET

GET_SEGMENT	ENDP


GET_NAME	EQU	(YYLEX_SYMBOL)


YY_MODNAME	PROC	NEAR
		;
		;ALLOW ., ETC.  UPPERCASE THIS NAME
		;
		PUSHM	EDI,ESI

		PUSH	EAX
		CALL	YY_FILENAME			;PUT IN FILNAM

		MOV	EAX,OFF FILNAM
		ASSUME	EAX:PTR NFN_STRUCT

		push	EAX
		call	_parse_filename
		add	ESP,4

		MOV	ECX,[EAX].NFN_EXTLEN		;ADD EXTENSION IF NOT THERE
		POP	ESI
		ASSUME	ESI:NOTHING

		TEST	ECX,ECX
		JNZ	L5$

		MOV	ECX,[EAX].NFN_TOTAL_LENGTH
		MOV	EDX,[ESI]			;EXTENSION

		MOV	DPTR [ECX+EAX].NFN_TEXT,EDX
		ADD	ECX,4

		MOV	[EAX].NFN_TOTAL_LENGTH,ECX
L5$:
		LEA	ESI,[EAX].NFN_TEXT

		MOV	EAX,[EAX].NFN_TOTAL_LENGTH
		MOV	EDI,OFF SYMBOL_TEXT

		TEST	EAX,EAX
		JZ	L9$

		MOV	SYMBOL_LENGTH,EAX
		CALL	OPTI_MOVE_UPPER_IGNORE

		POPM	ESI,EDI

		OR	EAX,EAX

		RET

L9$:
		CMP	ESP,-1

		POPM	ESI,EDI

		RET

YY_MODNAME	ENDP


		.CONST


		ALIGN	4

YYLEX_TABLE	DD	YY_A,YY_B,YY_C,YY_D		;ABCD
		DD	YY_E,YY_F,YY_FAIL,YY_H		;EFGH
		DD	YY_I,YY_FAIL,YY_FAIL,YY_L	;IJKL
		DD	YY_M,YY_N,YY_O,YY_P		;MNOP
		DD	YY_FAIL,YY_R,YY_S,YY_T		;QRST
		DD	YY_U,YY_V,YY_W,YY_FAIL		;UVWX
		DD	YY_FAIL,YY_FAIL 		;YZ

DEF_TABLE	DD	DEF_EOF		;0
		DD	DEF_APPLOADER	;APPLOADER
		DD	DEF_CODE	;CODE
		DD	DEF_DATA	;DATA
		DD	DEF_DESCRIPTION ;DESCRIPTION
		DD	DEF_EXETYPE	;EXETYPE
		DD	DEF_EXPORTS	;EXPORTS
		DD	DEF_FUNCTIONS	;FUNCTIONS
		DD	DEF_HEAPSIZE	;HEAPSIZE
		DD	DEF_IMPORTS	;IMPORTS
		DD	DEF_INCLUDE	;INCLUDE
		DD	DEF_LIBRARY	;LIBRARY
		DD	DEF_NAME	;NAME
		DD	DEF_OLD 	;OLD
		DD	DEF_PROTMODE	;PROTMODE
		DD	DEF_RC
		DD	DEF_REALMODE	;REALMODE
		DD	DEF_SEGMENTS	;SEGMENTS
		DD	DEF_STACKSIZE	;STACKSIZE
		DD	DEF_STUB	;STUB
		DD	DEF_CODECLASSES ;CODECLASSES
		DD	DEF_NEWFILES	;NEWFILES & LONGNAMES
		DD	DEF_NOEMUFLOAT	;NO EMULATED FP INSTRUCTIONS
		DD	DEF_SUBSYSTEM	;DEFINE NT SUBSYSTEM REQUIRED
		DD	DEF_VERSION	;SET NT USER VERSION #
		DD	DEF_FIXDS	;TURN ON FIXDS PROCESSING


DOT_EXE		DB	'.EXE'
DOT_DLL		DB	'.DLL'


		END

